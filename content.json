{"meta":{"title":"扯淡有理","subtitle":null,"description":"Java Python R 机器学习 统计 扯淡","author":"naosense","url":"https://naosense.github.io"},"pages":[{"title":"Categories","date":"2025-09-16T02:08:43.026Z","updated":"2025-09-16T02:08:43.026Z","comments":true,"path":"categories/index.html","permalink":"https://naosense.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2025-09-16T02:08:43.026Z","updated":"2025-09-16T02:08:43.026Z","comments":true,"path":"about/index.html","permalink":"https://naosense.github.io/about/index.html","excerpt":"","text":"项目 markdown-preview-sync：基于java的vim markdown预览插件 Yiya：无字典中文分词小程序，取“咿呀学语”之意 NewBe：五子棋对战ai，支持人机对战、机机对战 好玩 北京二手房数据分析：恩，买哪个别墅呢 北邮人论坛征友分析：征友者说，我想要“这样的” GitHub: https://github.com/naosense 扯自己的淡，让别人去喷吧！"},{"title":"Tags","date":"2025-09-16T02:08:43.027Z","updated":"2025-09-16T02:08:43.027Z","comments":true,"path":"tags/index.html","permalink":"https://naosense.github.io/tags/index.html","excerpt":"","text":""},{"title":"Links","date":"2025-09-16T02:08:43.027Z","updated":"2025-09-16T02:08:43.027Z","comments":true,"path":"links/index.html","permalink":"https://naosense.github.io/links/index.html","excerpt":"","text":"RE1IFE’s Blog：一个淹死在时代浪潮里的coder 有想交换友链的同学，请按如下格式留言。 name: 扯淡有理 link: https://naosense.github.io description: 扯自己的淡，让别人去喷吧！"}],"posts":[{"title":"秋天到了跑步者的好日子来了","slug":"秋天到了跑步者的好日子来了","date":"2025-09-16T09:40:03.000Z","updated":"2025-09-16T02:08:56.242Z","comments":true,"path":"2025/09/16/秋天到了跑步者的好日子来了/","link":"","permalink":"https://naosense.github.io/2025/09/16/%E7%A7%8B%E5%A4%A9%E5%88%B0%E4%BA%86%E8%B7%91%E6%AD%A5%E8%80%85%E7%9A%84%E5%A5%BD%E6%97%A5%E5%AD%90%E6%9D%A5%E4%BA%86/","excerpt":"","text":"又逢秋节至，咱跑步者的好日子来了。春天冷，夏天热，秋高气爽跑起来就是爽啊！ 今年配速快了一些，心率和以往大差不差，高了一点，从5月以来基本维持60%左右的出勤率，也就是一个月跑个18次左右，因为只有工作日跑，间或偷个懒(^_−)，总共跑了300多公里了，争取年底跑到600公里！同志们都加油跑起来啊！","categories":[],"tags":[{"name":"跑步","slug":"跑步","permalink":"https://naosense.github.io/tags/%E8%B7%91%E6%AD%A5/"},{"name":"减肥","slug":"减肥","permalink":"https://naosense.github.io/tags/%E5%87%8F%E8%82%A5/"}]},{"title":"春风得意马蹄疾，今日回看梦黄粱","slug":"春风得意马蹄疾，今日回看梦黄粱","date":"2025-01-11T10:35:43.000Z","updated":"2025-09-16T02:08:42.975Z","comments":true,"path":"2025/01/11/春风得意马蹄疾，今日回看梦黄粱/","link":"","permalink":"https://naosense.github.io/2025/01/11/%E6%98%A5%E9%A3%8E%E5%BE%97%E6%84%8F%E9%A9%AC%E8%B9%84%E7%96%BE%EF%BC%8C%E4%BB%8A%E6%97%A5%E5%9B%9E%E7%9C%8B%E6%A2%A6%E9%BB%84%E7%B2%B1/","excerpt":"","text":"2014年，本书出版的年份，正是中美云淡风轻的时候，当时批毛之风盛行，因为什么呢？书中有句话印象深刻：“邓的理念是融入欧美经济体系”。经过30年的融入，中国正是春风得意的时候，包括作者在内的教授们以为中国已经走在正确的道路上，已经登堂入室了。可是美国这位好老师，偏偏爱教育人，狠狠得给了这帮人一记响亮的耳光，告诉这帮人，全球化你们还真信呢。要不毛泽东老是强调反面教材，原因大概是反面教材教育人它是真疼啊！ 毛泽东思想是斗争的哲学，是在实践中流血流汗得来得，是这些十指不沾阳春水，脚不曾踏过实地的教授们天生所排斥的。这些办公室研究员，客厅思想家写出来得东西天生带有自身的奴颜媚骨和想当然。他们分不清理想与现实，总以为这个世界是一个童话，你好我好大家好就可以了，不要那些打打杀杀。 总结下来，这是一本一名既得利益者为一群既得利益者写就得辩护书，盛名之下其实难副。附录尚可一读，其余都是春风吹又生的陈词滥调。 最后提醒一下，冯骥推荐得是《筚路蓝缕：计划经济在中国》，不是这本。","categories":[],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"文明的第一要义是生存","slug":"文明的第一要义是生存","date":"2025-01-11T07:49:58.000Z","updated":"2025-09-16T02:08:42.975Z","comments":true,"path":"2025/01/11/文明的第一要义是生存/","link":"","permalink":"https://naosense.github.io/2025/01/11/%E6%96%87%E6%98%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E8%A6%81%E4%B9%89%E6%98%AF%E7%94%9F%E5%AD%98/","excerpt":"","text":"拉丁美洲的历史总让人看的有一种无力感，就像一架进入尾旋的飞机，有人尝试改出，但功亏一篑，有人虎头蛇尾，半途而废，还有人冷眼旁观，事不关己……最后眼睁睁地看着它的高度越来越低，直到坠毁。 拉美被发现的太早，自己还没有充分发展，拉美被发现的又太晚，被发现时已落后太远。如果留给它充足的时间发展，也许它也会有自己的秦始皇，也许没有秦始皇也会有晋始皇，就像某些历史唯物论半瓶醋声称的那样。但是多少事，从来急，历史不是无菌的培养皿，文明之间也会弱肉强食，有些事一旦失去时机，就再也没有做的可能了。因为文明一旦消失，别说秦始皇就是李狗蛋也不会有了。现在，阿兹特克没人说话了，印加也没人说话了…… 拉美，不幸的拉美，一个起步太晚的文明，与世界发生联系时尚处于襁褓之中，在凛冽的现实环境中迅速的败下阵来以至于行将消亡。 文明的第一要义是生存，否则一切都是泡影。也许拉美还要在黑暗中摸索许多年才能找到自己的路，也许几百年，也许几千年，也许是接近于无限的永远。只是作为一个数学概念有意义的无限，对于一个文明、一个人，又有什么意义呢？","categories":[],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"第12章 数据系统的未来","slug":"第12章 数据系统的未来","date":"2024-02-02T17:14:57.000Z","updated":"2025-09-16T02:08:42.978Z","comments":true,"path":"2024/02/02/第12章 数据系统的未来/","link":"","permalink":"https://naosense.github.io/2024/02/02/%E7%AC%AC12%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AA%E6%9D%A5/","excerpt":"","text":"数据集成 派生数据与分布式事务通过不同的方式达到了类似的目标。分布式事务通过锁机制进行互斥来决定写操作的顺序，而CDC和事件源使用日志进行排序。分布式事务使用原子提交来确保更改只生效一次，而基于日志的系统通常基于确定性重试和幂等性。 派生数据允许逐步演变。想重建数据集，无需采用高风险的陡然切换。而是在同一个基础数据上的两个独立视图来同时维护新老两种架构。逐步将少量用户迁移到新视图中，以测试性能检测错误。最后，所有用户迁移完，放弃旧视图。 lambda架构 核心思想是将数据看成一个个不可变的事件，基于这些总事件，派生出读优化的视图。建议运行两套系统：一个批处理，一个流处理。批处理产生精确的全量视图，流处理产生及时的增量视图。 这样结合了两套系统的优点：批处理简单，不易出错，流处理不可靠，难以容错，但流处理可以使用快速的近似算法。 最近的发展是将批处理和流处理在同一个系统中实现，即所谓的kappa架构。 分拆数据库 整个组织的数据流就像一个巨大的数据库。每当批处理、流或ETL将数据从一个位置传输到另一个位置，就类似数据库子系统需要保持索引或实体化视图至最新状态。流处理，批处理就像触发器。没有统一的数据模型或存储格式适用于所有的访问模式，最终会统一为两种途径： 联合数据库：统一读端 为各种各样的底层存储引擎和处理方法提供一个统一的查询结构：一种称为联合数据库或聚合存储的方法。 分离式数据库：统一写端 跨系统的同步写。 传统的同步写依赖分布式事务，但是具有幂等写入的异步事件日志是一种更健壮的方法。 在系统级别，异步事件流使得组件终端或性能下降时表现更稳健。 在人员角度，分离式数据系统使得不同的团队可以独立的开发、改进和维护不同的软件和服务，可以更专业的专注于自己的领域。 分离和组合的目的并不是替代传统数据库，而是为了组合不同的系统，结合每个系统的优点去满足自己的需求。 流式处理与服务 前者是单向的，异步的，后者是双向的，同步的。假设客户正在购买一种商品，这种商品以某一种货币定价，但需要另一种货币支付。两种方式的实现： 对于微服务，同步查询汇率服务，以获取特定货币的当前汇率。 对于数据流，会预先订阅汇率变更流，并在本地数据库记录当前汇率。 但是要注意事件依赖，如果要重演当初的购买行为，汇率必须得是当时的。 写路径与读路径 写路径与读路径涵盖了数据的整个过程。写路径和读路径在派生数据集上交会，某种程度上，它是写入时需完成的工作量与读取时需完成的工作量之间的一种平衡。从这个角度看，缓存、索引和视图主要是调整读写路径之间的边界。 端到端的正确性 强制约束 一致性包含两个方面： 时效性 意味着确保用户观察到系统的最新状态。暂时的，最终通过等待和再次尝试来解决。 完整性 意味着避免数据损坏，即没有数据丢失，也没有互相矛盾或错误的数据。永久的，需要专门的检查和修理。 宽松的约束 为了性能或可用性通常会采用。 如果两个人注册了相同的用户名或预订了同一个座位，则可以向其中一个发送道歉消息。这种纠正错误的措施被称为补偿性事务。 如果订购的商品超出库存，可以追加补充库存，但需要为延误发货道歉，并提供折扣。 如果有人提款额比他们账户中的钱还多，银行可以向他们收取透支费用。 在许多商业环境中，实际上可以接受的是暂时性违反约束，稍后通过道歉流程来修复，关键是道歉的成本有多高。 信任，但要确认 也就是允许系统出错，但是要及时的发现和修复。 加密工具来证明系统的完整性，比如加密货币、区块链和分布式账本。密码审计和完整性检查常常依赖默克尔树（Merkle Tree）。 检查数据完整性也被称为审计。 做正确的事 技术是工具而不是目的，要用技术造福人类。本节讨论了一些开发问题，比如偏见和歧视、信息孤岛导致的囚笼效应，用户隐私保护等话题。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第11章 流处理系统","slug":"第11章 流处理系统","date":"2024-01-30T11:32:20.000Z","updated":"2025-09-16T02:08:42.978Z","comments":true,"path":"2024/01/30/第11章 流处理系统/","link":"","permalink":"https://naosense.github.io/2024/01/30/%E7%AC%AC11%E7%AB%A0%20%E6%B5%81%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一个可用的复杂系统总是从可用的简单系统演进来的。反过来这话也是正确的：从零开始设计的复杂系统从来都用不了，也没办法把它变成可用。 ——John Gal，《系统学》（1975） 发送事件流 消息系统 发送事件通知的常用方式。 如果生产者发送消息的速度快于消费者处理，会发生什么？ 如果节点崩溃或暂时离线，是否会有消息丢失？ 生产者与消费者直接消息传递 即无代理的方式。这种方式当消费者离线时会丢失消息。 常见场景： UDP组播广泛应用在金融行业，比如股票市场等低延迟场景。 无代理的消息库，如ZeroMQ和nanomsg，通过TCP或IP多播实现发布/订阅消息传递。 StatsD和Brubeck使用UDP手机网络中所有机器的指标并进行监控。 网络上公开服务，生产者直接发出HTTP或RPC请求将消息推送给消费者。 消息代理（无日志） 本质上是一种针对消息流处理而优化的数据库。常见产品Rabbit MQ、ActiveMQ等。 只能消费订阅之后的消息，也就是历史的消息已经不能消费了。 基于日志的消息存储 将历史的消息存储为日志形式。代表产品Kafka、Twitter DistrbutedLog。 数据库与流 事件是成功的命令。一个请求到来时最初是一个命令，它可能失败，或违反某种约束。一旦它成功，它就是一个事件了。 变更数据捕获（changed data capture，CDC）是一种设计理念。不是记录数据的当前状态，而是数据变化的过程。 事件溯源（event source）是一种强大的数据建模技术，是对CDC思想的一种应用。事件溯源使得应用程序随着时间的推移更容易演化，更安全，杜绝了直接覆盖数据的情形，更容易理解发生了什么来帮助调试分析。比如用户加购一个商品后又删除，使用事件溯源就会捕获到更多的细节，用户可能将来会买，或者找到了替代品。 流处理 流处理的使用场景 复杂事件处理（Complex Event Processing，CEP）可以在流中搜索特定的模式，类似于正则表达式。查询和数据的关系在CEP和普通数据库是反过来的。在普通数据库中，数据是长期存储的，查询是临时的，一旦查询完，查询就没了。而在CEP中，查询是长期的，输入流中的事件不断流过匹配查询。常见实现Esper、IBM Info Sphere Streams、Apama等。 流分析与CEP界限有些模糊。作为一般规则，分析往往不太关心找到特定的事件序列，而更多地面向大量事件的累积效果和统计指标。例如： 测量某种类型事件的速率。 计算一段时间内某个值的滚动平均值。 将当前的统计数据与之前的时间间隔进行比较。 流分析有时使用概率算法，比如布隆过滤器，基数统计的HyperLogLog，但是流不等于就是概率的，不精确的。 Actor与流： Actor是管理通信模块的并发和分布式执行的机制，而流处理是数据管理技术。 Actor之间交流往往是短暂的，并且一对一，而事件日志是持久的，多用户的。 Actor可以以任意方式进行通信（包括循环请求/响应模式），但流处理器通常设置在非循环流水线中，其中每个流是一个特定作业的输出，并且从一组定义明确的输入流派生而来。 流的时间问题 事件时间与处理时间 使用事件时间得确定什么时候结束，使用处理事件可能导致事件错乱，处理事件的顺序和事件时间不一样。 窗口类型： 轮转窗口 长度固定，每个事件都属于一个窗口。比如一个一分钟窗口，10:03:00~10:03:59分到一个窗口，10:04:00~10:04:59是下一个窗口。 跳跃窗口 也具有固定长度，但是允许重叠。例如一个五分钟窗口，设定跳跃值为一分钟，10:03:00～10:07:59为一个窗口，下一个窗口为10:04:00～10:08:59，以此类推。 滑动窗口 包含某个间隔内发生地所有事件。例如，一个五分钟的滑动窗口将包括10:03:39～10:08:12的事件，因为他们相距不到五分钟。可以通过保留按时间排序的事件缓冲区并从移除旧事件来实现。 会话窗口 没有固定的持续时间，而是通过将同一用户在时间上紧密相关的所有事件分组在一起而定义的，一旦用户在一段事件内处于非活动状态，则窗口结束。 流式join 流和流join 流和表join 表和表join","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"红楼梦人物关系图谱","slug":"红楼梦人物关系图谱","date":"2024-01-23T12:56:22.000Z","updated":"2025-09-16T02:08:43.018Z","comments":true,"path":"2024/01/23/红楼梦人物关系图谱/","link":"","permalink":"https://naosense.github.io/2024/01/23/%E7%BA%A2%E6%A5%BC%E6%A2%A6%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%B0%B1/","excerpt":"","text":"红楼梦中人物太多了，第一次读过以至于都没意识到宝玉和黛玉竟是表兄妹。最近重读，读了没几回，又迷糊了。索性系统整理了下里面人物的关系，以备后面查询。并不是面面俱到，但是主要的人物应该都在里面了，需要的同学自行取用。 宁国公（长子） 贾代化（长子） 贾敷（长子，早夭） 贾敬（次子） 贾珍（儿子） 尤氏（妻子） 贾蓉（儿子） 秦可卿（妻子） 秦业（父亲） 秦钟（弟弟） 智能（恋人） 宝珠（义女） 贾蔷（侄子） 龄官（恋人） 贾惜春（女儿） 入画（丫鬟） 荣国公（次子） 贾代善（长子） 史太君（妻子） 鸳鸯（丫鬟） 贾赦（长子） 邢夫人（妻子） 贾琏（儿子） 王熙凤（妻子） 尤二姐（妾） 尤三姐（妹妹） 柳湘莲（恋人） 巧姐（女儿） 平儿（丫鬟） 贾迎春（女儿） 孙绍祖（丈夫） 司棋（丫鬟） 贾政（次子） 王夫人（妻子） 金钏（丫鬟） 周姨娘（妾） 赵姨娘（妾） 贾珠（长子，早夭） 李纨（妻子） 李绮（堂妹） 甄宝玉（丈夫） 李纹（堂妹） 贾兰（儿子） 贾元春（长女） 抱琴（丫鬟） 贾宝玉（次子） 袭人（丫鬟） 晴雯（丫鬟） 麝月（丫鬟） 秋纹（丫鬟） 贾探春（庶女，母赵姨娘） 侍书（丫鬟） 贾环（庶子，母赵姨娘） 贾敏（女儿） 林如海（丈夫） 林黛玉（女儿） 雪雁（丫鬟） 紫鹃（丫鬟） 贾雨村（老师） 娇杏（妻子） 贾代儒 贾瑞父母（亡故） 贾瑞（儿子） 史家 史太君 史鼐（内侄） 史湘云（侄女） 王家 王公 王子腾（儿子） 王夫人（女儿） 薛姨妈（女儿） 凤姐之父（儿子） 王仁（儿子） 王熙凤（女儿） 刘姥姥（女婿狗儿祖父连过宗） 薛家 薛公 宝钗祖父 薛宝琴之父 薛蝌（儿子） 邢岫烟（妻子） 薛宝琴（女儿） 薛宝钗之父 薛姨妈（妻子） 薛蟠（儿子） 夏金桂（妻子） 香菱（妾） 甄士隐（父亲） 薛宝钗（女儿）","categories":[],"tags":[{"name":"红楼梦","slug":"红楼梦","permalink":"https://naosense.github.io/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"}]},{"title":"第10章 批处理系统","slug":"第10章 批处理系统","date":"2024-01-22T15:10:19.000Z","updated":"2025-09-16T02:08:42.978Z","comments":true,"path":"2024/01/22/第10章 批处理系统/","link":"","permalink":"https://naosense.github.io/2024/01/22/%E7%AC%AC10%E7%AB%A0%20%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"通过弄清数据的来龙去脉，来理清复杂的系统架构，是本书的宗旨。 三种系统： 在线服务（或称在线系统） 服务等待客户端请求或指令的到达。当收到请求或指令时，服务试图尽快的处理它，并发挥响应。响应时间和可用性是衡量标准。 批处理（或称离线系统） 接收大量的输入数据，运行一个作业来处理数据，并产生输出数据。衡量标准是吞吐量。 流处理（或称近实时系统） 流处理介于在线与离线之间。与批处理类似，流处理处理输入并产生输出。但是，流处理作业在事件发生不久就可对事件进行处理。 linux命令是单机版的批处理，map-reduce是分布式的批处理。unix工具使用stdin和stdout作为输入输出，MapReduce作业使用HDFS（Hadoop Distributed File System）分布式文件系统读写文件。 除HDFS外，还有GlusterFS和Quantcast File System（QFS）。注入Amazon S3，Azure Blob存储和Open Swift对象存储服务也有相似之处。 HDFS在每台机器上都有一个守护进程，并开放一个网络服务以便其他节点访问存储在该机器上的文件。名为NameNode的中央服务器会跟踪哪个文件存储在哪台机器上。 批处理的输出： 生成搜索索引。尽管如今Google不再使用MapReduce构建索引，但是MapReduce仍是构建Lucene和Solr的好方法。 构建机器学习系统。比如分类器（如垃圾邮件过滤，异常检测，图像识别）和推荐系统（可能认识的人，可能感兴趣的产品）。 MapReduce虽然在模型抽象上比较简单，但是使用起来却很不方便。例如，你需要从头开始实现全部join算法。 MapReduce在物化（将中间状态写入文件的过程）的过程中存在如下问题： 前面的作业完成之后，后面的作业才能开始。 Mapper通常是冗余的。它们通常是读取前一个reducer写入的文件，并为下一个分区和排序阶段做准备。通常可以和reducer放在一起。 中间状态会复制到多个节点。 为了解决这些问题，Spark、Tez和Flink等数据流引擎应运而生。它们有一个共同点：将整个工作流作为一个作业完成，而不是把它分解为独立的子作业。同时也不严格区分map和reduce角色，而是以函数运算符进行组合。优点： 排序等昂贵的操作只在需要的地方进行，而不是在map和reduce之间默认发生。 没有不必要的map，可以合并到前一个reduce中。 所有join和数据依赖都是明确声明的，调度器知道哪些是必需的，因此可以进行本地优化。比如将使用某些数据的任务放在生成数据的机器上，避免网络复制。 将中间状态保存在内存或本地磁盘就够了，比写入HDFS更省IO。 运算符在输入准备就绪后立即开始，不用等待上一阶段全部完成。 MapReduce每个任务启动一个JVM，现在可以重用JVM。 Spark、Flink和Tez为了避免写入中间状态，同时失败了能够重新开始计算，必须在框架层追踪给定数据是如何计算的，使用了哪个输入分区以及应用了哪个运算符。Spark使用弹性分布式数据集（Resilient Distributed Dataset，RDD）来追踪数据的祖先，Flink对运算符状态建立检查点。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第9章 一致性与共识","slug":"第9章 一致性与共识","date":"2024-01-11T17:25:39.000Z","updated":"2025-09-16T02:08:43.015Z","comments":true,"path":"2024/01/11/第9章 一致性与共识/","link":"","permalink":"https://naosense.github.io/2024/01/11/%E7%AC%AC9%E7%AB%A0%20%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/","excerpt":"","text":"一致性保证 分布式一致性与事务隔离级别有相似之处。但总体有着显著区别：事务隔离是为了处理并发执行事务时的各种临界条件，而分布式一致性则主要针对延迟和故障等问题来协调副本之间的状态。 可线性化 所谓线性化，就是让一个系统看起来好像只有一个数据副本，且所有操作都是原子的。可线性化是最强的一致性保证。 例如一个非线性化的体育网站。Alice和Bob坐在同一个房间里各自观看自己的手机，焦集的等待2014年FIFA世界杯决赛的结果。Alice率先看到了比赛结果，然后兴奋地告诉了Bob。结果，Bob刷新之后发现比赛还没有结束。 对于Dynamo风格的数据库，即时使用了严格的quorum（法定人数），在网络条件不好的情况下仍然不满足线性化。比如x初始值为0，写客户端向三个副本（n=3，w=3）发送写请求将x更新为1。客户端A在一个节点读到了新值1，客户端B在A读取之后读取，反而收到的都是旧值0。 CAP理论 不仅仅主从复制和多主复制，即使在一个数据中心内部，只要有不可靠的网络，都会发生违背线性化的风险。 CAP理论由Eric Brewer于2000年正式命名，最初是作为一个经验法则被提出，并没有准确的定义，它的含义是“在网络分区的情况下，选择一致性还是可用性”，目的是帮助大家探讨数据库设计的权衡之道，对于具体的系统设计来说意义不大。 如果要求线性化，由于网络方面的问题，某些副本断开之后，就必须等待网络修复，或者直接返回错误。无论哪种方式，服务都是不可用。 如果不要求线性化，断开连接后，每个副本可以独立处理请求例如写操作（多主复制）。此时服务可用，但结果行为不符合线性化。 可线性化与网络延迟 当前很少有系统真正满足线性化，原因是性能。比如现在多核CPU上的内存：如果某个CPU核上运行的线程修改了一个内存地址，紧接着另一个CPU上的线程尝试读取，则系统无法保证可以读到刚刚写入的值，除非使用了内存屏障或fence指令。 Attiya和Welch证明了如果想要满足线性化，那么读、写请求的响应时间至少与网络中延迟成正比。 顺序保证 顺序与因果关系 如果系统服从因果关系所规定的顺序，称之为因果一致性。 全序关系支持任意两个元素之间进行比较。比如自然数符合全序关系。还有一些元素在某些情况下可以比较，在某些情况下不可比较，称之为偏序。比如集合，当集合有包含关系时，可以比较，否则不可比较。 因果关系并非全序，可线性化强于因果一致性。 序列号排序 虽然因果关系很重要，但是在实际系统中跟踪这种关系却不切实际。在许多系统中，在写入之前会先读取大量的数据，系统无法了解之后的写入是依赖全部读取内容，还是部分。 一个更好的方法：使用序列号或时间戳（可以是逻辑时间戳）。这样所有的操作可以进行全序排序，从而捕获了所有的因果关系，同时强加了比因果关系更为严格的顺序性。 非因果序列发生器 每个节点都独立产生自己的一组序列号。比如一个产生奇数，一个产生偶数。 物理时钟。 给每个节点分配序列号区间范围。比如节点A为0~1000，节点B是1001~2000。 Lamport时间戳 每个节点都有一个唯一的标识符，且每个节点都有有一个计数器记录请求总数。它的形式是一个键值对：（计数器，节点ID）。可以解决上面三种序列号都可能与因果不一致的情况。 假设事件A和事件B的计数器为C(A)和C(B)，那么如果A在B之前发生，那么必有C(A) &lt; C(B)，反过来，如果C(A) &lt; C(B)，A并不一定发生在B之前。也就是说，时间戳与因果关系是必要不充分的。注意这里说的A发生在B之前是在说因果关系，来自于happen-before的直译，并不是现实中物理时间上发生的意义。 比如下面图中节点1事件(1, 1)小于节点2的事件(2, 2)，但是二者并没有因果关系，而是一种并行关系。 如果C(A) = C(B)，A和B是什么关系呢？答案是并行关系。比如上面的(1, 1)和(1, 2)、(6, 1)和(6, 2)。 也就是说，Lamport时间戳使得所有的事件都能比较，即全序，包括那些并行的事件，以及具有因果关系的事件。这样的结果是因果关系的事件先后顺序确实都没问题，但是并行事件实际发生顺序可能是错的。比如节点1事件(1, 1)的lamport时间戳小于节点2的事件(2, 2)，但是在物理时间上，后者可能先于前者发生。 时间戳排序依然不够 为了实现用户名唯一性约束这样的目标，仅仅对操作进行全序排列还是不够的，还需要知道这些操作是否发生、发生时间等。因为操作是分布式的，在当前节点用户名创建的这一瞬间，你需要收集到在其他节点上是否有其他请求也在创建同一个用户。 要想知道什么时候全序关系已经确定就需要“全序关系广播”。 全序关系广播 全序关系广播常指节点之间交换消息的某种协议。它要求满足两个基本安全属性： 可靠发送：没有消息丢失，如果消息发送到了某一个节点，则它一定要发送到所有节点。 严格有序：消息总是以相同的顺序发送到每个节点。 像ZooKeeper和etcd这样的共识服务实际上就实现了全关系序广播。 采用全序关系广播实现线性化存储 全序关系与线性化并不等同，但是关系密切。全序广播是异步的，保证以固定的顺序可靠的传递，但不能保证何时传递。相反，线性化是一种最近的保证，读取保证看到最新写入的值。 理解全序关系广播的一种方式是将其看作日志。传递消息就像追加方式更新日志。以全序关系广播以追加日志的方式来实现原子比较-设置操作（创建用户）： 在日志中追加一条消息，并指明想要的用户名。 读取日志，将其广播给所有节点，并等待回复。 检查是否有任何消息生成用户名已被占用。如果是中止操作，否则成功获得该用户名。 此过程实现了线性化写入，却无法保证线性化读取，即读取时可能是旧值。具体来说，这里只提供了顺序一致性，也称为时间一致性，弱于线性化保证。为了同时满足线性化读取，有以下几个方案： 可以采用追加的方式将读请求排序、广播，然后各个节点获取该日志，当本节点收到消息时才执行真正的读操作。消息在日志中的位置已经决定了读取发生的时间点。etcd的quorum读取和这个思路相似。 如果日志允许你以线性化的方式获取最新日志的位置，则查询该位置，等待直到该位置之前的所有条目都已经发送给你，接下来再执行读取。这与ZooKeeper的sync()操作思路相同。 可以从同步更新的副本上进行读取，这样确保总是读到最新值。这种技术可以用于链式复制。 （没看懂前面两点的不同） 采用线性化存储实现全序关系广播 也可以反过来，通过线性化实现全序广播。 最简单的方法是假设有一个线性化的寄存器来存储一个计数，然后使其支持原子自增-读取操作或者原子比较设置操作。 与Lamport时间戳不同，线性寄存器的数字不会存在间隙，因此如果节点完成了消息4的发送，且接收了序列6的消息，那么它对消息6回复之前必须等待消息5。Lamport时间戳规则不是这样，这是区别全序关系广播与时间戳排序的关键。 如果不存在失效，实现线性寄存器不难，否则就等同于分布式共识算法。可以证明，线性化存储、全序广播、分布式共识三者是等价的。 分布式事务与共识 2PC 两阶段提交（two-phase commit，2PC）是一种在多节点之间实现事务原子提交的算法，用来确保所有节点要么全部提交，要么全部中止。2PC在某些数据库内部使用，或者以XA事务形式（例如Java Transaction API）或SOAP Web服务WS-AtomicTransaction的形式提供给应用程序。 2PC在分布式数据库中负责原子提交，2PL提供可串行化的隔离。 2PC引入了一个角色：协调者（也称事务管理器），普通节点称为参与者。常见的协调者包括Narayana，JOTM，BTM或MSDTC。 2PC包括两个阶段： 阶段1：协调者询问所有参与者是否准备好？如果都回答“是”则进入阶段2，否则中止。 阶段2：协调者向所有参与者发送提交请求。如果有参与者超时或失败，协调者会一直重试，直到成功为止。 更详细的步骤： 当应用程序启动一个分布式事务时，首先向协调者请求事务ID。该ID是全局唯一的。 应用程序在每个节点上执行单结点事务，并将全局唯一事务ID附加到事务上。如果这个阶段出现问题，协调者和其他参与者都可以安全中止。 当应用程序准备提交时，协调者向所有参与者发送准备请求。如果任何一个参与者失败或超时，协调者通知所有参与者放弃事务。 参与者收到准备请求后，确保在任何情况下都可以提交事务（包括系统崩溃，电源故障或磁盘空间不足），包括安全地将事务数据写入磁盘，并检查是否存在冲突或约束违规。 如果所有参与者都返回是，那么协调者将发送提交请求，并将决定写入磁盘的事务日志中。这个时刻称为提交点。 协调者发送提交请求。如果有参与者超时或失效，协调者将会一直重试，直到成功。 类比结婚的例子，神父要问双方是否愿意嫁（娶）给对方，双方都回答“是”，神父才会宣布双方结为夫妻。并且，一旦说出“我愿意”就没有反悔的余地，即使之后马上晕倒了。 如果在参与者发送了准备好的回复后，协调者如果崩溃，参与者只能等待。因此2PC也被称为阻塞式原子提交协议。 实践中的分布式事务 分布式事务有严重的性能问题。例如，MySQL的分布式事务比单结点事务慢10倍以上。2PC性能下降的主要原因是事务日志以及额外的网络往返开销。 两类分布式事务： 数据库内部：VoltDB和MySQL Cluster的NDB存储引擎就支持这样的内部分布式事务。 异构：存在两种或两种以上的不同的参与者实现技术。 后者更具挑战。 XA交易 X/Open XA（eXtended Architecture，XA）是异构环境下实施两阶段提交的一个工业标准，1991推出。目前许多传统关系数据库（包括PostgreSQL、MySQL、DB2、SQL Server和Oracle）和消息队列（包括ActiveMQ、HornetQ、MSMQ和IBM MQ）都支持XA。 XA不是一个网络协议，而是一个与事务协调者进行通信的C API。也有其他语言的绑定，比如JTA（Java Transaction API），JTA支持非常多的JDBC（Java Database Connectivity）和消息队列驱动（JMS）。 当参与者失效或协调者崩溃时，分布式事务陷入停顿，因为参与者有可能持有锁，比如数据库事务通常持有行级独占锁。可串行化隔离中两阶段锁的数据库还对曾经读取的行持有读-共享锁。参与者或协调者恢复可能也有意外发生，比如参与者重启也不会放弃锁（2PC正确实现要求），协调者丢失事务日志，这个时候就需要人工介入。 支持容错的共识 共识问题的形式化描述：一个或多个节点可以提议某些值，由共识算法来决定最终值。共识算法必须满足以下性质： 协商一致性（Uniform agreement） 所有节点都接受相同的决议。 诚实性（Integrity） 所有节点不能反悔，即对一项提议不能有两次决定。 合法性（Validity） 如果决定了值v，则v一定是某个节点提议的。 可终止性（Termination） 节点如果不崩溃则最终一定可以达成决议。 协商一致性和诚实性定义了共识的核心思想：决定一经做出，就不能改变。有效性排除了一些无意义的方案。可终止性引入了容错的思想。它强调一个共识算法要有所作为，不能空转。可终止性是一种活性，其他三个特性是安全性。 可终止性的前提是发生崩溃或不可用的节点必须小于半数节点。 大多数共识算法都假定不存在拜占庭式错误。但是研究表明，只要发生拜占庭式故障的节点少于三分之一，也可以达成共识。 共识算法与全序广播 最著名的共识算法有VSR、Paxos、Raft和ZAB。这些算法其实并没有直接使用上面的形式化模型（四大属性）。相反，它们定义了一系列值，然后采用全序关系广播算法，这样更加高效。 全序广播的要点是，消息按照相同的顺序到达所有节点，有且只有一次（不丢失，不重复）。相当于多轮共识：在每一轮，节点提出它们接下来想要发送的消息，然后决定下一个消息的全局顺序。 由于协商一致性，所有节点决定以相同的顺序发送相同的消息（只是发送吗？）。 由于诚实性，消息不能重复。 由于合法性，消息不会被破坏，也不是凭空捏造。 由于可终止性，消息不会丢失。 VSR、Raft和Zab都直接采取了全序关系广播，这比重复性的一轮共识只解决一个提议更高效。 Epoch和Quorum 问题是想要达成决议，必须先有主节点，想要主节点得让所有节点达成某种共识，看起来这是一个死循环。解决之道就是本节的内容。 协议定义了一个世代编号（epoch number），对应于Paxos中的ballot number，VSP中的view number，以及Raft中的term number，并保证在每个世代中，主节点是唯一的。 两轮投票：第一轮决定谁是主节点，第二轮对主节点的决议进行投票。关键一点，参与两轮的quorum（法定人数）必须有重叠。这样可以确保：没有发生更高epoch的主节点选举，当前的主节点地位没有改变，可以安全地就提议进行投票。 投票过程看起来很像2PC。区别在于，2PC协调者不是靠选举产生；容错共识算法只需要收集大部分节点的投票即可通过决议，而不像2PC收集全部的投票。 成员与协调服务 ZooKeeper和etcd被称为“分布式键值存储”或“协调与配置服务”。大多数情况下，可能不会直接使用这些服务，而是在中间件中间接的使用。功能包括： 线性化原子操作：实现分布式锁。 操作全序：对每个操作都赋予一个事务ID（zxid）和版本号（cversion）。 故障检测：临时节点配合心跳检测。 更改通知：节点数据变化可以发送通知。 适用的场景： 节点任务分配 如果系统有多个实例，需要一个充当主节点。当主节点失效时，由其他节点来接管。或者分区动态增删，决定哪些分区分配给哪些节点。都可以使用ZK的临时节点和通知机制实现。 服务发现 例如，需要某项服务时，应该连接哪些ip等。传统上，通过服务名称获取IP地址使用DNS，它使用多层缓存实现高性能与高可用性，但是不满足线性化。 成员服务 用于确定哪些节点处于活动状态并属于集群的有效成员。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第8章 分布式系统的挑战","slug":"第8章 分布式系统的挑战","date":"2024-01-03T18:14:10.000Z","updated":"2025-09-16T02:08:43.013Z","comments":true,"path":"2024/01/03/第8章 分布式系统的挑战/","link":"","permalink":"https://naosense.github.io/2024/01/03/%E7%AC%AC8%E7%AB%A0%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/","excerpt":"","text":"对于大型分布式系统，部分组件失效几乎是一定的。 不可靠的网络 分布式系统故障或部分失效的一大原因。 检测故障 检测故障没有什么万能的方法，如果能收到响应，通常使用各种状态码标识，另一些情况下通用的办法就是超时了。 超时与无限期的延迟 超时成因： 负载过重，排队。 CPU繁忙。 虚拟机环境切换。 TCP流量控制（也称拥塞消除，或背压）。 TCP与UDP UDP不支持流量控制也不支持重传丢失的数据包，速度较快。如果延迟或丢失的数据价值不大，UDP是一个不错的选择。比如IP电话，应用程序会采用静音填充丢失的位置（出现短暂声音中断）。 超时设置长了或短了都不好。更好的方法是自动调整，比如Phi Accrual故障检测器，已经在Akka和Cassandra中使用。TCP重传也采用了类似的机制。 同步与异步网络 固定电话网在打电话时会动态建立一条电路：一个固定的、带宽有保证的通信链路，这种网络本质是同步的，不会受到排队的影响。由于没有排队，网络最大的端到端延迟是固定的。我们称之为有界延迟。 究其根本是目地不同，电话网线路持续时间短，要求及时性，而以太网追求资源的最大化利用。有了这个目的以太网才采用了分组交换协议，这样可以最大化的利用带宽：带宽小的时候我就传少点，带宽大的时候我就传多点。 简言之，网络中可变延迟并不是一种自然规律，只是成本与收益相互博奕的结果。 不可靠的时钟 计算机内部至少有两种时钟：墙上时钟（或称钟表时间）和单调时钟。 墙上时钟返回当前日期与时间。例如，Linux的clock_gettime(CLOCK_REALTIME)和Java中的System.currentTimeMillis()会返回子1970年1月1日（UTC）以来的秒数和毫秒数，不含闰秒。墙上时钟在和NTP同步的时候，可能会跳回先前的时间点，不适合测量时间间隔。 单调时钟如Linux的clock_gettime(CLOCK_MONOTONIC)和Java中的System.nanoTime()。单调时钟保证总是向前。 如果一些服务依赖时间戳，比如LWW系统，时间如果不准将会造成严重的后果。例如下面的例子，错误的时间戳导致客户端B的更新丢失。 某些软件如果在指定时间内无法相应则会导致严重后果，比如飞机、火箭、机器人、汽车和其他需要对输入传感器快速做出响应的组件等。对于这些系统，软件有一个必须做出响应的上限：如果无法满足，会导致系统级故障，这就是所谓的硬实时系统。 在嵌入式系统中，实时通常意味着系统经过了精心设计和测试，以满足各种情况下执行时间约束。Web中的实时则通常是指一种持续的流式处理方式，并没有强的时间约束。 知识，真相与谎言 真相由多数决定 在很多情况下，系统范围内只能有一个实例。例如： 只允许一个节点作为数据库分区的主节点，防止出现脑裂。 只允许一个事务或客户端持有特定资源的锁，以防止同时写入从而导致数据破坏。 只允许一个用户来使用特定的用户名，从而确保用户名可以唯一标识用户。 在分布式系统中，某个节点自认为它是“唯一的那个”，但不一定获得了系统法定票数的统一！例如下面由于不正确加锁而导致数据破坏的例子。 一种简单的解决办法是使用栅栏（fencing）：每次锁服务在授予锁或租约时，还会同时返回一个fencing令牌，该令牌每授予一次都会递增。然后，要求客户端每次向存储系统发送写请求时，都必须包含所持有的fencing令牌。 使用ZooKeeper作为锁服务时，事务标识zxid或节点版本cversion都可以充当令牌。 拜占庭故障 fencing令牌可以检测并阻止哪些无意的误操作。如果节点存在“撒谎”的情况（即故意发送错误或破坏性的响应），这种行为称为拜占庭故障，在这样的不信任环境钟需要达成共识的问题也被称为拜占庭将军问题。 拜占庭将军问题指有n位将军需要达成共识，并且其中存在一些叛徒试图阻挠达成共识。大多数将军都是忠诚的，而且大家事先并不知道叛徒是谁。 如果系统中部分节点故障，甚至不遵从协议，或者恶意估计、干扰网络，但仍可运行，那么我们称之为拜占庭式容错系统。这些担忧在某些特定场景是合理的。例如： 航空航天领域，计算机内存或CPU寄存器受辐射影响，导致以不可预知的方式响应其他节点。 在多个参与者的系统中，某些参与者可能会作弊或者欺骗他人。比如比特币或其他区块链一样的点对点网络就是让互不信任的双方就某项交易达成一致，且不依赖集中的机制。 尽管我们假设节点通常是诚实的，但有必要防范一些不那么恶意的“谎言”。例如： 由于硬件问题或操作系统、驱动程序、路由器等方面的错误，导致网络数据包又是出现损坏。可以借助校验和来校验和发现这类问题。 对公众开放的应用必须仔细检查用户的所有输入。例如输入值是否在合理范围、有没有不合理的字符。 NTP客户端最好配置多个时间服务器。 理论系统模型与现实 关于计时，有三种常见的系统模型： 同步模型。假定有上界的网络延迟，有上界的进程暂停和有上界的时钟误差。 部分同步模型。系统在大多数情况下像一个同步系统一样运行，但有时候会超出上界。这是一个比较现实的模型。 异步模型。对时机没有任何假设，甚至里面根本没有时钟。 节点失效，也有三种模型： 崩溃-终止模型。一个节点只能以一种方式发生故障，即遭遇系统崩溃。 崩溃-恢复模型。节点可能会在任何时候崩溃，且可能会在一段（未知的）时间之后恢复并再次响应。 拜占庭（任意）失效模型。节点可能发生任何事情，包括试图作弊和欺骗其他节点。 安全性通常可以理解为“没有发生意外”，活性则类似“预期的事情最终一定会发生”。比如，唯一性和单调递增属于安全性，可用性和一致性属于活性。区分安全性和活性的一个好处是可以帮助简化处理一些具有挑战性的系统模型。安全性是必须要满足的，活性的满足则需要一定的必要条件。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"元旦西安跨年行","slug":"元旦西安跨年行","date":"2024-01-03T09:16:44.000Z","updated":"2025-09-16T02:08:42.964Z","comments":true,"path":"2024/01/03/元旦西安跨年行/","link":"","permalink":"https://naosense.github.io/2024/01/03/%E5%85%83%E6%97%A6%E8%A5%BF%E5%AE%89%E8%B7%A8%E5%B9%B4%E8%A1%8C/","excerpt":"","text":"29号请了一天假，1号回来的，总共玩了三天。 第一天 城墙-鼓楼-回民街-洒金桥-钟楼 29号上午12点到的，去酒店旁边的澄城水盆羊肉吃了个水盆羊肉套餐，也许是饿了，味道是真不错，最后连汤都喝干净了。 稍微休整了下，我们就奔城墙而去了。查了下距离，离得不远，也就一公里多，我们就走着过去了。 从永宁门买的票，到长乐门下来的，走了整个城墙的小1/4圈。顺便提一句，碑林也在永宁门附近，不过我们没去。没骑自行车是因为有小孩，自行车只有单人和双人。当天人不多，或许是还没放假。城墙的一半被围起来了，看着里面在扎花灯。 从长乐门下来后，我们一路又走到了回民街。回民街其实相当于北京的南锣鼓巷，就是一条小吃街，只不过比南锣鼓巷要大。我们大概是晚上7点到的回民街，人也不多。尝了尝桂花糕和烤串，烤串和北京回民烤串差不多，都是外面裹一层东西再烤。桂花糕我觉得桂花太少了，几乎没有桂花味。其他小吃如肉夹馍、凉皮、泡馍之类没啥欲望，在北京或多或少都吃过。 看网上说洒金桥是当地人比较喜欢去的小吃街，我们一路又转到洒金桥。离回民街不远，大概一公里。在这吃到了在家尝试过的粉蒸牛肉。和自己做的相比，他的味道花椒茴香味比较浓，面比较散，不像自己做的面是黏的 但是他的肉比较硬。总之，吃起来并没有网上视频说的那么惊艳。 最后从洒金桥又走到了钟楼。本来想打车的，但是所到之处都是一些小街小巷，怕出租车不好进。在这扫了一个共享单车，推着孩子一路走到了钟楼。钟楼算是西安的标志性建筑了。有好多小姐姐身着汉服在这拍照，搔首弄姿，好不热闹。 回到酒店一看走了27000多步，这一天可把大家累坏了，sign。其实这一天的大部分路都可以打车，只是这样会少很多体验感，这也算是一种取舍吧。 第二天 大雁塔-大唐不夜城 不能免俗，我们也去租了身汉服，地点就在钟楼附近的汉服城。下面是一个一个的小隔间，各种各样的汉服应有尽有，价格100-300一天不等。 化好妆吃了午饭会酒店休息了一会。我在马蜂窝查到的信息大雁塔喷泉是4点6点8点各有一场，4点天太亮没效果，就奔6点这场了。到达的大雁塔4点多，逛了一阵就快6点了。原本想等着6点看喷泉，谁知保安说7点才有，想着先去大唐不夜城转转，等会再回来看。这两个地点离得很近，没想到一转就转不回来了，因为大唐不夜城太大了，再加上晚上人开始多了，实现单向管制了，想回来必须得绕一大圈。 大唐不夜城太大了，里面还有各种表演，想一次转完太难了。算下来，我们只看了一个表演：贞观之治，吃了若干小吃，没有看到著名的不倒翁小姐姐。不过，既然是旅游，不妨随性一点，所谓“乘兴而来，兴尽而归”，氛围感受到了就行了。 第三天 华清池-兵马俑 今天有个大坑，大家可要看仔细了。 差不多十年前我去过一次，当时自己一个人去的，坐的公交车，没有请讲解。和大多数景点一样，看了啥印象都没有。所以，这次想着报个一日团，一来车接车送，二来有个讲解。两大人一小孩总共550倒也不贵，没成想，上了车就被那导游花言巧语把我骗，把我骗哎呀啊。 事情是这样的，上车暖场后，导游就说起来兵马俑的面积之大，文化之深，什么相当于故宫的多少倍，分为东西两区，西区是活的兵马俑，东区是死的兵马俑，活的看懂了才能看懂死的，活的死的都要看云云（事后才知道所谓西区就是私人开设的小型体验馆，东区才是真正的兵马俑一二三号坑）。 接下来就是图穷匕见的时刻了，大家记住两个关键字：铁鹰锐士和地宫，这两个项目加起来每个人要补278。所谓铁鹰锐士就是一个小型体验馆，地宫就是一个十分钟的VR。其实这时候我已经知道这是套路了，但是一来我被导游在车上绘声绘色的描述整好奇了，二来带着孩子想多体验点东西，三来她说如果不看活的兵马俑，死的就没有讲解了，所以就报了。 平心而论，这两个项目合起来能值100-120，但是收费278属实是贵了。事后发现，不报这两个项目完全没问题，兵马俑讲解根本就不是导游，而是博物馆内部工作人员，不存在没有讲解的情况，导游在游览兵马俑景区的作用只是引导你去各种地点，参与度很低。不报这两个项目，只需要按时去参观兵马俑一二三号坑就行。导游就是连哄带骗带你入坑。不想被骗的话只需收起好奇心，态度坚决点拒绝就行。 抛开这个插曲，这个一日团还不错，车接车送，华清池和兵马俑两个景点门票和讲解，一顿午餐。华清池是导游讲解的，讲的也不错。兵马俑的讲解是博物馆内部人员，也非常不错。只是当天人太多了，一号坑那里简直像赶集一样，走路只能向前挪动，到了后面的二号坑三号坑就好多了。多亏有了讲解，比我那次单枪匹马游览强多了。 回程的路上，不出意外，导游又开始套路卖特产了哈哈。不过都是些小打小闹，就不细说了。后来我自己去特产店买的，差的不多。 总之，这趟西安之行整体感觉还不错，吃的住的都没遇到坑，景点也各有特色。相比于北京故宫的金碧辉煌，我更喜欢西安古建的古朴大气。和十年前一样，游览的这三天，西安的雾霾没断过，不知是不是冬天取暖导致的。 顺便提一句几块比较大的费用吧，北京到西安来回路费2600左右，住宿三天1000左右，景点门票+旅游团1200左右，总共5000左右。住宿建议住在钟楼附近，钟楼应该是西安的中心，这个地方离哪里都不远。","categories":[],"tags":[{"name":"西安","slug":"西安","permalink":"https://naosense.github.io/tags/%E8%A5%BF%E5%AE%89/"},{"name":"旅游","slug":"旅游","permalink":"https://naosense.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"兵马俑","slug":"兵马俑","permalink":"https://naosense.github.io/tags/%E5%85%B5%E9%A9%AC%E4%BF%91/"},{"name":"回民街","slug":"回民街","permalink":"https://naosense.github.io/tags/%E5%9B%9E%E6%B0%91%E8%A1%97/"},{"name":"华清池","slug":"华清池","permalink":"https://naosense.github.io/tags/%E5%8D%8E%E6%B8%85%E6%B1%A0/"}]},{"title":"2023，程序员佛系减肥在路上","slug":"2023，程序员佛系减肥在路上","date":"2023-12-27T19:40:17.000Z","updated":"2025-09-16T02:08:42.938Z","comments":true,"path":"2023/12/27/2023，程序员佛系减肥在路上/","link":"","permalink":"https://naosense.github.io/2023/12/27/2023%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BD%9B%E7%B3%BB%E5%87%8F%E8%82%A5%E5%9C%A8%E8%B7%AF%E4%B8%8A/","excerpt":"","text":"最初的动机 其实一直对体重都没怎么注意过，男的嘛，对自己身材没那么在意，只是每年买的裤子到下年就不能穿了，浪费了不少钱（笑）。 直到上年年底体检，体检报告上有一项“超重，脂肪肝（中）”，着实还是给了我一点小小的震撼。以往的体检顶多是“甘油三酯高，转氨酶高”，现在好家伙都发展成中度脂肪肝了。我当时BMI已经超过25，体重一度逼近160。 为了“为祖国健康工作五十年”的宏伟目标，我决心要把这个肥给减下去。 取得的成果 今年一年跑步历程。 今年一年体重变化。 之前异常的指标去年今年对比。 指标 2022 2023 参考值 体重 78.5 71.7 – 甘油三脂 4.24 1.64 0.45~1.70 丙氨酸氨基转移酶 52 29 0~50 γ-谷氨酰转移酶 78 35 10~60 算下来，瘦了没几斤，但是效果非常显著。就连连续几年一直居高不下的甘油三酯和两个转氨酶也头一次正常了，这真的意想不到。 虽说这次跑步的初衷是减肥，但收获不止于此，还收获了一个附属品——恒心，所谓“一事有恒，万事渐振”。朋友都说没之前臃肿了，人的精神状态也变好了。 采取的行动 我比较懒散，因此也没制定计划。因为根据以往的经验，计划对我来说非但不会让我坚持下去可能还有反作用。每天想跑就跑，实在哪天不想跑，就不跑。 其次呢，就是晚饭不吃正餐，吃点水果。但是呢，哪天如果实在饿，也吃晚饭。也不计算卡路里摄入量这些东西，主打就是一个随性和佛系。 有人说，不吃晚饭我饿呀，饿的睡不着。你别说，我第一天没吃晚饭确实是这样子的。打工人中午这顿饭离睡觉太长了，晚上一点不吃真不行，因此我将其调整为不吃正餐，吃点水果啥的。 如何坚持 詹姆斯.克利尔在《掌握习惯》中介绍了习惯的四大定律： 让习惯显而易见。 让习惯有吸引力。 让习惯简便易行。 让习惯令人愉悦。 我上面说不制定计划，不计算卡路里，就是为了让习惯显而易见和简便易行，跑步就是简单的迈开腿跑就是了，没有距离快慢的要求。 那怎么让跑步变得有吸引力？合理利用自己的虚荣心是一种方式。比如使用一些关注长期主义的软件如miles、running_page记录自己跑步的历程。 还可以给自己的跑步赋予更多的意义。比如将省下的饭钱捐出一些，来达到令人愉悦的目的，赠人玫瑰，手留余香嘛。 还有一招，我称之为“减量不减次”：如果哪天不想跑，不要完全不跑，而是适当的减少跑步的距离。比如你平常跑五公里，那现在就跑三公里，甚至一公里，这样可以提高放弃的门槛。你明天状态好了，还可以跑回来，避免轻易地放弃，否则很容易有“反正昨天没跑，计划已经断了，没必要再坚持了”的想法。类似于股票跌的时候不要一下子全卖掉，而是逐次抛售，万一明天涨回来你还可以继续持有。 不过话说回来，如果状态实在不好，也千万不要强迫自己。比如有时候上一天班感觉很累，那就停一天，没啥大不了。 对了，如果能够找个人结伴跑步也会有助于坚持下去。我之前在小区一个人跑，跑不多远就累了，后来和一个同事一起跑，跑得又快又轻松。 去哪里跑 我觉得作为打工人能选择的跑步地点按优先级有以下几种： 有跑道的公园。 小区道路。 人行辅路。 跑步机。 第1种可遇不可求，如果家门口或者办公地点附近有这种地方，不用说，这是首选。如果离得太远，特意过去跑步，就有点得不偿失。 第2种属于内部道路，比较安全，但是通常来说比较短，跑起来容易乏味。还有一点，小区里楼比较多，路短，根据我个人经历，GPS跟踪不太准。 第3种属于外部路，人车混杂，如果晚上跑得话，视野不好，路况不好的话容易崴脚。而且晚上这种道路上，遛狗的，送外卖的，电动车，自行车，狗绳，你都得花精力躲避，搞不好还有危险。我试着跑了一段时间，就放弃了。 跑步机的话，一般我冬天才会选择。密闭空间，跑起来比较乏味，空气也不好。 刚开始，我就在小区跑，后来发现上班的地方附近正好有个临河公园，有健身跑道，我就去那了。 早上还是晚上 作为打工人，生活在城市中，早上跑的好处是人少，视野开阔，空气好（一说早上空气并不好）；晚上跑身体机能已经完全预热，时间也比较充裕，好安排。 我现在选择的是晚上。也试过早上，给我的感觉是跑起来心跳很快，就好像身体还没完全打开，就改成晚上了。 不过大家大可不必在这个事上纠结，所谓选择困难症往往是因为“想的多，做的少”。犹豫不决的时候试下就知道，没有多少成本。 没时间怎么办 其实跑步花不了多长时间。按六分钟配速，如果跑两公里的话，跑步洗澡半小时也够了。我是不信一个人一天挤不出来半小时时间的，一集电视剧都不止半小时！ 如果实在找不出成块的时间，还可以碎片式跑步，比如从家到地铁的这段路上可以利用起来。 每逢过节胖三斤 非常有道理啊。大家可以看上面的体重波动，五一、十一这些假日确实会反弹。究其原因，我个人的情况应该是过节没法正常节食，好不容易放假回趟家，父母怎么能允许你节食呢？一方面吃的多了，另一方面也不规律地跑步了，体重自然就上来了（笑）。 不过问题不大，一旦假期结束，重新跑起来，体重很快就会恢复正常。 写在最后，就像丹尼尔.利伯曼在《锻炼》中建议的那样： 为了自己的身体，动起来，为了自己的脑子，动起来。 对于大部分人，每周150分钟的中强度锻炼即可，多了没坏处，但也没多大用。大多数时间进行有氧运动，但也别忘了加入一些力量训练。 力量训练我也是从简，就是做做俯卧撑。 总之一句话，开跑有益，无论是在生理上还是心理上！","categories":[],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://naosense.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"跑步","slug":"跑步","permalink":"https://naosense.github.io/tags/%E8%B7%91%E6%AD%A5/"},{"name":"减肥","slug":"减肥","permalink":"https://naosense.github.io/tags/%E5%87%8F%E8%82%A5/"}]},{"title":"第7章 事务","slug":"第7章 事务","date":"2023-12-25T11:02:15.000Z","updated":"2025-09-16T02:08:43.007Z","comments":true,"path":"2023/12/25/第7章 事务/","link":"","permalink":"https://naosense.github.io/2023/12/25/%E7%AC%AC7%E7%AB%A0%20%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"深入理解事务 事务将多个读写操作捆绑成一个逻辑整体，要么都成功，要么都失败。 ACID 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 BASE 基本可用性(Basically Available)，软状态（Soft state）和最终一致性（Eventual consistency）。 各家数据库所实现的ACID并不尽相同，更像是一个市场营销用语。BASE是另一套标准，同样模棱两可，唯一可以确定的是“它不是ACID”。 原子性 要么成功，要么失败，不能部分成功部分失败。 在ACID的语境中，指的是出错时终止事务，并将部分完成的写入丢弃。 一致性 一致性是指对数据有特定的预期状态（满足特定的约束），比如银行贷款和借款余额保持相等。 一致性是应用层提供的属性，其他三个是数据库应提供的属性。 隔离性 并发执行的多个事务互相隔离，不能交叉。多个事务执行的效果和串行执行一样，但内部实现不要求一定串行执行。 下面的例子中，用户1和用户2分别更新同一个对象，最终结果本来应该为44，现在是43。由于没有隔离，导致用户1的更新丢失。 持久性 提供一个安全可靠的地方存储数据而不用担心数据丢失。在计算机语境下常常指写入磁盘。 单对象与多对象事务操作 单对象事务，比如向数据库写入20KB的JSON文档，多对象事务，比如外键的更新，二级索引的更新等。 弱隔离级别 所谓弱隔离级别在这里的意思是非串行化。 MySQL等数据库的四种隔离级别：读未提交，读提交，可重复读，串行化。 读-提交 读-提交是最基本的隔离级别，它指提供如下两个保证： 读数据时，只能看到已成功提交的数据（防止“脏读”）。 写数据时，只会覆盖已成功提交的数据（防止“脏写”）。 读-提交非常流行，它是Oracle 11g、PostgreSQL、SQL Server 2012、MemSQL以及许多其他数据库的默认配置。 脏写一般通过行级锁来实现，当事务想修改某个对象，它必须先获取该对象的锁。 脏读的话，理论上也可以这么做，但是这样做性能太差。因此，实际一般都是维护旧值和当前事务设置的新值两个版本。在事务提交前，读取旧版本，事务提交后，才读取新版本。 快照级别隔离与可重复读 读-提交有不可重复读（nonrepeatable read）或读倾斜（read skew）[1]的问题。 转帐者从账户1转帐100块到账户2，初始时两个账户都是500块钱，由于发生了脏读，Alice看到了转帐事务的中间状态，她看到账户1是500块，账户2是400块，少了100块。 这种问题，在一些场景是不可接受的： 备份场景：备份里可能含有新旧两个版本的数据，如果从这样的备份恢复，最终就会导致永久的不一致。 分析查询与完整性检查：这种查询可能会扫描大半个数据库，亦或定期的数据完整性检查。如果这些查询在不同的时间点观察数据库，可能会返回无意义的结果。 快照级别隔离是最常见的解决方法。它的想法是，每个事务都从数据库的一致性快照中读取，事务一开始锁看到的是最近提交的数据，即使数据随后被其他事务修改，但保证每个事务都只能看到特定时间点的旧数据。 基本上常见数据库都实现了这种隔离级别。 采用一种类似于读-提交中防止脏读但更通用的方案，保留对象的多个不同的提交版本，这种技术称为多版本并发控制（Multi-Version Concurrency Control，MVCC）。 既然是更通用的方案，因此在实现读-提交时，干脆也用MVCC，通过维护对象的两个版本就够了：一个已提交的旧版本和尚未提交的新版本。典型做法是，在读-提交级别下，对每一个不同的查询创建一个快照；在快照隔离级别下，则使用一个快照来运行整个事务。 前面不是说两个版本就够了，为啥后面又说一个查询一个快照呢？ 我个人理解，在读-提交级别下，事务中每个查询都创建一个快照是为了反映最新的提交。虽然是每次查询都创建一个新的快照，但是新的快照是覆盖旧的快照得来的，在每一个时刻，系统始终只有两个版本。因此前文说只需要两个版本，后面又说一个查询一个快照，不矛盾。 一致性快照的可见性规则 每笔事务开始时，列出所有当时尚未提交的其他事务，忽略这些事务的部分写入。 所有中止事务所做的修改全部不可见。 较晚事务所做的修改不可见。 除此之外，其他所有写入都可见。 换句话说，仅当以下两个条件都成立，则改数据对象对事务可见： 事务开始的时刻，创建该对象的事务已经完成了提交。 对象没有被标记删除，或者即使标记了，但删除事务在事务开始时还没有完成提交。 一句话，就是一个事务只能看到它开始之前已经提交的事务所做的修改。 索引与快照级别隔离 多版本数据库如何支持索引： 将索引指向对象的所有版本，然后想办法过滤对当前事务不可见的那些版本。典型如PostgreSQL。 采用追加式的BTree，更新时，不是原地修改，而是创建一个修改副本，拷贝必要内容。 防止更新丢失 读提交和快照隔离没有解决两个写事务并发，而脏写只是写并发的一个特例。最著名就是更新丢失问题，比如： read-modify-write场景。 对复杂对象的一部分内容执行修改，再写回。 两个用户同时编辑wiki页面，覆盖现有内容。 解决方案： 原子写操作。类似于Java语言中的CAS操作，比如下面指令UPDATE counters SET value = value + 1 WHERE key = 'foo'; 从实现上一是加独占锁，二是强制在单线程上运行。 显式加锁。如果数据库不支持原子操作，可以显式锁定待更新的对象。BEGIN TRANSACTION; SELECT * FROM figures WHERE name = 'robot' AND game_id = 222 FOR UPDATE; -- Check whether move is valid, then update the -- position of the piece that was returned by the previous SELECT. UPDATE figures SET position C4 WHERE id = 1234; COMMIT; FOR UPDATE对返回的所有结果行加锁。 自动检测更新丢失。属于一种乐观锁机制，也就是先并发执行，如果事务管理器检测到了更新丢失的风险，回退到安全的“读-修改-写回”方式。可惜的是并不是所有的数据库都实现了这种机制。 写倾斜与幻读 一个例子，正在开发一个程序帮助医生管理轮班。通常，会安排多个医生值班，医生也可以调整班次，但得确保至少一位医生值班。 现在Alice和Bob两位值班医生，碰巧都感觉身体不适，在同一时刻点击调班按钮。在快照隔离级别，前置检查都返回两位医生，所以两个事务都进入下一阶段，最终导致没有任何医生值班。 这种异常称之为写倾斜。它不是脏写，也不是更新丢失。可以将其看作一种更广义的更新丢失问题。即两个事务先读取相同的一组对象，更新其中的一部分：不同的事务可能更新不同的对象，则可能发生写倾斜；如果更新同一个对象，则可能发生脏写或更新丢失。 更多例子： 会议系统，多人抢占一个会议室。 多人游戏。 声明一个用户名，保证唯一性。 防止双重开支，避免同时插入两个开支项目。 在一个事务中的写入改变了另一个事务查询结果的现象，称为幻读。快照级别的隔离可以避免只读查询时的幻读，但是无法解决写倾斜。 串行化 写倾斜的解决方法是串行化。即事务可以并行执行，但是执行结果必须和串行执行相同。 实际串行执行 使用存储过程单线程运行。但有一下限制： 事务必须简短而高效，否则一个慢事务会影响所有其他事务的性能（和异步化类似）。 仅限于活动数据集完全可以加载到内存的场景。访问磁盘会严重拖累性能。 写入吞吐量必须足够低，才能在单个CPU上处理；否则就需要分区，最好没有跨分区事务。 跨分区事务虽然也可以支持，但是占比必须很小。 两阶段加锁 快照隔离级别“读写互不干扰”，2PL读写是互斥的。它的想法是： 如果事务A已经读取了某个对象，此时事务B想写入该对象，那么B必须等到A提交或中止才能继续。 如果事务A已经修改了对象，事务B想要读取该对象，则B必须等到A提交或中止才能继续。 两阶段加锁（2PL）听起来和两阶段提交（2-phrase commit，2PC）很相近，但它们是完全不同的东西。 目前2PL已经用在了MySQL（InnoDB）和SQL Server的“可串行化隔离”，以及DB2中的“可重复读隔离”。 实现方案为为每个对象都维护一个读写锁来隔离读写操作。即锁可以处于共享模式或独占模式，运行机制如下： 如果事务要读取对象，必须获得共享锁。多个事务可以同时获得一个共享锁，但是如果某个事务已经获得了独占锁，则所有事务必须等待。 如果事务要修改对象，必须以独占模式获得锁。不允许多个事务同时持有该锁（包括共享或独占模式）。 如果事务首先读取对象，后面想尝试写入，则需要将共享锁升级为独占锁。 事务获得锁之后，一直持有锁直到事务结束。这也是“两阶段”的来由，在第一阶段即事务执行之前获取锁，第二阶段即事务结束时释放锁。 也就是只有共享-共享可以共存，独占-独占，共享-独占都是互斥的。 锁的实现： 谓词锁。也就是符合某种搜索条件的所有查询对象共同持有一个锁。 索引区间锁。谓词锁性能较差，索引区间锁是谓词锁的简化版，实现原理是将保护的对象扩大化，也就是锁粗化。比如谓词条件是：房间123，时间段是中午到下午1点，索引区间锁即只保护房间123的所有时间段。如果没有合适的索引可以施加区间锁，会回退到整条加共享锁。 2PL自1970年提出后不被广泛接纳的原因是相比弱隔离级别吞吐量和查询响应下降的非常多。 可串行化的快照隔离 SSI（Serializable Snapshot Isolation），在2008年被首次提出，提供了完整的串行化保证，性能比快照隔离损失很小。 目前用在了PostgreSQL9.1之后的可串行化隔离和分布式数据库如FoundationDB。 它的想法是让事务并发执行，寄希望于相安无事，当事务提交时，数据库检查是否确实发生了冲突，如果是的话，中止事务并接下来重试。 2PL是一种悲观并发控制机制，SSI是一种乐观并发控制机制。 为了实现串行化的隔离，数据库必须检测事务是否会修改其他事务的查询结果，并在此情况下，中止事务。也就是SSI等于快照隔离+修改检测机制。 数据库如何知道查询结果是否发生改变？分两种情况[2]： 读取之前是否有未提交的写入。 读取之后是否又有新的写入。 检测是否都去了过期的MVCC对象 为防止这种异常，数据库会跟踪那些由于MVCC可见性规则被忽略的写操作。当事务提交时，数据库会检查是否存在一些当初被忽略的写操作现在已经完成了提交，如果是必须中止当前事务。 事务43在开始之前有一个未提交的事务42，事务43读取之后，事务42修改了值班人，这导致事务43之前的读取过期了，事务管理器注意到这种情况，及时中止了事务43，并重试。 为什么要等到提交才检测？因为无法预测当前事务是否有写动作，也无法预料写事务是否成功。 检测写是否影响了之前的读 第二种要考虑的情况是，在读取数据之后，另一个事务修改了数据。 和上面类似，事务43在开始之前有一个未提交的事务42，和之前不同的是，之前事务42的修改发生在事务43的读取之前，现在是读取之后，但效果是类似的，事务管理器注意到事务43的读取结果已经发生了改变，只好中止事务并重试。 可串行化快照隔离的性能 和2PL相比，SSI不需要加锁。和快照隔离一样，读写不会互相阻塞。使查询延迟更加稳定、可预测。 与串行化相比，SSI可以突破单个CPU的限制。FoundationDB将冲突检测分布在多台机器上，从而提高总体吞吐量。 二者是一个意思。 ↩︎ 我感觉这两种情况是一回事啊。 ↩︎","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第6章 数据分区","slug":"第6章 数据分区","date":"2023-12-19T16:41:16.000Z","updated":"2025-09-16T02:08:43.000Z","comments":true,"path":"2023/12/19/第6章 数据分区/","link":"","permalink":"https://naosense.github.io/2023/12/19/%E7%AC%AC6%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/","excerpt":"","text":"面对海量数据集或非常高的查询压力，光有副本还不行，还需要将数据拆分为分区，也称为分片。事实上，分区和副本常常结合起来使用，来提高系统的扩展性和可用性。 分区方式 分区的目标是将数据和查询负载均匀分布在所有节点上。 如果分区不均匀，那就会出现某些分区比其他分区承担更多的数据量或查询负载的情况，称之为倾斜。极端情况下，所有的负载可能集中在一个分区上，这种严重不成比例的分区即成为系统热点。 避免热点的一个简单方法是随机分配，但是它的缺点是读取数据时，只能并行查询所有节点。 基于关键字区间分区 为每个分区分配一段连续的关键字或关键字范围。 比如对于一个保存网络传感器数据的应用系统，选择测量的时间戳（年-月-日-时-分-秒）作为关键字，此时区间查询非常有用，可以快速查询某个月份的所有数据。 缺点是某些访问模式会导致热点。比如上面的例子，每天对应一个分区，数据写入时，所有的写入都会集中在一个分区，而其他分区处于空闲状态。 解决方案可以在时间戳前面加上传感器名称为前缀。 基于关键字哈希值分区 一个好的哈希函数可以处理数据倾斜。一旦找到合适的哈希函数，就可以为每个分区分配一个哈希范围。 Cassandra和MongoDB使用MD5，Voldmort使用Fowler-Noll-Vo。许多语言也内置简单的哈希函数，比如Java的hashCode，但是要谨慎使用，因为同一键在不同进程中可能返回不同的哈希值。 哈希分区的缺点是丧失了区间查询特性。因为即使关键字相邻，哈希之后也是千差万别。 在MongoDB中，如果启用了哈希分片模式，区间查询会发送到所有的分片上，而Riak、Couchbase和Voldmort干脆就不支持区间查询。 Cassandra支持多个列组成复合主键，复合主键只有第一部分用于哈希分区，其他列可以区间查询。这种特性对于社交网站上，一个用户可能会发布多个消息更新，关键字为(user_id, update_timestamp)的组合，可以高效的查询。 二级索引 二级索引主要挑战是它们不能规整的映射到分区中。 基于文档分区的二级索引 这种方法，每个分区完全独立，各自维护自己的二级索引，且只负责自己分区内的文档而不关心其他分区中的数据。因此文档分区索引也被称为本地索引。 这种索引查询代价高昂，尽管如此，它还是广泛用于实践：MongoDB、Riak、Cassandra、Elasticsearch、Solr、Voldmort都支持。 基于词条的二级索引分区 对索引数据建立全局索引，为了避免成为瓶颈，全局索引也必须进行分区，但是可以采用与关键词不同的分区策略。 好处是查询更高效，坏处是写入较慢且复杂，因为单个文档更新时，可能会涉及多个二级索引的更新，二级索引的分区又可能在不同的节点上，会引入显著的写放大。因此，现有实现都不支持同步更新，更新往往都是异步的。例如Dynamo二级索引通常可以在1秒内完成更新，但是故障时，可能时间会更长。 分区再平衡 也就是大家常说的rebalance。这是一项比较昂贵的操作，通常在下面的情况下才做： 查询压力增加，需要更多的CPU来处理负载。 数据规模增加，需要更多的内存和磁盘存储数据。 节点可能出现故障，需要其他机器取接管失效的节点。 动态再平衡的策略 之所以不用取模的方式分区，是因为节点数量的轻微变化，将会引起分区映射关系的剧烈变动。 固定数量的分区 创建远超节点的分区数，然后为每个节点分配多个分区。例如，对于一个10个节点的集群，一开始就划分为1000个分区，每个节点承担100个分区。如果增加了一个新的节点，从现有的节点上匀走一些分区即可，如果删除一个节点，采用相反的均衡措施。 目前，Riak、Elasticsearch、Couchbase和Voldmort都支持这种方式。 分区数量一经确定，就不会改变，通常已经考虑到扩容需求。这种分区方式不能适应数据集总规模高度不确定或可变的情况。 动态分区 一些数据库，如HBase和RethinkDB采用的方式，当分区数据超过一个可配的阈值（HBase默认是10GB），它就拆分为两个分区，每个承担一半的数据量。相反，会进行分区合并。类似于BTree的分裂和合并操作。 优点是可以自动适配数据总量。缺点是分区的大小参差不齐，可能会导致长尾效应。 不仅适用关键字区间分区，还适用于哈希分区。MongoDB从2.4版本，同时支持两者。 按节点比例分区 前两种方式分区的数据量与数据集大小成正比。Cassandra和Ketama采用第三种方式，使分区数与节点数成正比，也就是每个节点有固定的分区数。这种方法使分区的大小保持稳定。 自动与手动再平衡操作 全自动，即由系统自动决定何时从一个节点迁移到另一个节点。 纯手动，即分区到节点的映射由管理员显式配置。 半自动，由系统自动生成一个分区建议方案，管理员确认。 无疑，全自动再平衡会更加方便，但是再平衡是一项比较昂贵的操作，操作不当的话会影响某些节点的请求，甚至导致级联式失效，因此让管理员介入可能是个更好地选择。 请求路由 这其实属于一类典型的服务发现问题。 概括来讲，有三种方式： 客户端请求任意节点。如果节点恰好有需要的分区，直接处理，否则，将请求转发到合适的节点，并将回复转发给客户端。 客户端请求一个路由层，由后者将请求转发到合适的节点上。 客户端感知分区和节点分配关系，直接请求某个节点。 Cassandra和Riak节点之间使用gossip协议同步集群状态的变化，类似于上面第1种方式。 Couchbase采用第2种方式，通过一个名为moxi的路由层，向集群节点学习最新的路由变化。 LinkedIn的Espresso使用Helix（底层是ZK）进行集群管理，实现了下图所示的请求路由层。HBase、Solr和Kafka也使用ZK来跟踪分区分配情况。MongoDB有类似的设计，但它依赖自己的配置服务器和mongos守护进程来充当路由层。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第5章 数据复制","slug":"第5章 数据复制","date":"2023-12-15T19:13:26.000Z","updated":"2025-09-16T02:08:42.992Z","comments":true,"path":"2023/12/15/第5章 数据复制/","link":"","permalink":"https://naosense.github.io/2023/12/15/%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/","excerpt":"","text":"本章主要介绍数据复制的技术，问题及挑战，解决方案。 复制或多副本技术的意义： 高可用：避免单点故障。 低时延：将数据放置在靠近用户的地方，从而实现更快的交互。 扩展性：采用多副本读取，提高系统的吞吐量。 主从复制（一主多从） 最主流的复制方案，许多关系数据库都内置支持主从复制，包括PostgreSQL（9.0版本之后）、MySQl、Oracle Data Guard和SQL Server的AlwaysOn Availability Groups，非关系数据库如MongoDB、RethinkDB和Espresso也支持主从复制。还有一些分布式队列如Kafka和RabbitMQ都支持。 同步复制和异步复制 同步复制的好处是一旦向用户确认，复制已经完成了，缺点是阻塞所有的写操作。异步复制就反过来了。 不过，同步和异步并不是那么泾渭分明，还有一种半同步模式，它的做法是将其中一个副本设置为同步的，其余的为异步，这样至少有两个节点（主节点和这个节点）拥有最新的副本。 增加新节点 快照文件+修改日志的方式 节点失效 如果从节点失效，恢复后可以比对日志，追赶主节点。 如果主节点失效，需要选出一个新的主节点，这个过程称为切换。 切换涉及的步骤： 探活：一般基于超时的心跳机制。 选举新的主节点。 配置系统使新主节点生效。 典型问题，比如脑裂，是说有两个节点都认为自己是主节点的情况。超时时间如何设置，长的话，恢复时间比较长，短的话，会造成不必要的切换。 具体的复制技术 基于语句 比如SQL语句记录，但是会存在如下问题： 非确定函数，比如NOW()、RAND()，可能会在不同的副本上产生不同的值。 使用了自增列，或者依赖现有数据，例如UPDATE … WHERE。 有副作用的语句，比如触发器、存储过程、用户定义的函数等，可能会在不同的副本上产生不同的副作用。 基于预写日志（WAL） 比较偏底层，一个WAL包含了哪些磁盘块的哪些字节发生变化，诸如此类的细节。 基于行的逻辑日志 逻辑日志与具体存储引擎解耦，更有利于向后兼容性。 行插入，日志包含所有列的新值。 行删除，日志里有行的唯一标识，通常为主键，如果表没有主键，就包含所有列的旧值。- 行更新，日志里包含行的唯一标识，和列的所有新值。 MySQL的binlog（配置为行复制）就属于这一类。 复制滞后问题 使用最终一致性系统时，最好事先就思考这样的问题：如果复制延迟增加到几分钟甚至几小时，那么应用层的行为会是什么样子？如果答案是“没问题”，那没得说，否则就得考虑提供一个比最终一致性强的保证。 读自己的写 用户在写入不久即查看数据，新数据还未到达从节点。对用户来讲，看起来似乎刚才提交的数据丢失了。对于这种情况，需要“写后读一致性”。 典型方案： 用户访问可能会修改的内容，从主节点读取，否则，从从节点读取。比如，社交网络的个人主页从主节点读，他人主页从从节点读。 跟踪最新的修改时间，如果是一分钟之内，从主节点读取。 如果副本分布在多数据中心，需要先把请求路由到主节点所在的数据中心。 如果允许用户多设备登录，还需要考虑： 更新时间戳需要做到全局共享。 多数据中心部署的应用，还要将多设备的请求都路由到主节点所在的数据中心。 单调读 用户看到了新内容后，又读到了过期的内容，好像时间回拨，此时需要单调一致性。这是一个比强一致性弱，又比最终一致性强的保证。 实现方式之一是，确保用户总是固定的从某个节点读取，比如对用户id进行哈希。 前缀一致读 必须先看到“问题”，再看到“回答”，而不能反过来，这种保证叫做前缀一致读。 一个解决方案，确保任何具有因果顺序关系的写入都交给一个分区来完成，但该方案真实实现效率会大打折扣。 基于触发器 可以配置自定义代码在某种事件下。 灵活性最高，性能最差。 多主节点复制 主从复制有主节点单点故障的缺陷，因此自然有人想到设置多个主节点，每个主节点都可以接受写入，被写入的主节点再将数据同步给其他主节点。 使用场景： 多数据中心 离线客户端操作，比如日历软件，一个设备就相当于一个数据中心。 协作编辑，每个正在编辑用户都是一个数据中心。 处理写冲突 多主的一大问题是写冲突。 一种方法是避免冲突，比如将修改的请求都路由到特定的数据中心。 第二种方法是使状态收敛于一致的状态。具体实现方法： 给每个写入都分配一个唯一的ID，比如时间戳、一个比较长的随机数，挑选最高的ID获胜，这种技术被称为最后写入者获胜（last write wins, LWW）。 以某种方式合并值。比如上文中，合并的标题类似于“B/C”。 利用预定义的格式保存所有值，提示用户解决冲突，类似于git，和cf。 拓扑结构 环形、星形、全部-至-全部。 环形、星形有中间节点单点故障问题，全部-至-全部由于每个主节点的延时不同，有类似于前缀读的问题。 对于多主节点复制，某些副本上可能会出现错误的写请求到达顺序，可以使用版本向量解决。 无主节点复制 放弃主节点，允许任何副本直接接受来自客户端的写请求。一些实现是客户端直接将请求发送给多副本，另一些实现，由一个协调者代表客户端写入。 代表产品：Dynamo、Riak、Cassandra、Voldemort，因为Dynamo后面几种都是受Dynamo启发设计的，所以称之为Dynamo风格数据库。 失效节点重新上线后的两种处理机制： 读修复。客户端读取多个副本时，检测到掉线节点版本较旧，就用新值更新。这种方法适合频繁读取的场景。 反熵。后台进程不断查找副本之间的差异，将缺少的数据从一个副本复制到另一个副本。 读写quorum 如果有n个副本，写入需要w个节点确认，读取需要r个节点确认，w + r &gt; n，读取的节点中一定包含最新值。 当一个集群的节点大部分失效，已经无法满足仲裁的需求，这个时候面临着： 直接向用户报错。 将请求导向一些临时节点，等恢复后再将数据回传回来，这些节点不属于原来的n个节点。 后一种措施就是宽松的（sloppy）quorum。 所有的Dynamo风格的数据库都支持sloppy quorum。Riak默认启用，Cassandra和Voldemort默认关闭。 检测并发写 一种实现最终收敛的方法是最后写入者获胜LWW。但LWW会导致数据丢失问题。 在分布式环境中并发的含义是两个操作没有依赖关系，比如happen-before。基于此，两个操作A和B只有三种关系，A在B之前发生，B在A之前发生，A和B并发。依赖关系可以覆盖，并发不能覆盖。 对于不能覆盖的情况，需要合并值。方法是一种基于版本向量的算法。 以两个客户端并行操作购物车为例，它的算法运行步骤如上图所示： 客户端A首先添加了milk，服务器返回(version: 1, value: [milk])。 客户端B随后添加了eggs，服务器返回(version: 2, value: [eggs])和(version: 1, value: [milk])，客户端将值进行合并，并选择所有值最高的版本号，(version: 2, value: [eggs, milk])。 接着客户端A又添加了flour，注意他是在version1的基础上添加的，因此他发给服务器的是(version: 1, value: [milk, flour])，服务器意识到version1的值得到了更新，所以覆盖老的值，最终返回(version: 3, value: [milk, flour])和(version: 2, value: [eggs])，客户端A收到值进行合并(version: 3, value: [milk, flour, eggs])。 接着客户端B也添加了新的物品ham，和步骤3类似，他是在version2的基础上添加的，也就是发给服务器的是(version: 2, value: [eggs, milk, ham])，服务器更新version2的值，最终返回(version: 4, value: [eggs, milk, ham])和(version: 3, value: [milk, flour])，客户端B合并值，得到(version: 4, value: [eggs, milk, ham, flour])。 这时客户端A又添加了bacon，也就是在version3的基础上加上bacon——(version: 3, value: [milk, flour, eggs, bacon]，服务器覆盖version3的值，返回(version: 5, value: [milk, flour, eggs, bacon])和(version: 4, value: [eggs, milk, ham]，客户端A最终得到(version: 5, value: [milk, flour, eggs, bacon, ham])。 上面示例的因果关系如下所示。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第4章 数据编码与演化","slug":"第4章 数据编码与演化","date":"2023-12-13T14:52:14.000Z","updated":"2025-09-16T02:08:42.989Z","comments":true,"path":"2023/12/13/第4章 数据编码与演化/","link":"","permalink":"https://naosense.github.io/2023/12/13/%E7%AC%AC4%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/","excerpt":"","text":"本章对比了JSON、Thrift、Protocol Buffer、Avro几种编码方式在模式演进时如何保持兼容性，更好的支持程序滚动升级。随后列举了几种进程间数据交互的方式，这些交互方式利用之前介绍的数据编码方案保持服务的兼容性。 向后兼容：较新的代码可以读取较旧的代码编写的数据，新代码兼容旧数据 向前兼容：旧代码兼容新数据 一般而言，向后兼容比较容易，因为编写新代码时，清楚旧数据的格式。 数据编码格式 程序数据两种表示形式： 内存中的数据结构。 为了写入文件或网络传输的字节序列。 前者转为后者称为编码（也称序列化），后者转为前者称为解码（也称反序列化）。 语言特定的格式 JSON和XML &#123; &quot;userName&quot;: &quot;Martin&quot;, &quot;favoriteNumber&quot;: 1337, &quot;interests&quot;: [&quot;daydreaming&quot;, &quot;hacking&quot;] &#125; 文本形式，易读性强，开发调试友好，数字编码有模糊之处，缺少模式，占用空间大。 Thrift和Protocol Buffer Thrift有两种编码格式，为BinaryProtocol和CompactProtocol。Protocol Buffer常被称为pb，只有一种编码方式，和Thrift的CompactProtocol非常类似。由于Thrift和Protocol Buffer二者非常类似，因此下面只介绍pb。 接口定义语言（IDL）描述模式 message Person &#123; required string user_name = 1; optional int64 favorite_number = 2; repeated string interests = 3; &#125; 模式随着时间不断变化，称为模式演化。 添加新字段时，向前兼容通过忽略不认识的字段实现，向后兼容不能添加必填（required）字段。删除字段时向前和向后兼容性和添加字段时相反。这意味着只能删除非必填字段，而且之前的字段标签不能再用，免得老代码写入的数据被够被新代码忽略。 数据类型改变在某些方式是支持的，比如pb的单值到多值的互转，但是面临着潜在的数据丢失问题。 pb相比json占用空间更小的原因 使用字段标签（tag）代替了字段名。 紧凑的二进制编码，避免了文本编码的许多元字符，比如逗号，引号。 使用可变长度的int编码整型字段（varint，字节最高位标识是否还有下一个字节），进一步降低了空间占用。 Avro Avro是Hadroop孵化出得一个项目，广泛地用在Hadroop生态中。 当应用程序想要对某些数据进行编码，它使用所知道的模式模式的任何版本来编码数据，这被称为写模式。当应用程序想要解码某些数据，它期望数据符合某个模式，即读模式。 Avro的关键思想是，写模式和读模式不必是完全一模一样，它们只需保持兼容。例如，写模式和读模式字段顺序不同，这也没有问题，因为模式解析通过字段名匹配（这里不太懂，编码的时候没有将字段名编码进去，那解码是如何根据字段名匹配呢？）。如果一个字段写模式有读模式没有，则忽略，反之，则用默认值填充。 相比pb和thrift，avro对动态模式支持更好。 总结下，二进制编码的好处： 比json这种文本格式更紧凑，因为省略了字段名称。 模式是一种强制的自描述的文档[1]。 更好的向前兼容和向后兼容。 静态语言可以通过代码生成获得编译时类型检查。 进程间数据流动 基于数据库的数据流 这种方式或许是大家见得最多，使用得最多的一种方式了。也就是应用程序将数据库当作中转站，将数据写入，并在之后读取写入的数据，通常会涉及多种不同功能的服务以及众多的接口。 基于服务的数据流：REST和RPC 服务器公开的API称为服务。 将大型应用程序按照功能分解为较小的服务，当一个服务需要另一个服务的功能或数据时，就会向另一个服务发出请求。这种构建应用程序的方式被称为面向服务的体系架构（service-oriented architecture，SOA），或者微服务体系结构（microservices architecture）。 微服务体系的一个关键设计目标是，通过使服务可独立部署和演化，让应用程序更易于修改和维护。 当HTTP为用作底层通信协议时，它被称为Web服务。有两种流行的Web服务方法：REST和SOAP。 REST不是一种协议，而是一个基于HTTP原则的设计理念。它强调简单的数据格式，使用URL标识资源，并使用HTTP功能进行缓存控制、身份验证和内容类型协商。根据REST原则设计的API称为RESTful。 SOAP是一种基于XML的协议，用于发出网络API请求。虽然它最常用于HTTP，但其目的是独立于HTTP，并避免使用大多数HTTP功能。相反，它带有庞大而复杂的多种相关标准（Web服务框架，Web Service Framework，称为WS-*）和新增的各种功能。SOAP Web服务的API被称作WSDL（Web Service Description Language）来描述。 SOAP消息复杂，严重依赖工具支持、代码生成和IDE，不同厂商实现之间标准不一。RESTful倾向于更简单的方法，涉及较少的自动化工具和代码生成，受到小公司的青睐。 到底什么是REST？ REST全称Resource Representational State Transfer，资源表现层状态转移。这名字越听越让人糊涂，它的真正意思是用url标识资源位置，用HTTP动词（GET/POST/DELETE/PUT）表示操作，用HTTP状态码标识访问状态。 它的一些最佳实践： 使用名词，而不是动词，且推荐名词复数。BAD /getProducts /listOrders /retrieveClientByOrder?orderId=1 GOOD GET /products : will return the list of all products POST /products : will add a product to the collection GET /products/4 : will retrieve product #4PATCH /PUT /products/4 : will update product #4 保证HEAD和GET是安全的，不改变资源状态。 资源地址采用嵌套结构，例如GET /friends/10375923/profile 这样做地好处是啥呢？ 看url就知道请求的什么资源。 看method就知道要干什么。 看状态码就知道结构如何。 基于消息传递的数据流 与RPC相比，使用消息代理有几个优点： 接受方不可用或过载，消息代理可以充当缓冲区，也就是常说的削锋作用。 自动重发，防止消息丢失。 避免了发送方需要知道接受方的ip和端口。 支持一条消息发送给多个接受方。 逻辑上将发送方和接受方分离，也就是解耦作用。 消息传递是单向的，RPC通常是双向的，消息是fire-and-forget。 两种实现： 消息代理，也就是MQ。 分布式Actor模型。 分布式Actor框架的实质是将消息代理和Actor模型集成到单个框架中。 这一点的重要性相信调过别人接口的人都知道，当你使用一个json接口，很难有人能说清这个json会包含哪些字段，更比提每个字段的意义了。 ↩︎","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第3章 数据存储与检索","slug":"第3章 数据存储与检索","date":"2023-12-06T19:07:37.000Z","updated":"2025-09-16T02:08:42.982Z","comments":true,"path":"2023/12/06/第3章 数据存储与检索/","link":"","permalink":"https://naosense.github.io/2023/12/06/%E7%AC%AC3%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/","excerpt":"","text":"本章主要讲了数据库存储涉及到的核心数据结构，以及数据库两种主要的应用场景：OLTP和OLAP。 核心数据结构 在最基本的层面，数据库只需做两件事：向它插入数据时，它保存数据；之后查询时，它返回数据 数据存储两种形式：追加和原地修改。索引是为了提高查询速度的额外数据结构。 哈希索引 典型产品：Bitcask。 内存侧：hashmap索引，key为查询的键，value为文件中数据偏移量。 磁盘侧：真正的数据文件存储在磁盘上。 为什么进行日志分段？ 书中说为了避免用尽磁盘空间。我当时看了很纳闷，不分段，也就是一直往一个文件写，边写边检测文件大小是否小于磁盘剩余空间不就完了？为什么非得分段？请教了下chatgbt，给出了三个理由： 磁盘碎片化：长时间持续写入一个文件会导致磁盘碎片化，即文件被分散存储在物理磁盘的不同位置。 文件扩展：文件会持续增长，没有合适的管理，会耗尽磁盘空间（这不废话吗）。 日志管理：分成一定大小的段文件可以更好的管理日志。当文件达到一定大小时，关闭它并将后续写入到新的段文件中，可以使得日志的查找、备份、传输等操作更加方便和高效。 我又纳闷了，为什么长时间写入一个文件会碎片化，分段就不会？还有文件扩展，你边写边检测不就行了？ chatgbt给出的解答： 关于碎片化：持续写入一个文件时，磁盘上连续的可用空间可能不足以一次性写入整个文件，这倒是，文件越大，能够连续写入的概率越小。 边写边检测的方法是可行的，但是可靠性不如分段。比如，如果写入速度过快，检测文件大小频率太低，仍然会导致文件大小超过磁盘的情况。此外，写入文件时可能会出现错误或异常，导致无法正确检测文件大小的情况，导致数据丢失。分段的思想有点类似造船的时候设置的多个水密仓，单个仓损坏，船舶仍然可控，控制了数据损毁的影响范围。 追加日志的好处： 顺序写比随机写高效得多。 并发和崩溃恢复简单得多。 合并旧段可以避免碎片化。 哈希索引缺点： 必须全部放入内存，如果有大量的键，内存存不下就不行了。 区间查询效率不高。 SSTables和LSM-Tree 将段文件中的key-value对按键排序就是排序字符串表（SSTables）。相比哈希索引的日志段，具有以下优点： 合并更加简单有效。因为段文件已经按照key排序，合并多个段时，只需依次比较段的第一个键，然后将最小的放置在输入文件中，重复这一过程即可完成合并。 在文件中查找键时，不再需要在内存中保存所有键的索引，只需维护一个保存有部分键的稀疏索引。比如查找键handiwork，但是知道handbag和handsome的偏移量，根据键的顺序特性，handiwork的偏移量肯定位于handbag和handsome之间。 读取的时候因为往往要扫描多个key-value，可以将这些key-value对保存在一个块中，稀疏索引指向块的开头，更好的利用磁盘读取的局部性。对块还可以压缩合并，节省磁盘空间，还能减少磁盘IO带宽的占用。 稀疏索引如何查找key？ 稀疏索引是按照键排序好的，查找指定key时，可以采用二分法查找小于等于key的值，拿上面的示例来说，查找handiwork时，索引中没有handiwork，因此会查出来handbag，以handbag为起点查找，段文件中如果查不到那就是没有这个key，在leetcode上很常见的类型，算法复杂度log(n)。 SSTable构建和维护[1] 写入时，添加到内存中的平衡树数据结构（也称内存表），比如红黑树。 当内存表大于某个阈值（通常为几兆字节）将其作为SSTables写入磁盘。 读时先在内存表中查找，然后查找最新的磁盘段文件，然后是次新的段文件，依次类推。 后台进程周期性的合并和压缩段文件。 为了避免数据崩溃时数据丢失，可以在磁盘上保留单独的日志，每个写入都会立即追加到这个日志，该日志不需要排序，它的唯一目的就是恢复内存表。 内存索引和内存表 在SSTables的语境下，前者是为了快速定位SSTables在磁盘上的数据块，后者是新写入但未持久化到磁盘暂存在内存中的数据部分。 LSM-Tree（Log-Structured Merge-Tree）日志结构的合并树，基于合并和压缩排序文件原理的存储引擎通常都被称为LSM存储引擎。 性能优化： 当键查不到时，需要扫描内存表和多个段文件，效率很低，可以引入布隆过滤器来改善这一状况。 大小分级和分层压缩。LevelDB和RocksDB使用分层压缩，HBase使用大小分级，Cassandra同时支持这两种方式。 B-tree B-tree以固定大小的页为单位，传统大小为4KB，页是内部读写的最小单位，相比之下SSTable数据块是数据的逻辑分割单位。 B-tree一个页的子叶数量称为分支因子。 在插入时，如果一个页已经满了，就会分裂为两个半满的页。 B树和B+树 节点结构：B树节点存储键值对，B+树只有叶子节存储值，中间节点只存键，这样分支因子更高，树的高度更低，从而减少了磁盘访问次数。 叶子节点之间的连接：B+树增加了叶子节点之间的连接，提高了范围查找的效率。 预写日志（write-ahead log，WAL）是为了让数据块能从奔溃中恢复设置的额外的数据结构。 B-tree的优化措施： 不再用覆盖页和WAL了进行崩溃恢复，而是写时复制（也就是和java的CopyOnWrite数据结构类似的思想）。 使用键的缩略信息，而不是完整的键。 将相邻叶子页按顺序存在磁盘上，提高数据的局部性。 叶子之间的指针（上文B+树那里提过了）。 分形树等变体。 根据经验，LSM-Tree写时快，B-tree读时快。 总结，LSM-tree特点： 写入吞吐高。 碎片少，数据紧凑，磁盘占用少。 压缩会影响写入。 B-tree的特点： 事务支持好（在实现中，通过范围锁定键进行事务隔离）。 每个键对应唯一的索引位置。 其他索引结构 聚集索引 在索引结构中，可以存数据（行）的引用，也可以存数据本身，如果后一种，这种索引就称为聚集索引（也叫聚簇索引）。 在MySQL中主键索引是聚集索引，二级索引引用主键，在查找时多了一次从普通列到主键的检索过程。 多列索引 也叫多维索引，是为了提高多列数据条件查找的速度。在使用这种索引时，要考虑左端匹配。 全文索引和模糊搜索 之前介绍的索引，都是精确匹配的索引，而全文索引必须得支持对同义词，或者疏忽导致拼写错误进行检索，比如Lucene支持在某个编辑距离内搜索文本，采用的是字符序列生成一个有限状态机，可以高效的搜索单词。 内存数据库 我们常说的缓存就属于这一类，比如Redis、Memcached，数据完全保存在内存中，有些会提供弱的持久化。 作者提到： 与直觉相反，内存数据库的性能优势并不是因为它们不需要从磁盘读取。如果有足够的内存，即使是基于磁盘的存储引/擎，也可能永远不需要从磁盘读取，因为操作系统将最近使用的磁盘块缓存在内存中。相反，内存数据库可以更快，是因为它们避免使用写磁盘的格式对内存数据结构编码的开销。 “它们避免使用写磁盘的格式对内存数据结构编码的开销”就是那些对数据进行的序列化、压缩和持久化等操作，比如json想存在磁盘上，要不存成文本，要不经过protobuffer序列化，也就是所谓的“编码”，才能存在磁盘上。 OLTP和OLAP OLTP（online transaction processing）根据用户的输入添加或更新记录，由于这些应用是交互式的，所以称为在线事务处理。 事务不一定具体ACID属性。事务处理只是意味着允许客户端进行低延迟读取和写入，是相对批处理而说的（难道交互式的非自动化批处理的就可称之为事务？）。 OLAP（online analytic processing），数据库越来越多的用于数据分析，这些分析通常由业务分析师编写，为了给管理层提供更好决策的报告，为了和OLTP区分，称为在线分析处理。 数据仓库 对于大型公司，为了避免对在线服务的影响，都有自己专门的数据仓库，OLTP数据库经过ETL（Extract-Transform-Load，提取-转换-加载）生成OLAP数据库（数据仓库）（我之前就在一家公司使用PL/SQL干过这个活）。 有两种主流的分析数据模型：星形和雪花型分析模式。 所谓星形模型，是说中间有一个非常宽（通常超过100列）的事实表，围绕着它衍生出来许多维度表（只用到事实表中的几列），这些连接就像星星的光茫，因此得名。 而雪花模式是星形的更丰富版本，维度进一步细分为子空间（雪花是一种分形结构，它有六个分支，可以无限递归）。 列式存储 创建维度表时，大部分时候只用到了事实表的几列，每次将整行读出来是对资源的巨大浪费，很自然地就有人就想到了按列存储。 比如Parquet是基于Google Dremel的一种支持文档数据库的列存储格式 面向列的存储依赖一系列列文件，里面顺序保存着列数据。一整行通过拼接列文件同一个索引位置的数据组成，比如取23行，将列文件23位置的数据拼接起来。 列压缩 列式存储有大量重复值，非常适合压缩。 使用位图存储。 所谓位图就是列的每个不同值（假设为M）使用一个序列，通常是一个数组，序列的的长度等于列长（假设为N），根据列的值是否等于当前序列的值进行标记，比如1代表等于，0代表不等于，最终形成一个M x N的二维数据结构。 位图的优点： 压缩重复值，节省空间。 加速过滤和条件查询：可以快速指示数据中符合条件的行。 支持高效的AND/OR操作：也就是便于计算机矢量化处理。 列排序 排序后最直接的好处就是便于查询。 列排序后相同的值聚集在一起，更利于压缩，比如转为位图后，所有值都是0/1，再使用游程编码，即便几十亿行的表也可以压缩到几千字节。 上面位图的游程编码。 product_sk = 29: 9, 1 (9 zeros, 1 one, rest zeros) product_sk = 30: 10, 2 (10 zeros, 2 one, rest zeros) product_sk = 31: 5, 4, 3, 3 (5 zeros, 4 ones, 3 zeros, 3 ones, rest zeros) product_sk = 68: 15, 1 (15 zeros, 1 one, rest zeros) product_sk = 69: 0, 4, 12, 2 (0 zeros, 4 one, 12 zeros, 2 ones) product_sk = 74: 4, 1 (4 zeros, 1 one, rest zeros) 通常为了适配多种查询，会存储数据的多个排序副本，这一思想最早由商业数据仓库Vertica所采用。 数据立方体和物化视图 物化视图其实就是特定查询的一个缓存，这样每次查询不用从零开始，速度更快。 数据立方体是物化视图的一种实现，它是不同维度的聚合网格。比如下面事实表只包含两个维度：日期（date_key)和产品（product_key），绘制一个二维表。每个单元格是date-product组合的事实表属性（图中为net_price），沿着行或列聚合，得到一个减少一个维度的总和。 对于多维的事实表类似，比如有五个维度：日期、产品、商店、促销和客户。这意味着会生成一个五个维度的立方体，五个维度的值自由组合，比如单个维度如日期，两个维度（日期，产品），三个维度（日期，产品，客户）……。 LevelDB和RocksDB的算法大致就是这样的，主要用于嵌入到其他应用程序的key-value存储引擎库。类似的存储引擎库还被用于Cassandra和HBase，这两个引擎都受到Google的Bigtable论文的启发。 ↩︎","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第2章 数据模型和查询语言","slug":"第2章 数据模型和查询语言","date":"2023-11-30T18:42:23.000Z","updated":"2025-09-16T02:08:42.980Z","comments":true,"path":"2023/11/30/第2章 数据模型和查询语言/","link":"","permalink":"https://naosense.github.io/2023/11/30/%E7%AC%AC2%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/","excerpt":"","text":"本章主要讲了数据模型，以及围绕模型所构建的查询语言。 数据模型 关系模型 由Edgar Codd与1977年提出，这种模型将数据组织成关系（relations），在SQL中称为表（table），其中每个关系都是元组（tuples）的无序集合，也就是SQL中的行。 MySQL、Oracle、PostgreSQL等一众大家耳熟能详的数据库都属于此类。适用于： 结构一致的数据。 事务性要求比较高的情况，比如金融、银行等领域。 文档模型 所谓文档模型就是可以直接存储json、xml等非结构化数据，数据的关系和模式不再是首要关注的对象。相关的产品有Redis、MongoDB、HBase等等。 NoSQL[1]：不仅仅是SQL 最初作为一个标签出现在2009年的开源、分布式以及非关系数据库的见面会上。 NoSQL的优势： 扩展性更好，支持超大数据集或超高吞吐量。 大部分是免费开源，成本优势。 查询的局部性更好，也就是一次将所有数据都查出来了，不用做联结和子查询。 更具动态和表达力的数据模型，和应用程序数据结构比较接近，减少了阻抗失谐[2]。 树模型 一个示例，下面是比尔盖茨个人简历的json描述： &#123; &quot;user id&quot;: 251, &quot;first_name&quot;: &quot;Bill&quot;, &quot;last_ name&quot;: &quot;Gates&quot;, &quot;summary&quot;: &quot;Co-chair of the Bill &amp; Melinda Gates... Active blogger.&quot;, &quot;region id&quot;: &quot;us:91&quot;, &quot;industry_id&quot;: 131, &quot;photo ur1&quot;: &quot;/p/7/000/253/05b/308dd6e.jpg&quot;, &quot;positions&quot;: [ &#123;&quot;job_title&quot;: &quot;Co-chair&quot;, &quot;organization&quot;: &quot;Bill &amp; Melinda Gates Foundation&quot;&#125;, &#123;&quot;job_title&quot;: &quot;Co-founder, Chairman&quot;, &quot;organization&quot;: &quot;Microsoft&quot;&#125; ], &quot;education&quot;: [ &#123; &quot;school_name&quot;: &quot;Harvard University&quot;, &quot;start&quot;: 1973, &quot;end&quot;: 1975 &#125;, &#123; &quot;school_name&quot;: &quot;Lakeside School, Seattle&quot;, &quot;start&quot;: null, &quot;end&quot;: null &#125; ], &quot;contact info&quot;: &#123; &quot;blog&quot;: &quot;http://thegatesnotes.com&quot;, &quot;twitter&quot;: &quot;http://twitter.com/BillGates&quot; &#125; &#125; 画成图是这个样子。 可以看到是一层一层的，像一棵树，所以有时候也称为层次模型或树模型。 其实json并非没有模式，只是和关系模型相比，一个是写式模式（显式），一个读时模式（隐式），json格式更易修改，不用像关系数据库得修改表结构。 json拥有更好的局部性，不用联接（join）多张表或者多次查询，但仅限于访问大部分数据情况，无法像关系数据库返回特定字段。 json擅长处理1 vs N，不擅长处理N vs 1和N vs N。想支持只能在应用层使用代码做，另外是不是还增加了数据冗余度，因为不能像关系数据库那样通过外键引用同一份数据。 网络模型 不像层次模型，每个记录只有一个父节点，网络模型可以有多个父节点，比如“大西雅图地区”可能是一个记录，居住在该地区的用户都指向它，因此可以方便的支持多对一和多对多。 比如这个多对多的例子。 融合数据库 关系数据库和文档数据库呈现出融合趋势，主流的关系数据库PostgreSQL、MySQL、DB2已经支持json、xml等常用文档类型。文档数据库RethinkDB查询接口支持和关系型类似的联结，MongoDB驱动程序可以自动解析数据库的引用关系。 图状数据模型 关系模型可以勉为其难的处理多对多，但是还是图模型更自然。 图有两种对象构成：顶点和边，典型的例子： 社交网络：顶点是人，边指示哪些人彼此认识。 Web图：顶点是网页，边表示网页之间的超链接。 公路或铁路网：顶点是交叉口，边表示它们之间的公路线或铁路线。 一个示例，来自社交网络的族谱数据库，来自爱达荷州的Lucy和来自法国波恩的Alain，他们结婚了，目前住在伦敦。 图模型最大的特点就是灵活，它的灵活性来自于： 任何顶点之间都可以连接。 给定某个顶点，可以高效的得到它的入边和出边，从而遍历图。 可以在同一张图的同一顶点之间标记不同的标签来表达不同的关系，同时仍然保持图的整洁。 图数据模型可以使用关系数据库和三元存储实现。 关系数据表 如果是关系数据表实现，相应地可以用SQL查询，但是写起来比专门的图查询语言麻烦多了。 CREATE TABLE vertices ( vertex_id interger PRIMARY KEY, properties json ); CREATE TABLE edges ( edge_id integer PRIMARY KEY, tail_vertex integer REFERENCE vertices (vertex_id), head_vertex integer REFERENCE vertices (vertex_id), label text, properties json ); CREATE INDEX edges_tails ON edges (tail_vertex); CREATE INDEX edges_heads ON edges (head_vertex); 三元组 几乎等同于属性图模型，所有信息都表示为（主体，谓语，客体）。例如，（吉姆，喜欢，香蕉）。三元组的主体相当于图的顶点，客体可能是： 属性值，比如（lucy，age，33）。 顶点，比如（lucy，marriedTo，alain）。 以Turtle[3]三元组的形式表示图： @prefix : &lt;urn:example:&gt;. _:lucy a :Person; :name &quot;Lucy&quot;; :bornIn _:idaho. _:idaho a :Location; :name &quot;Idaho&quot;; :type &quot;state&quot;; :within _:usa. _:usa a :Location; :name &quot;United States&quot;; :type &quot;country&quot;; :within _:namerica. :namerica a :Location; :name &quot;North America&quot;; :type &quot;continent&quot;. RDF（Resource Description Framework）是一种基于xml的资源描述框架，目的是为不同的网站定义一种通用格式，这样不同的网站可以自动合并成一个数据网络，一种互联网级别包含一切数据的数据库。 我个人觉得Turtle是给人看的三元组，RDF是给机器看的三元组。 语义网 语义网源自大家想创建一种囊括互联网所有数据的大数据库的设想，为了创建这种数据库，需要所有人都遵守一种通用格式，就像人为了能够理解彼此，必须得说同样地语言，为了描述这种格式诞生了RDF。 在可预见的未来，大多数系统会同时使用关系数据库和NoSQL数据库，称为混合持久化。 数据查询语言 命令式 需要告诉程序一步一步怎么做，大多数的编程语言都属于此类。 声明式 告诉程序做什么即可，具体怎么做程序自主决定，如SQL、web中的css和xsl。 SQL 比如使用SQL查询每个月看到了多少鲨鱼。 SELECT date_trunc('month', observation_timestamp) AS observation_month, sum(num_animals) as total_animals FROM observations WHERE family = 'Shark' GROUP BY observation_month; 聚合管道 MongoDB 2.2增加了聚合管道的声明式查询语言，相当于SQL的子集，基于json语法。它的等效表达如下： db.observations.aggregate( &#123; $match: &#123; family: &quot;Shark&quot; &#125; &#125;, &#123; $group: &#123; _id: &#123; year: &#123; $year: &quot;observationTimestamp&quot; &#125;, month: &#123; $month: &quot;observationTimestamp&quot; &#125; &#125;, totalAnimal: &#123; $sum: &quot;$numAnimals&quot; &#125; &#125; ); 感觉某种程度上，可以看成是文档数据库的SQL语言。 Cypher Cypher查询语言，一种属性图的声明式查询语言，最早为Neo4j图形数据库而创建。比如，使用Cypher查询从美国移民到欧洲的人员名单： MATCH (person) -[BORN_IN]-&gt; () -[:WITHIN*O..]-&gt; (us:Location &#123;name:'United States'&#125;). (person) -[LIVES_IN]-&gt; () -[:WITHIN*O..]-&gt; (eu:Location &#123;name:'Europe'&#125;). SPARQL SPARQL（发音：sparkle），是一种基于RDF的查询语言。比如，执行同样的查询，比Cypher 更加简洁[4]。 SELECT ?personName WHERE &#123; ?person :name ?personName. ?person :bornIn / :within* / :name &quot;United States&quot;. ?person :liveIn / :within* / :name &quot;Europe&quot;. &#125; 又仔细看了下书，NoSQL是相对SQL（关系模型）而说的，应该不仅包括文档模型，还包含之后的图模型。 ↩︎ 编程语言中是一些对象，而关系数据库基本单元是行和列，模型之间的这种脱离称为阻抗失谐。 ↩︎ Turtle是Notation3的子集。 ↩︎ 简不简洁见仁见智，但是看起来更像SQL倒是真的。 ↩︎","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"第1章 可靠、可扩展与可维护的应用系统","slug":"第1章 可靠、可扩展与可维护的应用系统","date":"2023-11-28T17:21:45.000Z","updated":"2025-09-16T02:08:42.979Z","comments":true,"path":"2023/11/28/第1章 可靠、可扩展与可维护的应用系统/","link":"","permalink":"https://naosense.github.io/2023/11/28/%E7%AC%AC1%E7%AB%A0%20%E5%8F%AF%E9%9D%A0%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%8E%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"当前的许多系统都是数据密集型应用（data-intensive），已经不再受限于CPU，关键在于数据量、数据的复杂度以及数据的快速多变为特性。比如大型电商如淘宝、京东，新闻推送如腾讯、凤凰网，社交平台如twitter、facebook等等，都属于这一类型。 基本构成组件： 数据库 高速缓存 索引：根据关键字快速检索 流式处理：比如一些flink任务，或者自定义的worker承接来自MQ的消息，进行相关的数据处理 批处理：定时任务 数据系统的三个方面： 可靠性 可扩展性 可维护性 可靠性 可靠性大家天天挂到嘴边，用大白话说其实就是有点小风小浪，甚至中风中浪，系统是否稳定，书面一点，就是系统在遇到局部故障时，仍能维持服务的能力。 比如一些典型的场景： 参数输入错误 流量突然增加了一倍 分布式部署的某个机房突然挂掉了 黑客入侵 遇到这些情况，系统能不能很好的应对。 故障（fault）和失效（failure） 前者强调组件偏离规格，强调单体和局部，后者强调整体和全局，也就是说整个服务已经没法提供服务了。但事实上，大家在日常工作中区分不了那么精细，而且说法也不尽相同，书中提出这一概念，是为了说明100%可靠的系统是不存在的，系统的容错是有限度的，并不是所有的故障系统都能够容忍。 故障应对措施： 硬件故障：冗余备份，比如RAID、UPS电源。 软件错误：难以预料，更加隐蔽，只能充分的测试，报警和可观测系统。 可靠性很重要，但并不是绝对的。比如银行和普通的web服务对可靠性要求肯定不一样，甚至同一个系统的不同模块对可靠性要求也不尽相同，通常在线的可靠性要求要高于离线系统。 可扩展性 系统规模的增长，比如流量、数据量，相应的系统资源如何增加。 在日常工作中很常见，比如阿里、京东这样的电商公司在大促的时候面对流量激增通常的方案就是扩容，那到底扩多少呢？在降本增效的背景下，老板经常会问“能不能优化下，不用增加机器”，因为机器都是实实在在的钱呢。这个说起来容易，其实挺难的，因为系统资源增长并不一定是线性的，但实际工作中都是按照线性来评估，或者使用压测来决定。 负载通常使用吞吐量进行描述，在线系统常用QPS来衡量，离线系统可能是单位时间处理的数据量来衡量。 性能的话，使用性能指标的分位值来衡量，比如avg、p50、p99。书中说“avg掩盖了一些信息，无法告诉有多少用户实际经历了多少延迟”，实际上大部分情况下，avg和p50是非常接近的，avg的缺点是容易受异常值影响。比如100个请求，99个请求的延时都是50ms左右，剩下一个请求5000ms，那么平均下来，延时接近100ms。 通常衡量性能时，会同时使用avg和p99，一个说明平均情况，一个说明长尾情况。 长尾效应 一个服务涉及多个不同的后端调用，则最慢的调用会拖累整个服务相应时间。 比如分布式部署的服务，可能会涉及多个机器的相应，这些机器有快又慢。又比如推荐系统中不同用户的画像有多有少，多的自然相应就慢一些。这些都有可能造成长尾效应。 关于分位值的两种解释，以p99为例： 将延时按照从小到大排列，第99%*n（n为请求数）的延时大小。 100个请求中，有99个请求的延迟是小于p99的，也就是一个请求小于p99的概率是99%。 延迟（latency）和响应时间（response time） 延迟是系统服务的时间。响应时间是客户端看到的时间，除了服务时间，还有网络来回的延迟。平常上下游服务指标对不上，可能就是没有区分延迟和响应时间，但通常内网里延迟也就毫秒级。 扩容方式： 垂直扩容：使用更好的机器 水平扩容：使用更多的机器 一般小公司或初创公司倾向于使用垂直扩容，而中大型公司倾向于使用水平扩容，或者二者兼而有之，具体还是得看成本、业务增长速度等因素。 可维护性 一说维护，首先想到的可能就是运维，其实这里的维护性是指系统容不容易改，新功能容不容易上，出了问题容不容易排查和解决，不光涉及运维。 涉及到三个原则： 可运维性 简单性 可演化性 可运维性 运营团队能够方便的保持系统平稳运行。 简单性 简而言之，就是控制复杂度。 对于自己的小项目，你可以把代码写的简洁而优美，对于多人参与的公司级项目，复杂度常常会超出控制，相信大家都见识过这种“屎山”代码。 作者列举了几种表现形式，说的太好了，我必须全文摘录下来： 状态空间的膨胀：这种情况很好理解，随着代码越来越多，所要处理的情况越来越多，状态空间肯定越来越多。 模块紧耦合：比如随着人员的流动，最初的设计原则已经无人知晓，导致原本不该依赖的模块依赖了。 令人纠结的相互依赖关系 不一致的命名和术语：比如有的使用英文命名，有的使用拼音，即便有时候都使用英文大家翻译的也是五花八门。 为了性能而采取的特殊处理：这一条和下一条差不多，都是一些特例处理，如果你不是当事人，不了解背景，就很难了解代码的逻辑。 为了解决特定问题而引入的特殊框架：比如为什么有了grpc还要引入brpc，为什么有了protobuffer还要引入thrift，类似的框架同时出现在系统中 作者给出了解决复杂度的方法是抽象。但真正想做好并不那么容易，会受人员经验、需求紧迫度、公司政策等因素影响。 一个真实的例子 公司一名同学修改别人的代码导致线上出现错误，并因此复盘，后来，再遇到这种情况，这名同学都是复制一份代码再改，这样至少不会影响线上现有功能，但是代码的冗余度增加了。 可演化性 是不是容易改变，比如容易修改原来的老功能，容易添加新功能。 这一点和简单性密切相关，因为简单的系统更容易修改。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ddia","slug":"ddia","permalink":"https://naosense.github.io/tags/ddia/"},{"name":"系统设计","slug":"系统设计","permalink":"https://naosense.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://naosense.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"Git最小命令集","slug":"Git最小命令集","date":"2023-11-24T18:51:18.000Z","updated":"2025-09-16T02:08:42.958Z","comments":true,"path":"2023/11/24/Git最小命令集/","link":"","permalink":"https://naosense.github.io/2023/11/24/Git%E6%9C%80%E5%B0%8F%E5%91%BD%E4%BB%A4%E9%9B%86/","excerpt":"","text":"背景 git命令有点多，选项就更多了，别说初学者无所适从，作为老鸟，如果长期使用ui界面操作，或者一段时间不用命令行也是晕头转向。我呢，就是常年使用idea的ui界面操作git，突然切换vscode，界面和操作方式和之前idea不太一样，用起来很不适应，只好重新把命令行学起来。命令行有一个好处，无论是vscode，还是idea，抑或是其他的什么ide，都可以“一招吃遍”。 前提 大部分企业通常仓库会有一个主分支master，大家基于主分支拉取自己的开发分支，修改代码，然后提交，最后合并到master分支。 常规流程 常规流程基本上就是：创建分支——&gt;更新代码——&gt;提交代码——&gt;删除分支。 创建分支 # 查看本地分支 git branch # 创建本地分支并切换 git branch branch_name origin/master git checkout branch_name # 或者一步到位 git checkout -b branch_name origin/master 更新代码 除非个人仓库可以使用git pull origin master，其他多人合作的代码库，我建议一律采用先fetch后rebase的方式更新代码。 # 拉取最新代码 git fetch origin master # 查看本地当前代码与远程主库区别，如果只想看commit，去掉-p git log -p HEAD..origin/master # 将当前代码变基到远程主库上 git rebase origin/master 如果代码rebase有冲突，先解决冲突，然后执行继续变基。 git rebase --continue 提交代码 git status git add some_code_files git commit -m &quot;commit message&quot; git push 删除分支 # 删除本地分支 git branch -d branch_name # 忽略未合并的commit强制删除本地分支 git branch -D branch_name # 删除远端分支 git push origin :branch_name 其他命令 回退版本 # 上个版本 git reset HEAD^ # 上两个版本 git reset HEAD^^ # 或 git reset HEAD~1 git reset HEAD~2 回退到某个commit # commit id前7位 git reset 69fde2c 美化commit记录 如果写着写着，突然发现有个代码在上一commit中忘了添加了，想追加进去，那可以使用 git add forgot_file # 如果是最后一条可以用 git commit -m &quot;commit msg&quot; --amend # 如果这些commit已经推送到远端了，要使用force推送覆盖 git push --force-with-lease 如果写代码写的比较忘我，提交的也不亦乐乎，可能会形成许多零碎的commit，看着很不美观，这时候你可以 # 修改最后n个提交 git rebase -i HEAD~n # 如果这些commit已经推送到远端了，要使用force推送覆盖 git push --force-with-lease 查看文件或文件夹的变动记录 git log -p -- src/main.cpp git log -p -- src/some_path","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://naosense.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://naosense.github.io/tags/git/"}]},{"title":"一套全平台多端发布hexo博文的方法","slug":"一套全平台多端发布hexo博文的方法","date":"2023-11-21T18:51:10.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2023/11/21/一套全平台多端发布hexo博文的方法/","link":"","permalink":"https://naosense.github.io/2023/11/21/%E4%B8%80%E5%A5%97%E5%85%A8%E5%B9%B3%E5%8F%B0%E5%A4%9A%E7%AB%AF%E5%8F%91%E5%B8%83hexo%E5%8D%9A%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"hexo博客建了好久了，一直以来都有几个痛点： 只能电脑发布。在手机日期流行的今天还挺要命的，有时候上一天班真心不想开电脑，电脑不能随时随地使用，比如地铁上。 图片的插入不方便。需要找图床，或者保存在同名文件夹中，然后手动再插入markdown文档。 换电脑需要重复配置hexo环境，每次都要安装一次nodejs以及一堆依赖，特别是后端程序员，使用nodejs不多，时间一长都忘了咋配置，每次都得百度一番。 最近在twitter上受@lencx_启发，发现一套可以全平台多端发布hexo博文的方法，方案如下： 使用github discussion作为数据源，天然支持分类和tag，还有天生的版本管理功能，如果注重隐私，还可以选择私密仓库。 当发布或修改discussion时，使用github api将discussion同步下来，生成markdown文档。 使用github action创建hexo部署环境，将markdown发布成博文。 github有手机端，支持ios和android，支持上传图片，网页端也是相当的好用，github action透明发布，不用再关心部署环境。 大家也可以举一反三，使用这种方式，同步发布公众号什么的。 整体github action配置为 name: deploy discussion to hexo blog on: # init workflow # push: # branches: # - source discussion: types: [created, edited] env: # change env here GITHUB_NAME: naosense GITHUB_EMAIL: pingao777@gmail.com GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; ACTION_DEPLOY_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_SECRET &#125;&#125; jobs: sync: name: Build runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: ref: 'source' - name: Set up Python uses: actions/setup-python@v4 with: python-version: 3.11.4 - name: Get pip cache dir id: pip-cache run: | echo &quot;dir=$(pip cache dir)&quot; &gt;&gt; $GITHUB_OUTPUT - name: pip cache uses: actions/cache@v3 with: path: $&#123;&#123; steps.pip-cache.outputs.dir &#125;&#125; key: $&#123;&#123; runner.os &#125;&#125;-pip-$&#123;&#123; hashFiles('**/requirements.txt') &#125;&#125; restore-keys: | $&#123;&#123; runner.os &#125;&#125;-pip- - name: Install python dependencies run: | python -m pip install --upgrade pip if [ -f requirements.txt ]; then pip install -r requirements.txt; fi if: steps.pip-cache.outputs.cache-hit != 'true' - name: Check discussion if is ready id: check_discussion run: | python deploy.py - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: 16.19.0 cache: 'npm' - name: Install hexo and dependencies run: | npm install -g hexo-cli npm install - name: Hexo deploy and Commit md file run: | mkdir -p ~/.ssh/ echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.email &quot;$&#123;&#123; env.GITHUB_EMAIL &#125;&#125;&quot; git config --global user.name &quot;$&#123;&#123; env.GITHUB_NAME &#125;&#125;&quot; git add source/_posts git commit -m 'sync from discussion' \\ &amp;&amp; git push \\ &amp;&amp; hexo douban \\ &amp;&amp; hexo deploy -g \\ &amp;&amp; echo &quot;Done, congrats!&quot; \\ || echo &quot;Oops, something wrong!&quot; 有几点需要注意： 需要使用secret配置一个token，变量名为GH_TOKEN，用来调用github api。 需要生成一个ssh key，用来部署hexo，配置方法参考ssh配置。 这样，你就可以愉快地在地铁里，在被窝里……等任何地方写博客了。","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://naosense.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://naosense.github.io/tags/hexo/"}]},{"title":"二叉树的最近公共父节点","slug":"二叉树的最近公共父节点","date":"2023-11-19T17:14:28.000Z","updated":"2025-09-16T02:08:42.963Z","comments":true,"path":"2023/11/19/二叉树的最近公共父节点/","link":"","permalink":"https://naosense.github.io/2023/11/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%88%B6%E8%8A%82%E7%82%B9/","excerpt":"","text":"leetcode 235 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 leetcode 236 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 这两个题二字之差，一个是二叉搜索树，另一个是二叉树，搜索树是有序的，二叉树是无序的。 二叉搜索树还是比较好写的，我当时很快就写出来了。思路就是根据root与p和q的大小比较，递归的选择一边，直到root介于p和q之间。 class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) &#123; return root; &#125; // 因为是有序的，所以只需要查找一边 if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; return root; &#125; &#125; 但是轮到二叉树就没写对， 我清楚二叉树相比搜索树是无序的，因此需要遍历两个分支，但是依然没写对 ，它的正确代码如下。 class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) &#123; return root; &#125; // p或q在另一个的子树上 if (root == p || root == q) &#123; return root; &#125; // 由于二叉树是无序的，需要遍历左右子树 TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;&amp; right != null) &#123; return root; &#125; return left == null ? right : left; &#125; &#125; 可以看到两个代码结构基本上是等效的，都对root是否为空判断，一个只需要查一边，一个需要查两边，root如果在p和q之间都返回root，但是后者base条件多了一种对如下情况的判断，我当时没有写。 if (root == p || root == q) &#123; return root; &#125; 为啥额外增加这样一种判断呢？或者说搜索树为啥不用专门做这种判断？ 对于二叉树来说这个判断避免一旦p和q其中之一为父节点继续往下递归，因为再往下寻找肯定返回null。而对于搜索树，因为有序，只有父节点同时严格小于或大于p和q才会往下递归，二叉树因为无序所以没有这种条件限制它，因此需要单独加上这个条件。 本以为这样就结束了，这时突然一个问题出现在我的脑海，那就是为啥root在p和q之间时就是最近的公共父节点？换句话说，当root在p和q之间时，继续往下找有没有可能出现更近的公共父节点？各位可能觉得这是一个明摆着的事情，可是当时我把自己问住了，好多事情就怕多问一个为什么🙃。是啊，感觉不太可能，可是为什么不可能呢？ 对付这种杠精问题，最拿手的应该就是反证法了。我们假设root在p和q之间，p在左，q在右，在root的左子树上有一个更近的节点root'，那它必定不是q的父节点，如果root'在右子树，那它必定不是p的父节点，因此root的子树上不可能出现更近的公共父节点了。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://naosense.github.io/tags/leetcode/"},{"name":"hot100","slug":"hot100","permalink":"https://naosense.github.io/tags/hot100/"}]},{"title":"梦终有醒来的一天","slug":"梦终有醒来的一天","date":"2023-11-16T22:56:31.000Z","updated":"2025-09-16T02:08:42.977Z","comments":true,"path":"2023/11/16/梦终有醒来的一天/","link":"","permalink":"https://naosense.github.io/2023/11/16/%E6%A2%A6%E7%BB%88%E6%9C%89%E9%86%92%E6%9D%A5%E7%9A%84%E4%B8%80%E5%A4%A9/","excerpt":"","text":"一直以来，我都认为，一个人如果在某个领域造诣很高，他讲话应该是深入浅出的，要想深入浅出，少不了举例。一个人如果只会罗列概念，满嘴术语，说明他的水平其实还没到炉火垂青的地步。忘了是谁说的了，说是“最伟大的数学家能给邻居老奶奶讲述微积分”。 本书就是这种旁征博引，深入浅出的类型，带着那个时代鲜明的语言特点，简单明了，单刀直入，怕你学不会，怕你不敢学，而不是像现在七绕八拐，怕你学会了，怕你读懂了，仿佛这样的话作者的水平就低了。 或许有些例子现在大家觉得过时了，因为那些示例还带有明显的阶级叙事。是啊，好像一提阶级就是苦大仇深，振聋发聩，现在流行的是温情脉脉，男人至死是少年，女人四十小仙女……，资本给每个人都编织了美丽的梦，那梦美的人都不愿醒来。 老话讲，忠言逆耳利于行，这个时代或许人们已经不习惯听真话了，也没人愿讲真话了，但是无论你想不想听，有没有人讲，真相就在那里，你不找它，它就来找你，因为梦终有醒来的一天。","categories":[],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"哲学","slug":"哲学","permalink":"https://naosense.github.io/tags/%E5%93%B2%E5%AD%A6/"},{"name":"艾思奇","slug":"艾思奇","permalink":"https://naosense.github.io/tags/%E8%89%BE%E6%80%9D%E5%A5%87/"}]},{"title":"螃蟹不好吃","slug":"螃蟹不好吃","date":"2023-11-16T22:16:17.000Z","updated":"2025-09-16T02:08:43.025Z","comments":true,"path":"2023/11/16/螃蟹不好吃/","link":"","permalink":"https://naosense.github.io/2023/11/16/%E8%9E%83%E8%9F%B9%E4%B8%8D%E5%A5%BD%E5%90%83/","excerpt":"","text":"螃蟹，对于我这个北方内陆人来说，一直都是一种神秘的食物。三次尝试，三次的不知所措。带上这次，我对螃蟹的印象依旧模糊，也许更多的是对其复杂性的敬畏。 鲁迅说，第一个吃螃蟹的人必定是勇士，我深以为然。那个决定将这种多脚生物送入口中的人，一定拥有无与伦比的勇气和探索精神。想象一下，最初发现螃蟹时的人们是如何克服对这种奇异生物的恐惧，然后尝试并发现其可食用的。他们或许在艰难的试错中，一点点探索出螃蟹的美味所在。 但对我来说，每一次螃蟹摆在眼前，都是一场挑战。它们外表坚硬，似乎隐藏着无数秘密，而我却只能束手无策地面对。第一次，我犹豫不决，不知从何下口；第二次，尝试摆弄着螯，却频频遭到无情的反击；第三次，更像是在和一位不熟悉的工艺品较劲，除了些微的肉，却没能品尝到更多。 螃蟹在餐桌上的优雅摆放，似乎与其野性十足的外表形成了鲜明对比。从那盘螃蟹身上，我看到了别人娴熟地挥舞着锤子和钳子，轻松地剥开蟹壳，取出丰盛的肉。而我，则像是面对一门未解之谜，不知如何下手。 或许，对于北方人来说，对螃蟹的陌生感正是一种美好。在每一次碰触中，我仿佛能够重新审视这个世界，发现那些隐藏在食物背后的文化与习俗。而尽管我对螃蟹的品尝历程充满了困惑与挣扎，但我却体会到了尊重和欣赏它所蕴含的独特之处。 或许，尝试螃蟹并不只是一次简单的美食探索，更是一次对勇气和耐心的考验。第一个吃螃蟹的人是勇士，而我，也在每一次失败和困惑中，慢慢地成长着，学会尊重和感悟这份美好。","categories":[],"tags":[{"name":"螃蟹","slug":"螃蟹","permalink":"https://naosense.github.io/tags/%E8%9E%83%E8%9F%B9/"}]},{"title":"189. 轮转数组","slug":"189-轮转数组","date":"2023-09-28T16:32:26.000Z","updated":"2025-09-16T02:08:42.938Z","comments":true,"path":"2023/09/28/189-轮转数组/","link":"","permalink":"https://naosense.github.io/2023/09/28/189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"","text":"给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 提示： 1 &lt;= nums.length &lt;= 105 -231 &lt;= nums[i] &lt;= 231 - 1 0 &lt;= k &lt;= 105 题意挺好理解，就是将一个数组循环右移嘛。如果能够使用一个额外的数组，那将是非常容易，将数据拷贝一份，然后依次拷贝到偏移下标的地方，但是如果要求O(1)的空间复杂度呢？也是不难想起来，比如示例一，从下标0开始，依次将下标0的元素挪到下标3，即1挪到4的位置，以此类推，4挪到7的位置……，但是点子易得，方案难想，因为里面有许多细节需要确定。比如就这样挪动下去，截至条件是啥呢？一个很自然的想法是对挪动次数计数，截止条件就是计数值等于数组长度，我当时就是这么想得，可是这不是全部的真相。比如举个简单的例子，数组为[1,2,3,4]，k为2，但是挪动的过程会发生循环移动的情况，也就是下标0挪到下标2，下标2又挪到下标0，接着还是这个过程，最后循环截至，下标1和下表3根本没动，这显然不对。 那真正的全部真相是什么样的呢？我也是看了答案才知道。原来这种挪动，挪到最后会回到起始点，到了起始点之后，开启第二轮挪动，第二轮挪动的起始点是第一轮的下一个位置，这种挪动会持续多轮才能完成。我看了答案，不禁大呼人比人真是气死人，这脑子咋长得？接着我就有了三个疑问，一是为什么这种挪动会回到起点，二是多轮之间会不会有交集？三是一共要进行多少轮？ 首先第一个问题，为什么会回到起点？假设数组长度为n，每一步为k，要回到起点也就是要走整数个n的长度，也就是k走的够多，最终肯定会有一个数等于n的倍数，第一个遇到的就是最小公倍数嘛，为了方便将最小公倍数记为$LCM(n, k)$。 第二个问题，轮与轮之间难道没有交集吗？这个问题我们不妨反过来想，假如两轮之间有交集，这意味着一轮还没结束，因为这个交集元素两轮都可达，如果是这样，又称不上两轮了，因此不同轮次之间没有交集。 第三个问题，需要多少轮？一轮总共走了$LCM(n, k)$的距离，步长为k，那一轮应该是$step = LCM(n, k) / k$步，即挪动了这么多元素，因此需要$n / step = n*k / LCM(n, k) = 最大公约数 = GCD(n, k)$轮。相信那些和我一样将代数知识早已还给老师的人看到这里已是一脸懵逼，你不是一个人，我们一起复习下。 对于两个整数n和k，它们的最小公倍数$LCM(n, k)$和最大公约数$GCD(n, k)$有如下关系： $$LCM(n, k) * GCD(n, k) = n * k$$ 学有余力的同学可以看看下面的证明，来自chatgbt。 假设有两个整数 n 和 k，它们的最大公约数为 d（即 GCD(n, k) = d）。那么我们可以表示 n 和 k 如下： n = d * a k = d * b 在这里，a 和 b 是整数，它们分别表示 n 和 k 相对于它们的最大公约数 d 的倍数。这个分解的关键是，a 和 b 是互质的，即它们没有除 1 以外的共同因子。 那么 n 和 k 的最小公倍数可以表示为： LCM(n, k) = LCM(d * a, d * b) 由于 a 和 b 互质，它们的最小公倍数为 1，因此最小公倍数可以简化为： LCM(n, k) = d * LCM(a, b) 而 LCM(a, b) 就是 a 和 b 的乘积，即 a * b。 所以，最小公倍数和最大公约数之间的关系为： LCM(n, k) = d * (a * b) = d * (n / d * k / d) = (n * k) / d = (n * k) / GCD(n, k) 即LCM(n, k) * GCD(n, k) = n * k 解答了这三个问题可以得出两点结论： 需要挪动多轮，即$GCD(n, k)$轮 每一轮的截至条件是到达起点 由此，我们写出代码。 class Solution &#123; public void rotate(int[] nums, int k) &#123; int n = nums.length; k = k % n; int count = gcd(n, k); for (int start = 0; start &lt; count; start++) &#123; int si = start; int source = nums[si]; do &#123; int ti = (si + k) % n; int target = nums[ti]; nums[ti] = source; source = target; si = ti; &#125; while (si != start); &#125; &#125; private int gcd(int x, int y) &#123; return y &gt; 0 ? gcd(y, x % y) : x; &#125; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://naosense.github.io/tags/leetcode/"},{"name":"hot100","slug":"hot100","permalink":"https://naosense.github.io/tags/hot100/"}]},{"title":"ReentrantLock源码解读","slug":"ReentrantLock源码解读","date":"2023-09-04T11:20:09.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2023/09/04/ReentrantLock源码解读/","link":"","permalink":"https://naosense.github.io/2023/09/04/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"根据Javadoc的说法， A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities. ReentrantLock是一个类似synchronized的可重入互斥锁，拥有类似的行为和语义，以及一些扩展功能，比如公平锁、非阻塞尝试、可中断。 早年间，有传言说ReentrantLock的性能不如synchronized，不过这一点Java的架构师Brian Goetz在《并发编程实战》中作了澄清： 在Java 5.0中，当从单线程（无竞争）变化到多线程时，内置锁的性能急剧下降，而ReentrantLock的性能下降则更为平缓，因而它具有更好地可伸缩性。但在Java 6.0中，情况就完全不同了，内置锁的性能不会由于竞争而急剧下降，并且两者的可伸缩性也基本相当。 可见，ReentrantLock在性能上一直都没有落后过，如果硬要说有，那也是领先。作者还告诫“像‘X比Y更快’这样的表述大多是短暂的”。 回到正题，下面是ReentrantLock的一个典型用例。 class X &#123; private final ReentrantLock lock = new ReentrantLock(); // ... public void m() &#123; lock.lock(); // block until condition holds try &#123; // ... method body &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; 可以看到ReentrantLock需要手动显式地解锁，并且解锁要放在finally块中，确保锁得到释放。 它的核心也是AQS，一起看看如何实现的，具体的代码如下。 abstract static class Sync extends AbstractQueuedSynchronizer &#123; final boolean tryLock() &#123; Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (getExclusiveOwnerThread() == current) &#123; if (++c &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(c); return true; &#125; return false; &#125; abstract boolean initialTryLock(); @ReservedStackAccess final void lock() &#123; if (!initialTryLock()) acquire(1); &#125; @ReservedStackAccess final void lockInterruptibly() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!initialTryLock()) acquireInterruptibly(1); &#125; @ReservedStackAccess final boolean tryLockNanos(long nanos) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return initialTryLock() || tryAcquireNanos(1, nanos); &#125; @ReservedStackAccess protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (getExclusiveOwnerThread() != Thread.currentThread()) throw new IllegalMonitorStateException(); boolean free = (c == 0); if (free) setExclusiveOwnerThread(null); setState(c); return free; &#125; // ...省略一些不重要的方法 &#125; Sync继承自AQS，和Semaphore一样，也有两种工作模式：公平模式和非公平模式，state表示锁重入的次数。 static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; final boolean initialTryLock() &#123; Thread current = Thread.currentThread(); if (compareAndSetState(0, 1)) &#123; // first attempt is unguarded setExclusiveOwnerThread(current); return true; &#125; else if (getExclusiveOwnerThread() == current) &#123; int c = getState() + 1; if (c &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(c); return true; &#125; else return false; &#125; protected final boolean tryAcquire(int acquires) &#123; if (getState() == 0 &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; &#125; static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final boolean initialTryLock() &#123; Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedThreads() &amp;&amp; compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (getExclusiveOwnerThread() == current) &#123; if (++c &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(c); return true; &#125; return false; &#125; protected final boolean tryAcquire(int acquires) &#123; if (getState() == 0 &amp;&amp; !hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; &#125; 我看这段源码时有两个疑问，initialTryLock的代码和tryLock非常像，为什么要单独设置一个initialTryLock方法？二是联系之前解读过的CountdownLatch和Semaphore，tryAcquire*和tryRelease*方法为什么一会有循环一会没循环？ 首先，第一个问题，为什么要单独设置一个initialTryLock方法？从代码上看，initialTryLock在公平模式和非公平模式下各有一个实现，而tryLock只有一个非公平实现，javadoc中还专门作了说明。 …Also note that the untimed tryLock() method does not honor the fairness setting. It will succeed if the lock is available even if other threads are waiting. 同时，在tryLock的方法中也作了注释。 Acquires the lock if it is not held by another thread and returns immediately with the value true, setting the lock hold count to one. Even when this lock has been set to use a fair ordering policy, a call to tryLock() will immediately acquire the lock if it is available, whether or not other threads are currently waiting for the lock. This “barging” behavior can be useful in certain circumstances, even though it breaks fairness. 大意是为了一些特殊的场景，tryLock有意设计成非公平的，即使ReentrantLock是工作在公平模式下。initialTryLock则不然，它需要在不同的模式下表现不同的行为，在Sync中，它充当lock*方法的前置判断逻辑，即如果成功抢到锁，那么获得运行权，否则，线程排队等待。话说回来，为什么要把tryLock设计成非公平的模式呢？这和tryLock的使用场景有关，tryLock一般用在高吞吐的无线程等待的场景，搭配unlock方法使用，加锁解锁仅仅只是一些CAS操作，避免了线程的切换和等待。 第二个问题，为啥tryAcquire*方法和tryRelease*方法一会有循环，一会没循环呢？比如在Semaphore中，tryAcquireShared和tryReleaseShared都有循环，而在ReentrantLock中，tryAcquire和tryRelease都没循环。我觉得，原因和并发组件中的Sync工作模式有关。共享模式下，允许多个线程运行，因此在调用tryAcquire*争夺运行权时，势必有的线程失败，因为一次只有一个成功，但是失败了不要紧，还有机会，那些失败的可以紧接着再次尝试争夺，直到资源被争夺一空（state到达某个约定状态），那些仍然没有争夺成功的进入队伍排队。而独占模式下，因为只允许一个线程运行，大家在竞争这个资源时，失败的线程没必要再去尝试了，成功的就成功了，失败的也不要来回尝试了，因为仅有一次机会，tryRelease*同理。 但是还需要明确一点，方法中到底有没有循环，还要根据组件的方法语义来决定，比如CountdownLatch的tryAcquireShared就没有循环，因为tryAcquireShared方法是在await方法调用的，它的语义是等待，而不是争夺资源，不需要修改state。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://naosense.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"juc","slug":"juc","permalink":"https://naosense.github.io/tags/juc/"}]},{"title":"206. 反转链表","slug":"206-反转链表","date":"2023-08-29T17:23:57.000Z","updated":"2025-09-16T02:08:42.951Z","comments":true,"path":"2023/08/29/206-反转链表/","link":"","permalink":"https://naosense.github.io/2023/08/29/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3： 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 这道题经常被同事们戏称为“送分题”，比如你面试别人时特别想要那个人，那就给他出这个题。那意思是说这道题是个人就会，但是我见过不少人阴沟翻船的时候，原因可能是这道题太简单了，以至于刷题时都不屑于刷，到了面试这种高度紧张的场合，一着急写不出来了。所以大家不要掉以轻心，复杂总是起于简单，而且本题是解其他衍生题的基础，比如234. 回文链表，92. 反转链表 II。 一开始看这道题时我的想法是，既然你是要把链表反转，那我依次将每个节点的next指针换个方向不就行了，示意图如下。 代码如下。 class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode cur = head; ListNode pre = null; while (cur.next != null) &#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; cur.next = pre; return cur; &#125; &#125; 后面看了答案，第一次知道了“头插法”，即不断的将“头”的后一个节点移到头的前一个节点，直到最后一个节点，示意图如下。 代码如下。 class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null) return head; ListNode dummy = new ListNode(-1, head); ListNode cur = head; while (cur.next != null) &#123; ListNode next = cur.next; cur.next = next.next; next.next = dummy.next; dummy.next = next; &#125; return dummy.next; &#125; &#125; 我个人觉得头插法写起来更简单紧凑，当然这是一个智者见智的问题，小伙伴们你怎么看？","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://naosense.github.io/tags/leetcode/"},{"name":"hot100","slug":"hot100","permalink":"https://naosense.github.io/tags/hot100/"}]},{"title":"Semaphore源码解读","slug":"Semaphore源码解读","date":"2023-08-27T11:12:54.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2023/08/27/Semaphore源码解读/","link":"","permalink":"https://naosense.github.io/2023/08/27/Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"根据Java Doc的说法，Semaphore是一个控制访问某种资源并发量的组件。 Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. 例如，下面是一个使用信号量来控制对Item池访问的类： class Pool &#123; private static final int MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); public Object getItem() throws InterruptedException &#123; available.acquire(); return getNextAvailableItem(); &#125; public void putItem(Object x) &#123; if (markAsUnused(x)) &#123; available.release(); &#125; &#125; // Not a particularly efficient data structure; just for demo protected Object[] items = ... // whatever kindsof items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() &#123; for (int i = 0; i &lt; MAX_AVAILABLE; ++i) &#123; if (!used[i]) &#123; used[i] = true; return items[i]; &#125; &#125; return null; // not reached &#125; protected synchronized boolean markAsUnused(Object item) &#123; for (int i = 0; i &lt; MAX_AVAILABLE; ++i) &#123; if (item == items[i]) &#123; if (used[i]) &#123; used[i] = false; return true; &#125; else &#123;return false;&#125; &#125; &#125; return false; &#125; &#125; 这个例子，available是一个信号量，最大并发数是100，用这个信号量来控制调用getItem的并发数。我初看这个例子时，有个疑问，那就是虽说信号量限制了并发访问数，但是getNextAvailableItem不是加锁了吗，最终不还是只有一个线程才能访问吗？ 后面想了想，这个例子的信号量用来控制的不是最终拥有访问权限的并发数，而是争夺这个权限的候选者的个数。就好比选举中，当选者和候选者的关系，在这两者之外，还有广大的普罗大众。 下面看看AQS在Semaphore是怎么使用的。 abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; Sync(int permits) &#123; setState(permits); &#125; final int getPermits() &#123; return getState(); &#125; final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(&quot;Maximum permit count exceeded&quot;); if (compareAndSetState(current, next)) return true; &#125; &#125; final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); int next = current - reductions; if (next &gt; current) // underflow throw new Error(&quot;Permit count underflow&quot;); if (compareAndSetState(current, next)) return; &#125; &#125; final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125; &#125; &#125; 这是Semaphore的核心代码。Sync继承了AQS，通过state状态变量维护最大并发许可数permits，获取许可就减去一定的许可，释放就增加一定的许可，最终通过compareAndSetState完成修改。 /** * NonFair version */ static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125; &#125; /** * Fair version */ static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; &#125; Semaphore可以设置成公平和非公平模式，二者唯一的差别就是公平模式会调用hasQueuedPredecessors判断前面是否还有等待的线程。如果前面还有排队的线程，直接返回失败，否则，和非公平逻辑一样。 Semaphore api看着不少，核心其实就两个acquire和release，都是围绕着Sync中的方法进行调用，就不赘述了。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://naosense.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"juc","slug":"juc","permalink":"https://naosense.github.io/tags/juc/"}]},{"title":"234. 回文链表","slug":"234-回文链表","date":"2023-08-24T14:58:45.000Z","updated":"2025-09-16T02:08:42.951Z","comments":true,"path":"2023/08/24/234-回文链表/","link":"","permalink":"https://naosense.github.io/2023/08/24/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","excerpt":"","text":"给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 示例 1： 输入：head = [1,2,2,1] 输出：true 示例 2： 输入：head = [1,2] 输出：false 提示： 链表中节点数目在范围[1, 105] 内 0 &lt;= Node.val &lt;= 9 我常觉得解链表题好比理耳机线，通常链表题都不会涉及太多的算法，要得是细心和耐心，一不小心就可能缠作一团，所以做链表题大家拿笔画一画，就比较清楚了。 “回文”大家应该都知道啥意思，就是镜像，第一个和最后一个一样，第二个和倒数第二个一样……，以此类推。但是，链表没法像数组那样直接按索引随机读取，所以得把后半段反转一下，之后一个指针指向头，一个指针指向中间，依次往后检查。这一个题相融合了三个题：链表反转、寻找链表中点、判断回文。 先写链表反转，没啥好说的。方法也有好多种，记住一种就行了，记的多了还容易乱，我比较习惯头插法，啥叫头插法，就是不断的将“头”的后一个节点移到头的前一个节点，直到最后一个节点，就完成了反转，如下。 private ListNode reverse(ListNode head) &#123; ListNode dummy = new ListNode(-1, head); ListNode cur = head; while (cur.next != null) &#123; ListNode next = cur.next; cur.next = next.next; next.next = dummy.next; dummy.next = next; &#125; return dummy.next; &#125; 然后找中点，采用快慢指针的方式，快的一次走两步，慢的一次走一步，当快的走到末尾时，慢的正好是链表的一半。思想很简单，就是细节得想明白。比如，快的一次走两步，那是一步一步走走两次还是一次走两步，走到“末尾”是走到最后一个节点，还是走到不足两步就停下来，那如果这时候停下来，慢的还正好在中点这个位置上吗？ 先来看是一步一步走，还是一次走两步。 一次走一步，走两次，如下。 private ListNode getMiddle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast.next != null) &#123; slow = slow.next; fast = fast.next; if (fast.next != null) &#123; fast = fast.next; &#125; &#125; return slow; &#125; 一次走两步。 private ListNode getMiddle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; return slow; &#125; 是不是看起来差不多？实际上是不一样的，当n为偶数时，前一种会多走一步，n为奇数时两者一样。其实本题用哪个都行，关键你要关注到两者的不同，后面的代码也因之不同。 再来看第二个问题，走到“末尾”是走到最后一个节点，还是走到不足两步就停下来，如果这时候停下来，慢的还正好在中点这个位置上吗？假设链表上有n个节点，也就是能走n-1步，这意味着奇数个节点有偶数步，偶数个节点有奇数步。比如，如果链表有3个节点，那只有2步，有4个节点，有3步，对于快指针来说偶数步正好走到最后一个节点，奇数步走到倒数第二个节点；对于慢指针来说，偶数步走到第(n-1)/2 + 1个节点，如果n为3，那应该是走到第2个节点，正好是中间，奇数步的话，如果是“一次走两步”是走到第(n-1-1)/2 + 1个节点，如果n为4，也是走到第2个节点，链表前半段的末尾。还记得上面说，如果“一步一步走”，会多走一步，也就是会落在第3个节点，即后半段的开头。因此，第二个问题的答案可以笼统的说，慢指针会落在链表的中间节点上，只不过有时候不同走法前后会相差一个。 现在问题就简单了，下面是我写的第一个版本，当时的想法是找到中点，中点的下一个是后半段的头，然后从中间断开，将后半段反转，然后依次判断前半段和后半段反转后的节点值，只有完全一样才会继续往后走，否则直接返回false，不知道大家看出问题没。 public boolean isPalindrome(ListNode head) &#123; // 采用一次走两步的方式 ListNode pre = getMiddle(head); ListNode mid = pre.next; pre.next = null; if (mid == null) return true; ListNode head2 = reverse(mid); while (head != null || head2 != null) &#123; if (head != null &amp;&amp; head2 != null) &#123; if (head.val != head2.val) return false; head = head.next; head2 = head2.next; &#125; else &#123; return false; &#125; &#125; return true; &#125; 上面的写法，忽略了遇到奇数个节点时，getMiddle切割的前后两段节点数是不一样的，前半段会多一个，这会导致head != null而head2 == null情况出现，进而返回false，比如[1, 2, 1]，下面是改正后的。 public boolean isPalindrome(ListNode head) &#123; // 采用一次走两步的方式 ListNode pre = getMiddle(head); ListNode mid = pre.next; pre.next = null; if (mid == null) return true; ListNode head2 = reverse(mid); while (head != null &amp;&amp; head2 != null) &#123; if (head.val != head2.val) return false; head = head.next; head2 = head2.next; &#125; return true; &#125; 事实上，head != null &amp;&amp; head2 != null的判断条件可以进一步精简为head2 != null，因为getMiddle已经对前后两端的长度做了保证，前半段的长度是不会小于后半段的。前后两段也可以不断开，getMiddle使用的是“一次走两步”的方式，如果用的是“一次走一步走两次”的方式，返回值直接就是head2，不用再下一个了。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://naosense.github.io/tags/leetcode/"},{"name":"hot100","slug":"hot100","permalink":"https://naosense.github.io/tags/hot100/"}]},{"title":"树莓派折腾记（1）：电子宠物养起来了","slug":"树莓派折腾记（1）：电子宠物养起来了","date":"2023-08-20T11:36:39.000Z","updated":"2025-09-16T02:08:42.975Z","comments":true,"path":"2023/08/20/树莓派折腾记（1）：电子宠物养起来了/","link":"","permalink":"https://naosense.github.io/2023/08/20/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%94%B5%E5%AD%90%E5%AE%A0%E7%89%A9%E5%85%BB%E8%B5%B7%E6%9D%A5%E4%BA%86/","excerpt":"之前时不时的看网上有人在玩树莓派，可以折腾不少有意思的小项目。说树莓派就是一个大号的单片机，哎，一说单片机我可就不困了，想起上学那会和小伙伴们逛电子元件市场，买来51单片机、电阻、电容、面包板……，在宿舍拿着烙铁焊接，烧录程序，联调测试……。唉！好久没折腾这些玩意了，你别说，手还真的有点痒。为了“忆苦思甜”，同时也为了满足自己的折腾欲，上周终于下定决心买了一个，几番对比后，最终选择的是4B 4G版本。经过一个周末的折腾，电子宠物终于养起来了。","text":"之前时不时的看网上有人在玩树莓派，可以折腾不少有意思的小项目。说树莓派就是一个大号的单片机，哎，一说单片机我可就不困了，想起上学那会和小伙伴们逛电子元件市场，买来51单片机、电阻、电容、面包板……，在宿舍拿着烙铁焊接，烧录程序，联调测试……。唉！好久没折腾这些玩意了，你别说，手还真的有点痒。为了“忆苦思甜”，同时也为了满足自己的折腾欲，上周终于下定决心买了一个，几番对比后，最终选择的是4B 4G版本。经过一个周末的折腾，电子宠物终于养起来了。 目前折腾的进度: 烧录系统 配置wifi 配置默认用户密码 解锁root用户 修改软件源 配置BT下载 配置网盘客户端 配置samba 配置minidlna 安装kodi家庭影院 挂载硬盘 设置静态IP 下面细说过程和遇到的坑。 烧录系统 烧录挺顺利的。从官网下载系统，链接为https://www.raspberrypi.com/software/operating-systems/，我选择的是Raspberry Pi OS with desktop and recommended software 32位版本。 之所以选择这个版本是因为软件比较全，在折腾的过程中不至于陷入不停安装软件或依赖的地狱，毕竟第一次折腾。没有下载64位系统是因为看网上评论说64位系统刚出，性能和稳定性还不如32位。下载完成后，使用SDFormatter格式化SD卡，使用Win32DiskImager烧录镜像，之所以选择这两个，是因为卖家提供的教程以及网上的资料大都是这两个软件，官方也有烧录软件，回过头看，可能当初使用官方的更好，这是后话，后面会解释。总之，到这里一切顺利。 配置wifi 下面坑来了，因为我没有屏幕也没有网线，因此走的是无屏幕无线启动。按照卖家给的教程和网上的资料，大部分设置wifi的方法都是在烧录好的镜像boot分区新建wpa_supplicant.conf文件，填入以下配置， country=CN ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network=&#123; ssid=&quot;wi-fi name here&quot; psk=&quot;wi-fi password here&quot; key_mgmt=WPA-PSK &#125; 我试了好几次，都不行，使用Advanced IP Scanner根本扫描不到，无奈只好向客服求助。客服给了一个url：https://www.pistar.uk/wifi_builder.php，填入wifi名称和密码，可以生成wifi配置文件，拖到boot分区根目录，终于可以连上wifi了。对比了下，它生成的配置zhan长这样， ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 ap_scan=1 fast_reauth=1 country=CN network=&#123; #ssid=&quot;wifi name&quot; ssid=77696669206e616d65 #psk=&quot;wifi pass&quot; psk=0bac15b1c47e8e33b0f81b03be8fc75099109162dac4cda4ef1ef09aec4c461e id_str=&quot;0&quot; priority=100 scan_ssid=1 &#125; 看起来多了一些配置，而且wifi名称和密码都不是明文了，或许官方为了安全将原来的配置方式废弃了，放在这里给大家避坑。 配置默认用户名和密码 按照原来的教程树莓派开机就有一个默认用户pi，默认密码是raspberry，可是我试了下，已经不行了，提示这个， 查了一下，才发现官方在2022年取消了默认用户和密码，解决办法一是使用官方的烧录工具，有设置用户和密码的步骤，这也是上文说使用官方的烧录软件会更好的原因，因为我都走到这了，不想再走回头路了，因此采用的是另一种方法，在boot分区创建userconf.txt文件，在该文件内输入用户名和密码的密文，格式如下， 用户名:密码密文 以下例子，用户名为pi，密码为raspberry的密文， pi:$6$4ilokQRQxmURT.py$aJWBQ5yniJJPwV3CKawYJcnSK5JZGhrVZYF3K4omRUFv6KL0MysEH7F4NZRMNMcYF.U3xsQvWrx7ZL2GKxuv.1 正常登录后，不要忘了使用passwd pi改下默认密码。 默认用户和密码也搞定了！ 解锁root用户 默认root用户是没有启用的，有时候某些操作是需要root用户的，可以先使用如下命令设置root密码， sudo passwd root 然后，解锁root用户， sudo passwd --unlock root 修改软件源 将官方的源替换为国内的源来获取更快的下载速度， sudo vi /etc/apt/sources.list 注释掉原来的内容，加上国内的源，比如清华的， deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/ raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 更改系统源， sudo vi /etc/apt/sources.list.d/raspi.list 注释原来的源，增加下面的内容， deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ debian/ buster main ui 然后更新仓库及执行升级， sudo apt-get update sudo apt-get upgrade 提醒一句，国内源虽快，但是不如官方源完备，我在安装samba服务的时候使用清华源就提示依赖不满足：“The following packages have unmet dependencies:&quot;，最终切回官方源，安装成功。 配置BT下载 BT下载软件我安装的是qbittorrent，原因就是安装简单，一条命令搞定，aria2和transmission都需要一大坨配置，而且也没看出它们能做qbittorrent不能做的点。 sudo apt install -y qbittorrent-nox 安装完成后，使用如下命令启动， qbittorrent-nox -d 然后，在浏览器中输入你的树莓派ip:8080就可以看到qbittorrent的ui了，使用方法还是比较简洁直观的，支持torrent和磁力链接。 安装完成后，我就迫不及待的找了宫崎骏的《龙猫》的种子，准备试试速度，毕竟想要一个BT下载机也是买树莓派的动机之一。试过之后，有点失望，根本下不动，经过一通谷歌，说是得加tracker，从网上找了几个tracker list，加了之后效果也一般，聊胜于无，后来想了下可能种子太老了，又换了时间更新的几个磁力链接，还是不行。又是一通谷歌百度，说得要公网IP，好吧，先这样将就着用吧。不过后来找了个《流浪地球2》的种子，下起来挺快的。 配置网盘客户端 唉，因为上面BT下载不尽如人意，所以又找了些网盘作为补充。 百度我用的是bypy，阿里用的aliyunpan。百度的非会员速度有限制，下载也就几十K，阿里的没有速度限制，用起来还是挺爽的。 配置samba 本来以为samba很简单，不就是一条apt install命令吗，没想到折腾了好久，原因就是清华的源相比官方源软件有滞后。 初始，执行sudo apt-get install samba，提示， The following packages have unmet dependencies: ... Recommends: attr but it is not going to be installed Recommends: samba-dsdb-modules but it is not going to be installed Recommends: samba-vfs-modules but it is not going to be ... 谷歌了一番，说是缺少库，结果安装这些库，又提示说缺少另一些库，也就是你安装A，它说你缺少B、C、D，你手动去安装B，结果它又告诉你缺少X、Y、Z。碰到递归依赖的问题，真是头大。 查了好久，试了好多方法，都不行，安装不上，后来鬼使神差的换会原来的官方源，执行sudo apt-get install samba，刷刷刷，装上了。所以，大家如果遇到安装软件不成功的情况，可以换回原来的官方源再试试。 安装上samba，下面就简单了，在/etc/samba/smb.conf添加如下配置 [shared] path = /home/pi/shared writeable=Yes create mask=0777 directory mask=0777 public=yes browseable=yes 创建samba用户 sudo smbpasswd -a pi 重启服务 sudo systemctl restart smbd Windows、Mac、Android、Iphone连接samba服务方法各不相同，但是大同小异，大家自行百度，不再赘述。 配置minidlna 首先安装minidlna， sudo apt-get install minidlna 修改配置文件sudo vi /etc/minidlna.conf #media_dir=A,/example/audio #音频目录 #media_dir=P,/example/picture #图片目录 media_dir=V,/example/video #视频目录 看网上说还得给这些目录777权限，但是我试了下不给也能观看，我就把这些配置去掉了。就加了一行配置，即上面的视频目录。 启动服务， sudo service minidlna start 修改配置文件及媒体资源更新，需要强制刷新时， sudo service minidlna force-reload 如果想取消开机启动， sudo update-rc.d -f minidlna remove 停止所有minidlna进程， sudo service minidlna stop 现在一般的电视盒子都可以识别dlna服务，但是我家的腾讯盒子播放视频没声音，不知道为啥，可能盒子太老了。手机、电脑可以使用VLC、Oplayer等软件播放dlna视频。 说到这里，我对minidlna和samba的区别还不是特别明白，感觉差不多，都是去分享某个东西，因此就不献丑总结了。引用一位网友的话， smb对文件格式的适用性更广，dlna对播放设备的适用性更广。一个是直接共享文件，一个是共享要播放的媒体文件，当然日常使用都差不多，但智能电视这种相关文件管理软件少的设备用dlna蛮方便的。 安装kodi家庭影院 这是我购买树莓派最期待的一个功能了。可惜我家的盒子装不上kodi软件，32位64位都试了，都不行，提示“软件包已损坏”。谷歌了好久，也没查出来原因，我的家庭影院梦戛然而止。万能的网友，有谁遇到类似的问题，如果知道答案，麻烦告知下。 !!2023-09-10更新 换了个盒子，终于可以安装kodi了，安装过程没什么波澜，只是配置刮削器时配置哪个都不好使，无论是官方的TMDB，还是豆瓣，MTime都不行。查了半天资料，说是TMDB被墙了，后面两个停止维护了，尼玛。。。前有狼后有虎，怎么办？突然想到自己手机有VPN，能不能用手机做代理访问TMDB，没想到还真可以！ 方法是，打开Clash-设置-覆写-复合端口，设置一个端口，比如4321，然后点击wifi连接，拿到自己的局域网ip，在kodi代理写上上述的ip和端口，开启手机VPN，就可以刮削了。 挂载硬盘 之前买了一个惠普的台式机暗夜精灵，一天软件提示有新的BIOS版本，我点了个“升级”，主板就这样光荣的牺牲了，你敢信？保修期也过了，问了售后换一个主板和买一个新的主机价钱也差不多了，因此就放在角落里闲置了。 树莓派可以挂载硬盘，之前闲置的硬盘终于可以废物利用了。 使用df -h命令查看硬盘挂载位置，发现默认是挂载到了/media/pi/DATA中，如果你想挂载到一个不同的路径，需要先把硬盘卸载下来， sudo umount /dev/sda1 然后重新挂载到指定目录， sudo mount /dev/sda1 /home/pi/sda 我在执行这一步时报错了， The disk contains an unclean file system (0, 0). Metadata kept in Windows cache, refused to mount. 已经安装了ntfs-3g， sudo apt-get install ntfs-3g -y sudo modprobe fuse 咋回事呢？又百度谷歌了一番，使用如下命令修复， sudo ntfsfix /dev/sda1 看起来可以了。 配置开机自动挂载， sudo vi /etc/fstab 文件有六列： 第一列：磁盘分区名/卷标； 第二列：挂载点 第三列：文件系统类型 第四列：缺省设置，一般用defaults，默认硬盘如果找不到会报错，如果不想这样，可以加上nofail 第五列：是否备份：0——表示不做dump备份 第六列：检测顺序：0——不进行检测；根分区（/），必须填写1，其它的都不能填写1。如果有分区填写大于1的话，则在检查完根分区后，从小到大依次检查下去。 我加的配置如下 /dev/sda1 /home/pi/sda ntfs defaults,nofail 0 0 !!配置更改 根据Arch Wiki的说法，盘符的名字可能随着加载的顺序变化： If your machine has more than one SATA, SCSI or IDE disk controller, the order in which their corresponding device nodes are added is arbitrary. This may result in device names like /dev/sda and /dev/sdb switching around on each boot, culminating in an unbootable system, kernel panic, or a block device disappearing. Persistent naming solves these issues. 所以，我打算把挂载硬盘的方式换成UUID的方式。先用这个获取硬盘的UUID。 sudo blkid 将原来的配置更换为下面的配置。 UUID=&quot;your uuid&quot; /home/pi/sda ntfs defaults,nofail 0 0 设置静态IP 发现有时候树莓派重启会更换IP，静态IP使用起来会更方便。 使用下面命令打开配置， sudo vim /etc/dhcpcd.conf 在文件中增加如下配置， interface wlan0 #网卡名 inform 192.168.2.218/24 #树莓派IP static routers=192.168.2.1 #路由器IP static domain_name_servers=192.168.2.1 #DNS，这里也是路由器IP 重启，IP就是固定的了。 sudo reboot !!配置更改 因为上面需要设置路由器IP，但是我发现路由器重启会更换IP，因此换成了如下的配置。 interface wlan0 request 192.168.0.100 发现不管用，又换成了下面的方式，亲测可用。 interface wlan0 inform 192.168.0.100 两种用法的详细解释见stackexchange上这个帖子，里面提到后面一种，也就是inform这种方式可能会有bug，会产生大量的日志，不过有人说已经修复了。 好了，至此，基本上就配置完了，遇到了一些坑，好在基本上都解决了，中间的过程可谓是“痛并快乐着”，但是配置完成的那一刻还是很有成就感的。相信其中遇到的一些问题及解决方法对你有所帮助，接下来，打算买点传感器，折腾折腾嵌入式。 最终的效果， 参考资料： https://www.raspberrypi.com/software/operating-systems/ https://zhuanlan.zhihu.com/p/266495858 https://zhuanlan.zhihu.com/p/484963590 https://zhuanlan.zhihu.com/p/457890714 https://zhuanlan.zhihu.com/p/101616464 https://zhuanlan.zhihu.com/p/312387581 https://wiki.archlinux.org/index.php/Persistent_block_device_naming https://raspberrypi.stackexchange.com/questions/137443/dhcpcd-conf-inform-vs-static-ip-vs-request-how-should-you-really-setup-a-static https://raspberrypi.stackexchange.com/questions/137112/why-does-dhcpcd-flood-my-logs-with-with-useless-messages-when-i-use-the-inform https://askubuntu.com/questions/462381/cant-mount-ntfs-drive-the-disk-contains-an-unclean-file-system","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://naosense.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"raspberry pi","slug":"raspberry-pi","permalink":"https://naosense.github.io/tags/raspberry-pi/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://naosense.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"电子宠物","slug":"电子宠物","permalink":"https://naosense.github.io/tags/%E7%94%B5%E5%AD%90%E5%AE%A0%E7%89%A9/"},{"name":"samba","slug":"samba","permalink":"https://naosense.github.io/tags/samba/"},{"name":"minidlna","slug":"minidlna","permalink":"https://naosense.github.io/tags/minidlna/"},{"name":"kodi","slug":"kodi","permalink":"https://naosense.github.io/tags/kodi/"}]},{"title":"56. 合并区间","slug":"56-合并区间","date":"2023-08-15T11:32:51.000Z","updated":"2025-09-16T02:08:42.952Z","comments":true,"path":"2023/08/15/56-合并区间/","link":"","permalink":"https://naosense.github.io/2023/08/15/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","excerpt":"","text":"以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 首先我们来看，题目要求一组区间合并后的结果，如何合并取决于两个区间的关系。那两个集合的关系共有几种呢？共四种关系：包含、被包含、有交集、无交集。具体到编码上，如何判断是哪种关系是通过判断区间的上下边界。比如你想判断[1, 3]和[2, 6]的关系，首先是否是包含关系，你得判断2和6是不是都大于等于1小于等于3，发现不是，再判断是否被包含关系，即1和3是否都大于等于2小于等于6，也不是，接着再判断是否有交集，发现是交集的。有交集的就要合并，合并后变为[1, 6]，重复这一过程处理[1, 6]与[8, 10]，直到最后一个区间。 同时可以发现，区间的合并是有顺序性的，比如，如果先合并[1, 3]和[8, 10]，再合并[2, 6]，前两个没有交集，如果你只拿后一个[8, 10]与[2, 6]合并，最后的合并结果还是原来的三个区间，没什么变化。 如果有N个区间，照这种算法，复杂度应该是O(N^2)，所以我们需要对区间进行排序，排序还有一个好处，区间由“左右”两个值确定，如果按照其中一个值已经是排好序的，那判断区间关系的时候，只需要判断剩下的那个边界就可以了。你可能要问了，你怎么想到排序的，你怎么发现这种特点的？我只能说，看答案，哈哈，开句玩笑。其实这就是一种洞察力，如果你不是生而知之者，只能靠练了。 下面开始编码，我们选取下边界进行排序，然后通过判断上边界来确定区间的关系。 class Solution &#123; public int[][] merge(int[][] intervals) &#123; // 按起始位置从低到高排序 Arrays.sort(intervals, (i1, i2) -&gt; i1[0] - i2[0]); List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int[] pre = intervals[0]; for (int i = 1; i &lt; intervals.length; i++) &#123; int[] cur = intervals[i]; // [[1,3],[2,6],[8,10],[15,18]] // 那么分别处理三种情况：无交集、有交集、包含 if (pre[1] &lt; cur[0]) &#123; // 无交集 res.add(pre); pre = cur; &#125; else if (pre[1] &gt;= cur[0] &amp;&amp; pre[1] &lt;= cur[1]) &#123; // 有交集 pre[1] = cur[1]; &#125; else &#123; // 包含 // do nothing &#125; &#125; res.add(pre); return res.toArray(new int[0][0]); &#125; &#125; 可以看到在处理区间关系时，处理了无交集、有交集以及包含关系，如果你还记的上面说过两个区间的关系共有四种，你就会发现少了一个被包含，原因是显而易见的，因为经过了排序，不可能存在这种关系。这样经过一遍循环就可以得到合并后的结果了。 总结一下，这道题有两个关键点：一是要想到两个区间的四种关系，二是使用排序简化整体逻辑。当遭遇O(N^2)复杂度时，排序通常可以作为算法武器库中一个通用兵器尝试一下，虽然它会提高局部的算法复杂度，但如果它能降低整体的算法复杂度，那么排序就是值得的。 对了，还有一个小问题，题目中的区间都是闭区间，如果是开区间怎么办？ 一个简单的办法是如果是“左开”，那么可以在原来的值上面加一，如果是“右开”，那就在原来的值上减一。当然这些区间的值必须是整数，如果是小数，又该怎么办呢？","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://naosense.github.io/tags/leetcode/"},{"name":"hot100","slug":"hot100","permalink":"https://naosense.github.io/tags/hot100/"}]},{"title":"CountDownLatch源码解读","slug":"CountDownLatch源码解读","date":"2023-08-05T10:43:12.000Z","updated":"2025-09-16T02:08:42.958Z","comments":true,"path":"2023/08/05/CountDownLatch源码解读/","link":"","permalink":"https://naosense.github.io/2023/08/05/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"之前写过一篇关于AQS的源码分析的文章，介绍了AQS是Java并发组件的基础，基础的介绍了，我们再看看它的应用，因此从这一篇开始我将依次介绍下AQS在Java各个并发组件如何应用的，先从CountDownLatch开始。 CountDownLatch，有时也叫闭锁，它的作用就像一个大门，初始是关着的，线程在“门外”等候通过，在某一时刻大门打开，线程一起通过，大门打开后一直会保持打开状态，不会再关闭。它用在什么场景呢？一个典型的场景是JVM的warmup，我们都知道JVM刚启动时，由于JIT还没介入，系统的响应是比较慢的，需要发送一些请求让JVM快速“热”起来，即所谓的warmup。这个过程需要确保warmup的请求处理完，才能去接线上的正常请求，这个场景就可以用CountDownLatch来实现。也就是CountDownLatch源码中抽象出的代码示例， class Driver &#123; // ... void main() throws InterruptedException &#123; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); // don't let run yet startSignal.countDown(); // let all threads proceed doSomethingElse(); doneSignal.await(); // wait for all to finish &#125; &#125; class Worker implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; public void run() &#123; try &#123; startSignal.await(); doWork(); doneSignal.countDown(); &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125; void doWork() &#123; ... &#125; &#125; 可以看到上面的源码有两个闭锁，一个用来开始，一个用来结束，N个线程执行某种任务，比如发送warmup请求，startSignal可以确保这些请求一起发送，请求有的响应快，有的响应慢，doneSignal可以确保那些快的慢的一起结束。那么它是怎么做到的呢？我们一起看下源码。 private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c - 1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; &#125; CountDownLatch里有一个Sync类，看懂这个类，其实闭锁的原理就懂了。 还记得之前AQS那篇文章里说： AQS其实就是一个由状态变量和CLH虚拟队列组成的一个基础并发组件，它维护了一套线程阻塞、排队、唤醒的机制。它可以工作在共享和非共享两种模式下，共享模式下允许多个线程一起运行，非共享模式只允许一个线程运行。 count就是这个状态变量，我们知道，AQS的tryAcquireShared如果返回正数表示当前线程可以执行，并且后续其他线程也可以继续执行；如果返回0，表示当前线程可以执行，但是后续线程就好好的待着吧；如果返回负数，连当前线程也不能继续执行了，会进入休眠状态等待唤醒，tryReleaseShared方法如果成功会唤醒休眠中的线程，看起来闭环了。 因为闭锁可能需要唤醒多个线程，因此AQS工作在共享模式下。Sync重写了tryAcquireShared，使得count为0时，大门已开，畅通无阻，当前及后续线程继续执行，否则当前线程进入休眠，等待大门打开的那一刻，同时重写了tryReleaseShared使得下一个count为0时才能唤醒休眠的线程，也就是唤醒只发生在count从1到0发生变化的那一刻，在这之前和在这之后都不会唤醒线程，在这之前是count还没数到0，大门是关闭的，在这之后是count已经数到0了，大门已经开了，并且一直是打开的，不会关闭。 下面是CountDownLatch的两个核心方法await（一个不带超时，一个带超时）和countDown，前者用来拦住某些线程，后者倒计时控制闭锁打开，里面的核心就是上面介绍的两个方法，不再赘述。 public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; public void countDown() &#123; sync.releaseShared(1); &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://naosense.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"juc","slug":"juc","permalink":"https://naosense.github.io/tags/juc/"}]},{"title":"共和国战争-抗美援朝（四）","slug":"共和国战争-抗美援朝（四）","date":"2023-06-22T14:36:39.000Z","updated":"2025-09-16T02:08:42.968Z","comments":true,"path":"2023/06/22/共和国战争-抗美援朝（四）/","link":"","permalink":"https://naosense.github.io/2023/06/22/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E6%8A%97%E7%BE%8E%E6%8F%B4%E6%9C%9D%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"战俘营 当我们编辑这组资料时，心情十分沉重。战后40年，这些镜头可能是第一次出现在我国的纪录影片中。这就是志愿军战俘的镜头。朝鲜战争期间，志愿军有2万余人被俘，是美军实际战俘数的6倍。其中被俘数量最大的一次是在第五次战役中，60军180师回撤失利，约有5000人被俘。中国被俘人员中，职务最高的就是该师的代理政委兼政治部主任。毋庸置疑，志愿军战俘中有一部分是主动投敌分子，但大部分还是掉队的伤员和在战斗中被敌人抓获的。这是美军当时拍摄的作为宣传的资料镜头。 志愿军战士被俘后，被美军押解到釜山以西8公里的收容所。在收容所里，战俘被登记照相，被发给一个铁牌编号，换上一套美军旧军服，后背用油漆印着PW两个缩写的英文字母，意思是战俘。美军把战俘中的投诚人员挑出来担任各级战俘官，他们可以任意虐待其他战俘。收容所名义上是关押伤病战俘和向外岛转运战俘的。这里把战俘按伤病、女战俘和转运战俘分别关押。伤病员战俘和女俘被留下来关押。其他战俘用船运到朝鲜东南沿海的巨济岛关进战俘营。美第8集团军后勤部和宪兵司令部共同负责战俘营的管理。美国远东军事情报局、远东民众心理调查局负责审讯。同时，所谓的美国远东民众教育馆和宗教系统负责对战俘进行教育。 在巨济岛上，美军沿海修建了12个战俘营，称为12支联队。志愿军战俘被关押在72和86两支联队里，共计1万多人。连队下设大队、中队和小队，大队以上设有警备队。在用5层铁丝网围起来的管理区里，每50名战俘住在一顶帐篷里，每两名战俘睡一张草席，每个战俘盖一条旧军毯。冬天，每10名战俘发7件旧大衣。每个战俘每天的口粮规定是一磅相当于9两。每顿饭70%是带壳的大麦， 30%是碎米。50人分一桶罐头，每5天供应一次开水。 板门店谈判陷于停顿期间，1952年的1月至4月，美方宣布对中国和北朝鲜的战俘实行甄别审查。所谓甄别，就是按美国自愿遣返的原则，把愿意回国和拒绝回国的两类人甄别区分。这种甄别在志愿军战俘营是怎样进行的？据亲历者战后的回忆，每个中队为一个会场，战俘们列队伍，由俘虏官当场宣布愿意回大陆的站到一边。很多人被打怕了，不敢站出来。少数坚决要求回国的站出来以后马上被单独关押起来，当晚就遭到警备队的残酷毒打，有的甚至被当场挖出心脏杀一儆百，随后又被强行刺字，前胸和后背刺满了反共口号。 这种残酷的甄别同时也在北朝鲜军队的战俘营中进行着。以至于发生了这样一件震动世界的事件。5月7日，巨济岛战俘营总管、美军准将杜德被北朝鲜战俘扣作人质。13:30事件发生后，美军警卫部队立即处于高度戒备状态，一场大屠杀随时可能发生。同时，美军命令驻釜山的部第9团和第64中型坦克连向巨济岛增援。 下午5点的时候，被扣押的杜德写了一份手令传给战俘营管理局，说：“为防止事态扩大和保证我的安全，我命令绝对禁止开枪，并同意立即召开全岛朝中战俘代表大会。”美军当局只好于当晚用吉普车把各战俘连队的代表送往扣留杜德的北朝鲜第76连队。第二天，5月8日，第9步兵团乘登陆艇登上了巨济岛，同时美海军舰艇包围了该岛。釜山基地空军的飞机也处于高度戒备状态。而就在这个同时，中朝战俘的代表43人在76联队里召开了代表大会，控诉美军迫害战俘的罪行，杜德在场不住的点头。第三天，5月9日，新成立的战俘代表团起草了一份中朝战俘代表大会向全世界人民的控诉书，提出四项条件，其中第一条就是立即停止对在武力之下处于被奴役地位的战俘进行强迫性的甄别。就在这一天，美军调来的第64中型坦克营B连已登上了巨济岛。同时，美军宣布撤销了杜德的职务，接替他的是科尔森准将。新的战俘营总管发出了最后通牒，要求战俘次日继5月10日晚10点以前释放杜德，否则即发起进攻。5月10日，第8集团军司令范佛里特乘飞机赶到了巨济岛。这天早晨，美军的20辆坦克及各种火炮都已进入了阵地，面对手无寸铁的战俘，摆出一幅正规作战的架势。10点前，科尔森与杜德在电话中最后话别。 现在看到的这个镜头是美军在战俘营中镇压战俘的真实记录。杜德于5月10日晚8:30被释放，释放前，他承认了在甄别中采用暴力逼迫战俘的罪行，并与接替他职务的科尔森共同签署了一份答复中朝战俘要求的书面复函。摘引如下：一、关于你方信中的第一项，我承认发生过流血事件。在这些事件中，联合国军使许多战俘伤亡。我承诺今后按国际法原则给战俘以人道待遇。今后我将尽最大努力防止发生暴力和流血事件。二、第二项，自愿遣返问题正在板门店讨论，我无权左右谈判的决定。三、关于第三条强迫甄别问题，只要杜德将军获释，我保证不再进行强迫审查。杜德事件后，刚上任的科尔森也很快被解职，接替他的是波特纳准将。10天后，即5月20日，他指挥了一场大规模的报复性屠杀，当场打死打伤中朝战俘86人。这是当时美军记者在现场拍摄的影片资料，一直被列为机密档案，战后封存了30年。 4个月以后，10月8日，陷于战俘问题困境的美国在板门店宣布无限期休会，谈判又一度中断。在这个特殊的战场上，中国和北朝鲜战俘用血肉之躯的代价赢得了胜利。战争结束后，回到祖国的志愿军战俘仅6673人，其余14235人去了台湾，12人去了印度，回来的人，党员全部被开除了党籍，直到30年后才得以反正。 1952年是美国第34届总统换届之年，入夏以后，美国驻欧洲盟军司令艾森豪威尔作为共和党候选人回国参加竞选。按照美国宪法，他辞去了军职，白宫随即调任李奇微前往欧洲接替空职，同时委任克拉克接替远东司令的职缺。艾森豪威尔回国竞选的时候，朝鲜战场换上了第三位美军指挥官。 克拉克6月到任，作为民主党的杜鲁门切望他能在前线打个胜仗，给执政的民主党制造点竞选声势。克拉克到任后，亲自携大批参谋人员视察了前线，深感在横贯朝鲜半岛宽达200公里的整条战线上，几乎无法在某一点上有所突破。中国军队在停战谈判谈谈打打的一年中，在纵深阵地上挖掘了犬牙交错的地下坑道，并囤积了大批粮食和弹药，以逸待劳，立足于长期坚持。这时，新上任的克拉克已经体味到了同为军人的中国对手彭德怀一年前的感受。 朝鲜战争已经到了打政治的时候，美国的政治需要克拉克在朝鲜打一个漂亮仗。这时，第8集团军司令范弗里特向克拉克建议，在金化以北、武圣山南路的两个山头打一下，战线能局部推进1100米。动用的部队是美军一个师和南朝鲜一个师，并由16个炮兵营的280门火炮和200架战斗轰炸机给予支援，估计战斗5天内就可以结束，这样美军可以在不付出过大牺牲的情况下攻取敌方的一些阵地，从而在美国国内炫耀朝鲜战场的胜利之势。 于是，10月8日，克拉克指令美国代表在板门店宣布无限期休会。当天晚上他就批准了这一代号为“摊牌”的作战计划。这时中国军队已经很清楚了，停战谈判的休会与开会已是美军军事行动的晴雨表。果然，6天以后，美军向范佛里特亲自勘察选定的叫上甘岭的两个高地投下了第一排炮弹。从10月12日起，美军预先以航空兵炮兵对中国军队武胜山及上甘岭的 597.9 高地和 537.7 高地北山阵地实施的连续两天的火力突击。 从14日3时起，美军又进行了持续达两个小时的猛烈的炮火准备，接着于5时以美第7师、南朝鲜军第2师各一部共7个营的兵力，在300多门105毫米以上口径火炮、30余辆坦克、40余架飞机的支援下，分六路向志愿军597.9高地和537.7高地、北山两阵地发起猛攻。 美军以成营的兵力采取多路多拨的方式，进行了连续不断的冲击，对面积仅有3.7平方公里的两高地发射炮弹30余万发，投掷炸弹500余枚，志愿军军阵地平均每秒钟落弹5至6发，战斗异常激烈。中国防守部队是志愿军两个加强连，在仅有山、野、榴炮15门和82迫击炮12门支援作战的情况下，进行了顽强的抗击。打了8个多小时后，志愿军的表面阵地攻势几乎全部被摧毁，人员伤亡很大。美军连续发起冲锋，志愿军表面阵地大部分被美军占领，志愿军防守部队只能转入坑道作战。19时，志愿军趁敌立足未稳，组织4个连实时反击，又恢复了表面阵地。面对将孤注一掷的美军，志愿军清醒地意识到，面临的将是一场少有的恶战，他们提出了“人在阵地在，绝不让阵地丢半分”的口号。 这一天，志愿军毙伤美军近2000人。14日晚，志愿军调整了部署，将两个炮兵营调至上甘岭地区，以第134团的两个营和133团一个营，分别加入597.9高地和537.7高地北山防御。15日至18日，美军先后投入了两个团4个营的兵力，在大量炮兵、航空兵支援下，向597.9高地和537.7高地北山进行连续的猛烈进攻，志愿军防守部队与美军反复争夺，至18日，志愿军两高地的表面阵地全部被美军占领。19日晚，志愿军第45师分别以3个连的兵力一举夺回了阵地。20日，美军又以两个营的兵力占领了表面阵地。10月20日，志愿军第3兵团决定将第12军调往武圣山地区作为战役预备队，以第15军第29师接替第45师除597.9高地和537.7高地北山以外的全部防务，以使第45师以一个整师的力量用于两高地的争夺战。另外将炮兵第71个营、炮兵第24个连和高射炮兵一个团加强给第15军，同时还给第45师补充了1200余名新兵。 10月29日，中国军队实施决定性反击的准备工作就绪，并进行了两天的预先火力准备，将被美军占领的表面阵地攻势基本摧毁。30日21时，志愿军第15军以第45师5个连、第29师两个连与坚守坑道的部队相互配合，在山、野、榴炮50门、火箭炮24门、迫击炮30门的支援下，开始对597.9高地的美军实施反击。志愿军坚守坑道的3个连首先对美军发起冲击，接着坑道外的志愿军7个连迅即投入战斗，对美军两面夹击，经过5个小时激战，全歼了美军4个连，并打退了美军一个营兵力的多次反扑。至31日夜晚， 597.9高地阵地被中国军队收复。11月2日，美军自7时起又对志愿军阵地实施猛烈炮击，达4小时之久。12时至18时，美军集中兵力向志愿军597.9高地攻击40余次，曾一度突入志愿军阵地。11月5日，志愿军第3兵团将第12军第31师的三个团全部投入了两高地的作战。 11月6日，志愿军总部向北京的中央军委报道，坚决与美军争夺下去的决心和部署。7日，军委复电同意并指出此次武圣山附近的作战已发展成为战役的规模，望坚决作战，争取全胜。中国军队收复597.9高地以后，随即投入反击537.7高地北山美军的准备。至11月10日，美军全部占领了537.7高地的表面阵地。11月11日16:25，志愿军第31师第92团两个连在山、野、榴炮70门、迫击炮20门和火箭炮24门的直接支援下，分两路发起冲击，激战至17时夺回了537.7高地，北山阵地全歼美军一个营。在上甘岭长达43个昼夜的攻防争夺战中，志愿军最终守住了阵地，取得了胜利。 朝鲜半岛上的战争先是军事上陷入了僵持，而后又在谈判上陷入了僵持。当美国手上的两把牌都打死了的时候，又开始重打联合国这张牌。 在朝鲜刚刚打响内战的第一天，联合国就决议北朝鲜事侵略16个国家，组成联合国军，越过三八线。联合国却决议是为了统一中国出兵。恰逢第五届联大，联合国决议污蔑中国为侵略者。第六届联大时，美国甄别战俘闹得沸沸扬扬，联合国却决议规避讨论朝鲜问题。第七届联大开幕时已近1952年年末，横尸遍野的战争已经进行了两年零四个月，美国携英法21国首先提出一个提案，中心内容是要求中国和北朝鲜接受战俘的自愿遣返原则。5天以后，苏联也提出一个提案，中心内容是首先停火，停止流血，把战俘遣返问题单独剔出来，交给一个由直接有关国家和其他国家参加的委员会去解决。正当这两个提案相持不下的时候，印度又冒了出来，提出一个提案。它的中心内容是由四个中立国组成一个遣返委员会，并公推一个国家为公断人，遇到不能解决的问题时，由公断人裁决。停火后90天，尚未遣返的战俘由高一级政治会议解决。30天后，仍没有解决的战俘交联合国收养。美国最后同意印度这个提案，中国和北朝鲜声明同意苏联提案。12月3日，联合国大会以53票赞成、5票反对通过了印度提案。 事实上，朝鲜半岛的战争，没有中国和北朝鲜同意的任何方案，都是事实上无效的方案。当1952年即将过去的时候，朝鲜的问题已经全部僵死在朝鲜半岛上。在一条基本沿三八线走向的战线上，战线以北的前沿地区，西段中国军队押了8个野战军，约为27万人。东段北朝鲜押了3个军团，约为83000人。战线以南的前沿地区，美军押了4个满员陆军师，一个海军陆战师。南朝鲜押了4个战斗师，总计兵力达到247000人。 在北方纵深地区，中国军队押了42万兵力，北朝鲜压了185000预备兵力，同样在南方纵深地带，联合国军也压着617000后备力量。这样隔着一条战线，在这条狭长的半岛上，中国北朝鲜一方共计有958000的兵力，日夜枕戈待旦。美国南朝鲜一方总计864000兵员，每天都在消耗着从800海里以外的美国本土远远运来的巨额战争物资。而这一切都卡死在一件事情上，那就是美国抓住的大批战俘说他们不愿意回到共产党国家去。朝鲜战争的战争实质最终显露了出来，它不是领土争端，不是民族纠纷，而是第二次世界大战后战争状态所出现的一种新的表征，即为意识形态而战。 在美国，竞选总统的艾森豪威尔做了一个公开的许诺，他说，如果他当总统，他将亲自前往朝鲜并结束这场战争。这个演说打动了大多数美国人的心，人们寄希望于这个曾率领过100万大军在法国诺曼底登陆的二战名将，能够最终把美国从朝鲜战争的泥潭中拯救出来。 大选揭晓的当天，像卸了包袱的杜鲁门对新当选的总统发出贺电，说：“如果你仍打算去朝鲜，总统的座机独立号将随时听从您的调遣。”这时，当选总统不到一个月的艾森豪威尔已经带着他内定的国防部长、司法部长乘一架军用运输机飞往朝鲜。与此同时，美军参联会主席布莱德雷从美国本土太平洋舰队司令雷德福、从太平洋硫磺岛远东司令克拉克和驻朝第8集团军军长范佛里特从日本东京纷纷赶到汉城，加入新总统的视察行列。已经打成残垣断壁的朝鲜从没有来过这么多美国要员。李承晚趁机在汉城组织了几次大规模的群众游行，为的是让美国新总统亲眼看到南朝鲜统一全朝鲜的决心志在必得。 李承晚亲自陪着艾森豪威尔走遍前线，在一个前沿阵地的观察所里，这位昔日的五星上将端着望远镜，一言不发地向对方阵地足足看了20分钟。所有陪同人员都望着他，他最后说了一句，“看来任何进攻都将是非常困难”。三天以后，艾森豪威尔一行人在乘军舰回国途中，路过威克岛，讨论新政府面临的种种问题。他组阁新班子的人马已陆续赶来，其中就有内定的新国务卿杜勒斯，这个杜勒斯就是朝鲜战争打响的前七天，在三八线上向北窥望的那个杜勒斯。这个威克岛就是两年前麦克阿瑟向杜鲁门保证在感恩节结束战争的那个威克岛，今天还是在这个岛上。杜鲁门之后的艾森豪威尔和他的新政府班子讨论的仍是他前任总统的老问题：如何结束朝鲜的这场战争。 1953年1月20日，艾森豪威尔正式就任第34届美国总统。他在发表就职演说时讲了一段使他的选民深感遗憾的话。他说：“我们早已知道没有什么简单的办法能迅速而胜利的结束朝鲜战争，但是通过亲临现场的了解，至少使我对我们面临的艰巨任务有所准备。” 据战后资料披露，艾森豪威尔讲的有所准备，就是他在威克岛时与他的同僚们研究了多少天的朝鲜方案。他秘密指示参联会尽快拟定一个攻势计划。这项计划包括把蒋介石的地面部队拉进朝鲜战场的问题，包括对中国本土实行全面轰炸的问题，甚至于包括在战术上使用原子弹的问题。从战后解密的美国陆军档案资料中，历史学家证明了一条美国从未公开承认过的密文。 1950年10月以后，当中国军队从鸭绿江畔向三八线快速推进的时候，麦克阿瑟曾向参联会提交过一份名为“迟滞目标”的作战方案。在这个计划中，美国准备使用原子弹，其中4枚轰炸进攻部队，另4枚袭击敌后方重要集结地。同年12月，未装配好的原子弹已经悄悄运到一艘停泊在朝鲜半岛附近海面的航空母舰上，从舰上起飞的飞机还对平壤进行过模拟核袭击。只是后来战局的发展，美军在三八线以南稳住了阵脚，该计划才未最后实施。 1953年，艾森豪威尔上台，又一次秘密准备使用原子弹。从解密的档案材料看，美军参联会对原子弹的使用已经讨论到非常详细的地步，甚至于谈到对付地面部队将是个什么效果。于是美国专门进行了这么一次核试验，用美国士兵做活的试验物，在原子弹爆炸中心11公里以外，检测原子弹爆炸时的各种杀伤及危害的数据。这是实验时的真实镜头，这也是当时真实的镜头。美国联邦调查局逮捕了把原子弹试验核心机密泄露给苏联的两名间谍。三个月后，他们被送上了电影。 艾森豪威尔正式步入白宫的第十天。2月2日，他发表了第一个国情咨文，他宣布解除台湾中立化的地位。美国的外交措辞总是反着说，他鼓动蒋介石进攻大陆。艾森豪威尔说成是“我现在下令第七舰队不再用来保卫共产党中国”。美国舆论把艾森豪威尔这一举措称为“放蒋出笼”。同时，美国开始介入印度、法国军队不堪支撑的越南、老挝和柬埔寨，意在从中国的东南沿海压迫中国收缩在朝鲜的实力。 世界舆论这时已经注意到军人出身的艾森豪威尔一上台就全面突破了他的前任文职出身的杜鲁门把朝鲜战争陷于局部战争的基本国策，艾森豪威尔不但要把朝鲜的战火扩大到台湾，同时也扩大到东南亚，这同时也是美国以后的旷久20年的越南战争的开始，这是当时美国首批陆战队员为援助法军进入越南时的资料镜头，这时美国的主要盟国英国和法国分别陷入了各自的危机，埃及摆脱英国的独立愿望和阿尔及利亚摆脱法国的殖民统治，使英法自顾不暇之中，无力听复美国在远东再把朝鲜战争扩大化。在这一年的英国大选中，丘吉尔重新上台，在第二次世界大战诺曼底登陆时，他和当时的美国总统罗斯福共同领导过艾森豪威尔。这时他以一个老牌政治家的口气明确表示：“英国反对放蒋出笼，致使朝鲜战争升级。”这是当年埃及发生暴乱被英军镇压时的历史镜头。 第二次世界大战后，特别是进入50年代后，民族独立和民族解放运动已成为一种趋势。英美法几个老牌帝国主义国家，在这种国际大事面前，已不能为所欲为的、按它们的设计和构想来安排世界。朝鲜战争似乎给全世界一种明示，帝国主义不是不可反抗的，不是不可战胜的。这是那个时期阿尔及利亚争取民族独立反抗法军镇压时的历史镜头。 在这种国际背景下，周恩来指示在朝鲜板门店的中国谈判代表团写一份详细的分析报告，速报中央。12月19日，中国代表团向中央提出如下建议：“如果我方正式在板门店通知对方无条件赴会，美国态度将是拒绝的居多。如我方以金日成彭德怀致函形式，对方可能认为我方性急，有些示弱，反易引起对方幻想。结论是，一动不如一静，让现状拖下去，拖到美国愿意回到谈判桌上。”毛泽东和周恩来当即批复同意这一建议，决定拖。 现在的镜头是北大西洋公约组织在里斯本开会的情景。西欧各国呼吁美国要看到欧洲面临的危机，尽快结束朝鲜战争。艾森豪威尔如何180度大转弯下这个台阶，他的国务卿杜勒斯向他进言，建议借用国际红十字会来说话。上台一个月就陷入进退维谷的艾森豪威尔，这时不得不与英法主要盟国首脑重新研究世界战略格局，最后还是听取了英法的意见。这时，在美国国内，刚刚下台的民主党正在对刚刚执政的共和党的冒险国策进行激烈抨击。2月22日，美国驻远东司令遵总统指令，给金日成、彭德怀发出一封信函，建议按国际红十字会的建议先行交换病伤战俘。美国宣布无限期休会4个月零两个星期之后。这无疑是在传递一个重要信号。 据战后资料披露，1951年至52年，以至53年停战谈判拖而不决。中国最高决策层以现实主义态度，已准备给美国一个梯子，做点妥协，希望尽快结束从建国第一年起，就拖耗着新中国建设的这场朝鲜战争。但斯大林不同意，原因是显而易见的。当美国放出空气有意回到板门店的第16天，一个对东西方而言都是惊人的消息在一天之内传遍世界，斯大林逝世了。 3月8日到17日，周恩来率中国党政代表团在莫斯科参加这位国际共产主义领袖为期10天的葬礼。紧接着，3月17日至20日，周恩来又率同一个代表团前往布拉格，参加捷克斯洛伐克共产党主席戈特瓦尔德的葬礼。这一下拖出去了一个月。但很显然，在葬礼期间，中国、苏联、北朝鲜三国的党和国家领导人就朝鲜问题进行了洽商。从3月28日起，三国开始采取一个一致的新的重大步骤，而这时，中国事实上已经可以很大程度上以自己的意愿来处理国际事务。3月28日，美军远东司令克拉克的信发出。一个月后，金日成、彭德怀附近同意交换病伤战俘。 两天以后，3月30日，周恩来发表声明说，中国政府主张朝鲜人民军和中国志愿军的停战谈判，代表应立即与联合国军的停战谈判代表开始关于在战争期间先行交换病伤战俘的谈判，并进而谋取战俘问题的通盘解决。一天以后，3月31日，金日成发表声明，他说：“热烈支持周恩来提出的新建议。”第二天，4月1日，苏联外交部长莫洛托夫发表声明：“支持周恩来和金日成的声明。” 苏联发表声明的第五天，4月6日，设在板门店相隔不足100米的谈判双方的两个电台在例行开机通话时间里，中方收到美方一个电文，电文说美方联络组组长、海军少将丹尼尔已经到达板门店。僵局终于打开，中国和北朝鲜方的联络组长随即进入会场区。这次谈判进展的很顺利。5天以后，4月11日，双方联络组签订了遣返病伤战俘的协定。7天以后，4月18日，第七届联大又不失时机的通过了一项希望病伤战俘交换迅速完成的决议。4月26日，中断了6个月零18天的和平谈判，正式赴会。这时艾森豪威尔收到李承晚一封抗议信，信中说：“大韩民国有理由要求除了那些愿意参加把敌人驱逐到鸭绿江以北的国家外，所有的盟国都离开这个国家。”同时，台湾蒋介石也写信给艾森豪威尔，对他说：“谈判应有个时限，超过了时限就应大打。”然而，这时，交换病伤战俘的工作已经开始，通盘解决战俘问题的谈判也已经开始。4月14日，中方按规定提前一周用23辆卡车载着首批联合国军病伤战俘离开北朝鲜战俘营，前往板门店集体交换。 在同一时刻，中国和北朝鲜的病伤战俘也从南朝鲜的巨济岛运至釜山。5天之后，他们被送上火车，从釜山前往文山等待交换。按双方签约规定，中朝方每天送交100名，美方每天送交500名。互相交换，中朝方总计要换回700名中国人和5100名北朝鲜人。美方总计要换回150名联合国军人员和450名南朝鲜人。 4月20日，交换正式开始，美方把这次交换定名为“小开关行动”。小开关行动按每组30人根据事先互换的花名册逐批交换。当交换进行到第三天的时候，美方突然发现从釜山运到板门店的中朝方人员超过了原计划要交换的5800名，多出550名。情况报告给东京的克拉克，克拉克最后决定多出的人员也一并遣返。 这是北朝鲜战俘回到北方国土时激动人心的画面，战地记者及时的把它抓拍了下来。当美军把多出的战俘移交给北朝鲜后，北朝鲜曾表示他们交还的战俘也将超过原定的600人这个数字，于是美国人连夜又在花名册中增加了一批北朝鲜战俘，想借此多换回一些美军战俘。但是三天以后，4月26日，北朝鲜在多交还了84名南朝鲜人之后，立即宣布病伤战俘交换完毕，没有多交换一名美军战俘。5月3日，美方也扣住最后一批已列入遣返名单的中朝伤病战俘，宣布完成了遣返工作。 这次交换最后统计的数字是，中朝方共移交给美方684名伤病战俘，其中94人是躺在担架上的。美方移交给中朝方战俘总数是6670名，其中中国战俘1030名，多出330名。北朝鲜战俘5640名，多处出540名。在这些战俘中，用单架抬过板门店分界线的有357名。 在这次交换中，有两名在战争开始的第一周就被北朝鲜扣留的英国外交官，也由北朝鲜移交给联合国，这是他们被扣留三年后回到伦敦述职时的情景。 最后一战 板门店停战谈判恢复以后，随着伤、病战俘交换的进行，中国对全面解决战俘问题，提出了一个新的“六点方案”。这六点方案是：一、在停战协定生效之后两个月内，双方应遣返所有愿意回国的战俘。二、在第三个月内，应将所有不愿回国的战俘送到一个中立国看管。三、对不愿回国的战俘，其所属国派人进行6个月的解释工作。四、在解释之后要求遣返的，应给予遣返。五、6个月解释期结束后，仍在中立国看管的战俘，将由停战会议中所规定的政治会议决定。六、不愿的战俘在中立国的费用将由其所属国承担。这六点建议实际上是给美国一个下台阶的梯子。事实上，与七届联大美国同意的印度方案已经很接近。美国说不出什么话来，只是提出6个月的解释期太长，而且战俘没有必要移送国外，中立国可以在朝鲜接管看守工作。这时，中国又做了一次让步，同意把解释期从6个月减为3个月。同时同意波兰、捷克、瑞士、瑞典和印度5个中立国在朝鲜本土接管对不愿回国的战俘的看守工作。5月23日，在美国华盛顿，艾森豪威尔主持召开了国家安全会议，内定同意这个方案。 朝鲜和平已经在望，美国大兵早想回家了。从1950年6月到1953年4月，整整三年中，战线从三八线向南推到釜山，又从釜山向北推到鸭绿江畔，最后仍旧稳定在三八线附近。对于中国的停战方案，南朝鲜的李承晚不能忍耐美国的态度，他勃然大怒地叫嚣：“我们将自己单独行动，我将领导这场战争继续打下去，一直打到鸭绿江。”5月23日，美国白宫密电远东司令克拉克，指示他在5月25日上午10点，也就是在板门店开会前一个小时，再去当面通知李承晚，告诉他美国准备同意中国的这个停战方案。两周之后，6月18日，美国不顾李承晚的明确反对，在板门店签订了唯一障碍停战达成协议的关于战俘问题的文件。李承晚大为光火，南朝鲜政府在南朝鲜各地接连几天发动反对停战的游行示威，群情激昂，大有丧权辱国之感。这使急于结束朝鲜战争的美国人大为恼火。据战后美军解密的机要档案披露，第8集团军曾奉命制定过一个永远准备着的行动计划。该计划拟定，一旦李承晚再干扰美国的谈判行动，美国将在汉城拘捕他，并马上对南朝鲜实行全面军事管制。 十天以后，一个意外的事件终于发生了，它几乎是朝鲜战争再次升级。6月18日，李承晚命令在釜山的南朝鲜看守部队打开战俘营，以就地释放的名义，把27000名北朝鲜不愿遣返的战俘直接编入了南朝鲜军队。事件发生时，已回国任职的彭德怀正从国内前往三八线上的开城，准备参加停战协定的签字仪式。经过平壤时，一封毛泽东的加急电报追上了他。电报告知，停战协定的签字必须推迟，推迟至何时为适宜，要看情况发展才能决定。再歼灭伪军万余名极为必要。6月21日，李承晚事件的第三天，志愿军总部决定在金城地区组织一个惩罚南朝鲜军的战役。这次战役，志愿军集中了1:3的绝对优势兵力和1:1.7的优势炮火，同时调动2000辆卡车，保证70万发炮弹的供应，对当面的南朝鲜首都师和第4、第6、第8四个师集中打击。 在中国军队组织金城战役的同时，西方各国也对李承晚进行谴责。英国首相丘吉尔在遭到下院严厉质问的情况下，不得不公开宣读英国致李承晚的抗议照会。照会称，“女王政府强烈谴责这种背叛行为”。艾森豪威尔也在给李承晚的信中严厉警告他：“要是你坚持目前的行动方针，就无法使联合国军继续同你一致行动。”据战后资料披露，从6月18日李承晚事件出现后，在近一个月的时间里，克拉克几次到南朝鲜总统府亲手转交艾森豪威尔的亲笔信件，李承晚都拒绝合作，美国已经着手准备实施永远准备着的方案。这时，金城战役打响了。 7月13日21时，浓云密布，大雨欲来。中国军队出乎意料突然发起进攻。志愿军第20兵团各部及第9兵团、第24军在1000余门火炮支援下，经过火力准备，同时向美军展开了猛烈突击，1个小时内即全部突破美军的前沿阵地。至14日佛晓，志愿军在进攻正面的西段和中段，突破敌军基本阵地。美军为堵缺口，急调第3师和空降第187团，增强金化以东地区的防御，并向志愿军新战阵地反扑。至17时，志愿军占领了金城川以北地区，战线向南推进了9.5公里。鉴于战役第一步发展顺利，志愿军电令第20兵团以其主力控制限战领先，迅速构筑工事，修通道路，抢运物资弹药，推进炮兵阵地，准备抵御美军反扑。 这时，美军战役预备队南朝鲜第11师及第7师已调进战场，志愿军正面已有9个师的兵力准备反攻，企图夺回已失去的阵地，志愿军第20兵团鉴于雨季道路泥泞，供应保证困难，金城川桥梁全部被美军飞机炸毁，情况不利，为争取主动，于当夜全部撤到金城川以北转入防御。这次进攻作战，中国军队收复失地148公里，毙伤俘美军78000人，取得了辉煌的战果。 停战 7月27日一清早，200多名各国记者云集在板门店。这一天，全世界关注的朝鲜战争将在这里签字停战，以结束这个半岛打了三年一个月零两天的一场没有胜负的战争。上午9点，双方代表团从两个方向上同时到达板门店。签字的会场是一座用板和油毡搭的朝鲜风格的飞檐斗拱的大厅，这是100名中国工人在当天凌晨用了7个小时搭起来的。9:30，中国志愿军、美军、北朝鲜和南朝鲜军的8名负责警卫的军官首先进入大厅，在大厅的四个角相互对峙的站立着。随后，双方代表分别从东西两门同时进入大厅。 10点整，大厅里一片寂静，双方代表相互为打一声招呼，就开始在18本用中、朝、英三种文字书写的协定书上签字。代表中国和北朝鲜签字的是北朝鲜人民军总参谋长南日大将，代表联合国军签字的是美国陆军中将哈里森。签字仪式据悉，美国远东司令克拉克对记者说：“我在执行政府的训令中获得一项不值得羡慕的荣誉，那就是我成了美国历史上第一位签订没有胜利的停战条款的司令官。”这是朝鲜停战时的分界线。当天下午3点，美军远东司令克拉克在文山签字，联合国方的文件随即生效。当晚10点，金日成在平壤签字，彭德怀在开城签字。在他们签字时，朝鲜半岛上已听不到一声枪响。停战后，彭德怀回国出任国防部长，1956年授予元帅军衔。1958年，在停战协定签字5周年之后，中国人民志愿军全部撤离了朝鲜。这就是中华人民共和国建国9周年国庆时的情景。这是彭德怀身为国防部长时的最后一个历史镜头。七个月之后，在庐山会议上，他被撤销了一切职务，十年之后死于磨难。但是，彭德怀指挥的抗美援朝战争，给中华民族永远留下一句震撼人心的话。他说：“任何帝国主义在中国家门口架上一门火炮就能吓唬住中国人的时代，已经一去不复返了。” 中国的百年屈辱，中国的百年沧桑，终于随着20世纪50年代这场援外御敌的战争而重换中国的面目，重改中国的形象，中国人民为此付出了血的代价。 在抗美援朝战争中，总人数累积达300万的中国人民志愿军，有36万人牺牲、误伤和失踪，有15万烈士的遗骨永远埋藏在了朝鲜三千里江山的青谷之中。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-抗美援朝（三）","slug":"共和国战争-抗美援朝（三）","date":"2023-06-18T11:06:26.000Z","updated":"2025-09-16T02:08:42.967Z","comments":true,"path":"2023/06/18/共和国战争-抗美援朝（三）/","link":"","permalink":"https://naosense.github.io/2023/06/18/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E6%8A%97%E7%BE%8E%E6%8F%B4%E6%9C%9D%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"除夕攻势 以10月25日计算，志愿军出国作战整整两个月，26万志愿军把42万联合国军从鸭绿江边一直推过了整整半个朝鲜。溃败的美第8集团军，终于在三八线以南收住了脚。这是他的司令官沃克中将在他生命最后一天的最后一个镜头。12月23日，他乘坐的吉普车在拥挤的公路上夺路抢行时翻车身亡。 三天后，他的遗体被运回美国。这一天正是圣诞。一个月前，麦克阿瑟曾当面向沃克讲过，“圣诞节就可以结束战争，回美国过年了”。经麦克阿瑟推荐，杜鲁门任命陆军副参谋长李奇微接替驻朝第八集团军司令官，李奇微当晚即飞离华盛顿，圣诞节的午夜抵达日本东京。 次日凌晨，这位欧洲战争的名将身穿一套陆战军服，胸前挂着两颗手榴弹，直飞朝鲜三八线前线。战后他在回忆录中说：“我当时见到的是一支张皇失措的军队，这时中国军队已在三八线以北地区向前沿移动，又一场大战即将来临。”面对中国军队强大的攻势，李奇微却着手制定一项进攻计划，当时他的参谋人员都感到疑虑重重。事后证明，正是李奇薇这种进攻意识所确定的美军的“磁性战术”，才使彭德怀感到遇到了一名真正的对手。 1950年最后的几天即将过去，这时的朝鲜三八线战区，迷茫的风雪中蕴藏着一种杀机。 1950年12月31日17时，中国军队按照预定计划，经过短促的炮火准备之后，全线发起进攻，并迅速的突破了美军在三八线预设的防御阵地。志愿军右纵队第39军在炮兵支援下，其主力1月1日佛晓前突入美军防御纵深约10公里。第38军在炮兵支援下，于进攻发起后一小时突破敌人阵地，至1日12时突入美军防御纵深20公里。第40军第119师在炮兵支援下，于进攻发起一个半小时后突破临荆江，至1日佛晓前突入美军防御纵深12公里。至此美军第一道防线已全面崩溃，特别是其右翼已经完全暴露，美军恐中国军队从其暴露的右翼实施深远的迂回包围，使其10多万军队拥挤在汉江北岸背水作战而陷于危险境地，被迫于1月2日开始实施全线撤退，只以一部兵力在汉城以北进行掩护。 志愿军左纵队第42军在炮兵支援下，于进攻发起一小时20分钟后突破美军阵地，继续发展进攻，沿途打破了美军10余次阻击。第66军主力于进攻发起了3小时突破敌人阵地，会同第42军歼灭了该地区的南朝鲜第20、第31、第32团和第5师的第36团以及炮兵第24营，缴获加农炮、榴弹炮等30余门，俘虏700余人。 美军在中国军队的猛力攻击下异常恐慌，被迫于3日15时开始自汉城撤退。李奇微亲临汉江大桥桥头指挥，他为了保证其第8集团军能迅速撤退下达命令：“如果南朝鲜难民争夺汉江大桥，影响其撤退行动，就开枪射击。”4日，志愿军第50军和第39军各一个师和朝鲜人民军第一军团一部攻占汉城。战斗至1月8日，中国军队将美军驱逐到北纬37度线附近。鉴于中国军队在进攻中并未能大量歼灭美军有生力量，美军有计划的实时撤退，企图诱中国军队深入，而后在其侧后实时登陆，对中国军队进行夹击，彭德怀果断决定停止追击。 第三次战役是中国军队对愈有防御准备的美军进行的一次较大规模的进攻战役。经过7昼夜的连续进攻，中国军队突破了美军在三八线的防御，歼灭美军19000余人，收复了汉城。当时中国军队已连续进行了两次战役，部队相当疲劳，再加上战线南移，供应更加困难。毛泽东依据当时形势，从政治需要出发，决定中国军队立即越过三八线，再打一仗，然后休整。 第三次战役结束后，中国军队用两个月的时间进行了休整，准备3月间发动“春季攻势”。这时，美国人已发现中国军队粮弹补给困难，每次战役只能持续7至10天，美国人称之为“礼拜攻势”。同时，美国人还估计中国军队第一线兵力不足，短时间内不可能发动进攻。美军迅速完成了部署调整和补给，自1月25日开始，由西至东逐步在全线发起了大规模进攻。中国军队没有料到美军会这么快发动大规模进攻，所以主要把精力放在春季攻势的准备上。当中国军队判明美军企图之后，于1月27日停止休整，准备进行第四次战役。 中朝两军召开了会议，战役部署如下，西线由志愿军副司令员韩先楚指挥第38、第50军和人民军第一军团简称韩集团，抗击美军向汉城方向的进攻。东线由邓华副司令员指挥的第39、第40、第42、第66军简称邓集团，于汉城以东地区集结，准备实施反击。人民军第二、第三、第五军团掩护邓集团集结。1月25日，西线美军先发起进攻，重点为水源至汉城公路铁路两侧约20公里的地段。2月3日，西线进攻的美军占领了中国军队一线阵地，志愿军转至第二线防御。西线美军占领中国军队第一线阵地后，继续猛烈进攻。中国军队决定立即对东线的美军实施反击，以打破美军的进攻。 2月11日17时，邓集团和朝鲜人民军第三、第五军团按预定计划开始了战役反击。反击作战于13日晨结束。两天中，志愿军歼灭了南朝鲜第83个团、第3师、第5师各一部，美第2师一个营，4个炮兵营，共12000余人，其中俘虏7800余人。14日，西线美军骑兵第1师应英27旅、南朝鲜第6师开始增援。 是日晚，中国军队调整部署，继续以6个团的兵力进行攻击，并将美军压缩在不足两平方公里的狭小地区。但是美军已形成据点式防御，兵力火力集中，志愿军炮兵少，弹药又不足，因而仍未能解决战斗。从当时双方力量对比来看，中国军队歼灭援敌的可能性很小，因此中国军队于15日17时30分决定停止进攻。16日，佛晓前，志愿军进攻部队撤出，战斗向北转移。从3月7日起，美军集中5个军的兵力，在全线发动了大规模进攻，企图从中间突破，造成由东北迂回包围汉城的态势，以夺取汉城，进而向三八线推进。 为了防止发生不利情况，中国军队第19兵团奉命集结，准备入朝参加西线作战。为了防备美军从侧后登陆，志愿军第9兵团的两个军加强了东海岸的防御。3月9日，中国军队根据当时战场形势，决定第一梯队8个军自3月10日起按照预定计划逐步向北转移，第二梯队3个军接替，继续采取运动防御至三八线以北地区。战至3月底，中国军队全线部队已逐步转移至三八线以北附近地区。4月初，美军越过了三八线。 迄始战 美国当时正在秘密拟定一项从朝鲜撤军的计划。美军参联会在制定方案时，让麦克阿瑟在地图上标出美军在中国军队压力下，最后撤到哪个位置的时刻，就是美国最后决定美军要撤往日本的时间。麦克阿瑟大为不满地在地图上标出了釜山。参联会在制定撤退方案时，按照杜鲁门的指令，还计划撤走100万南朝鲜人，其中包括36000多名政府官员和家属、60多万名警察、26万名士兵，以及他们的家属除了把军队放在朝鲜冀州岛外，其余全部运往日本。美国制定的这一计划虽然是为了应备万一，但同时说明了美国在它的全球战略中已决定放弃朝鲜。这时的美国已经清醒地看出，苏联为了遏阻美国在西欧的发展，正在用中国去拼耗它的实力。在中国发起突破三八线战役即第三次战役的前一天，参联会通知远东司令部不会再派一兵一卒前往朝鲜。在此之前，麦克阿瑟曾向华盛顿建议，用海空军轰炸并封锁中国本土，使用蒋介石军队入朝作战并援助台湾进攻大陆。这一切建议遭到白宫的否定后，麦克阿瑟亲笔给美国一位议员写了一封信。 这封信的内容始终没有全文公开过，但说法很多，说麦克阿瑟像老师对学生一样教训他的总统。他说，“亚洲和欧洲同样对美国尤为重要”。杜鲁门读到这封信的时间是4月11日下午。杜鲁门立即决定撤销了麦克阿瑟的全部职务。杜鲁门在声明中说，他不能相信像麦克阿瑟这样阅历丰富的军人，竟会不明白，把中国国民党军队用于朝鲜战场并同时轰炸中国本土，是在冒挑起全面战争的风险。 对远东司令的突然被免职，美国一些报纸指出，这是杜鲁门受到西方、英法、盟国压力而作出的决定。而美国军方高层人士则认为，真正的原因是麦克阿瑟的许多做法超出了他军事指挥官的权限范围。美军参联会立即电给正在朝鲜访问的陆军部长佩斯，指示他在24小时之内向麦克阿瑟本人宣读总统的免职命令。命令说：“我深感遗憾的是，我不得不尽我作为总统和美国武装部队总司令之职，撤销你盟军总司令、联合国军总司令、远东美军陆军总司令的职务。你的指挥权交给李奇威中将，立即生效，杜鲁门签字。”好像在唱对台戏，好像要产生强烈的反差对比。麦克阿瑟被撤职的同时，中国政府派出了庞大的慰问团。他们带着全国人民献赠的1093面锦旗、420多万元的慰问金、2000多箱慰问品及15000封祖国人民写给最可爱的人的慰问信。来到朝鲜前线。第四次战役结束后，中国军队持续进行了两个多月的异常艰苦的运动防御作战。中国军队当时的意图是在第二番志愿军部队的9个军到齐后，再进行有力的新的战役，争取在新的战役中能有志愿军9至11个军及炮兵7至8个师、坦克3至5个团和朝鲜人民军两个军团参战，从而扭转一时的被动局面。但各方情报及种种迹象表明，美军进占三八线以后还要继续北进，而且从侧后登陆配合正面进攻的可能性为大。中国军队为了粉碎美军从侧后登陆配合正面进攻，夺回主动权，决定在美军登陆之前实施反击。 22日，志愿军第9兵团指挥第26、第27军及第39、第40军配属炮兵第1师从左翼突进。志愿军第3兵团指挥第12、第15、第60军配属炮兵第2支从正面突击，第19兵团指挥第63、第64、第65军和人民军第一军团配属炮兵第8师，从右翼突击，发出全线反击。 中国军队连续作战3昼夜，但战役发展形成平推，歼灭美军不多，美军于25日逐步撤至第二线阵地继续抵抗。26日，志愿军继续向敌防御纵深发展进攻。28日美军主力撤至汉城，继续组织防御。中国军队第五次战役发起后，整个战线形成由西南伸向东北的斜线态势，东线敌人明显突出，而且均系南朝鲜军队。中国军队于4月28日决定立即向东转移兵力，以南朝鲜军队为主要歼击目标，举行战役的第二阶段作战。随即第三、第九兵团先后向敌军发起猛烈突击，于5月17日突入敌军纵深28公里。 在中国军队连续突击下，东线美军第10军主力已沿战线逐次东移，美第3师则由汉城东南迅速东，援南朝鲜第8师也建立了纵深防线，至此敌人又形成了东西相接的完整防御。而这时中国军队粮弹将尽，一时难以补充，雨季又已接近，江湖沼泽，在志愿军之后，一旦山洪爆发，交通中断，那时将重现人民军被美军仁川合围的局面。在这种情况下，21日中国军队决定停止进攻。23日中国军队主力开始向北转移。 23日晨，美军就开始有计划的猛力反扑。美军在反扑中共集中了4个军13个师的兵力，以摩托化步兵、坦克、炮兵组成的特遣队为先导，并有大量的航空兵和远程炮兵支援，多路向志愿军实施反扑。由于对美军有计划的实施这种规模、这种形式的反扑估计不足，未能组织有效的交替掩护，又因8000多伤员未能及时后送，造成了中国军队十分被动的局面。为了稳定局势，中国军队主力及人民军主力立即转入了全线防御。随着中国军队全线防御布置的完成，美军的追击行动被阻止，整个战局趋于稳定。中朝军队将美军阻止在三八线附近，双方均转入防御，第五次战役遂告结束。 开城谈判 1951年5月1日，社会主义各国同时举行了意义非同往年的盛大庆祝游行。朝鲜战争是东方阵营第一次显示出惊骇世界的力量。从国际劳动节的第二天起，5月2日到16日，美国最高决策机构国家安全委员会开了整整两个星期的会，背后就美国在朝鲜所追求的政治和军事的目标，委员会向总统建议，拟通过谈判结束敌对行动。第二天，杜鲁门即批准了这一建议，他明确的指出：“美国的主要敌人是苏联，只要这个敌人还没有卷入战场而在幕后操纵，美国就绝不能在朝鲜浪费自己的力量。”在战争的一年中，美国损失了10万兵力，耗用美元100个亿。1951年军费预算激增到600亿美元，使每一个美国人担负了307美元的战争费用。 朝鲜半岛1951年5月份的战争态势是，美军、联合国军和南朝鲜军虽然增加到69万人，但中国和北朝鲜军队的数量已达到了112万，美国现役陆军总共18个正规师，投入朝鲜的就有7个半师，而苏联这时一兵一卒都没有动用，美国急需停战。 5月中旬以后，美国外交机构开始行动起来，意图疏通一条与中国谈判停火的渠道。5月31日，美国通过已离职的原驻苏大使凯南以老朋友的关系拜访了苏联驻联合国的代表马立克。在闲谈中提到了停火，职业的敏感性，使马立克马上明白了凯南来访的真正目的。美国的信息很快传回了莫斯科。4天以后，即6月3日，金日成秘密前往北京，毛泽东和他谈了停火的利弊。20天以后，即6月23日，马立克在联合国新闻机构举办的一个叫“和平的代价”节目中突然露面。在广播演说中，他谈到在朝鲜交战者之间开始进行停火谈判的时机已经到来。当天，杜鲁门指示美国驻苏大使求见苏联外交部长，就马立克的演说词问苏联政府的意见，他得到了明确的答复：马立克的讲话代表苏联官方意见。 6月25日，杜鲁门利用参加一次典礼的机会发表演说时，突然插进一段与典礼内容完全无关的话，他说：“美国愿意参加朝鲜问题的和平解决。”同日，中国的人民日报也发表了一篇社论，表示中国人民赞成马立克的和平建议。不知内情的世界舆论一致认为是苏联的建议打破了朝鲜战争的僵局。 4天以后，6月29日，美国国家安全委员会给远东的李奇微发出一份急电。电文说：“奉总统指示，你应在30日星期六东京时间上午8点，经广播电台将下述文件向北朝鲜军司令部发出，同时向新闻界发布。”文件全文是：“本人以联合国军总司令的资格，奉命与贵金谈判下列事项，因为我得知贵方可能希望举行一次停战谈判会议，以停止朝鲜的一切敌对行为以及武装行动，并愿适当保证有关停战协议的实施。我在接到贵方对本文的答复以后，将派出我方代表，并提出会议的日期，以便与贵方代表会晤。我提议这个会议科在元山港内一艘丹麦医疗船上举行。美国陆军上将李奇微签字。”这个声明经东京和汉城电台反复播放后，美军还用传单方式向北朝鲜散发。 三天以后，7月1日，北京拟就的一份复电以金日成和彭德怀的名义在北京经广播电台发出。电文如下：“联合国军总司令李奇微将军，你在6月30日关于要求和平谈判的声明收到，我们授权向你声明，我们同意为举行关于停止军事行动的谈判而和你的代表，会晤的地点我们建议在三八线上的开城地区。若你们同意，我们的代表准备以7月10日至15日和你们的代表会晤。朝鲜人民军总司令金日成、中国人民志愿军司令员彭德怀签字。” 经过10天的协商，交战双方决定在中国军队控制的开城一个叫来风庄的地方正式开始谈判。 7月10日清晨，联合国方的代表从文山前线乘直升飞机飞抵距开城10公里的板门店，然后换乘汽车，按双方约定悬挂白旗，直驰开会地点。代表联合国谈判的是清一色的美国职业军人，团长是美远东海军司令乔伊，代表分别是美国驻远东的海陆空三军副参谋长，另外还有一名南朝鲜第一军团的司令白善业。谈判会场由志愿军和朝鲜人民军的军事警察负责警戒，以开城为中心，半径5英里以内为中立区。中国和北朝鲜的代表是志愿军副司令员邓华和参谋长谢方，朝鲜人民军总参谋长南日和情报部长李向朝。中共中央指派原中央社会部部长李克农全权负责谈判工作，并指定外交部新闻局长乔冠华作为他的助手，同时赴朝，工作人员包括中国驻朝武官柴城文等。 被选定的会场战前原是一座茶馆，而此时进出茶馆的人都不是来喝茶的。第一次会议时，美军代表团抢先进入会场，直接坐到了面朝南的位置上。当宣布开会时，美军代表立即把一面联合国的小旗摆在他们的桌前。按照国际惯例，胜利方是坐在面朝南的位置，而战败者是面朝北而坐的。第二天会议中朝代表早早进入会场，坐在了朝南的坐席上，并且把朝北的坐席换成了一排排的矮凳子，还把一面很大的朝鲜国旗放在了台面上。 这是中国战地记者拍摄到的他们的同行美国记者在会场外的情景，他们正在打赌这次谈判需要多么长的时间，结果赌最长的时间的是5个星期。而实际上，这次谈判仅仅为达成一个一致的会议程序就花了半个月的时间。会议开到第24天的时候，一个意外的事件让早已不耐烦的美国人找到了借口。8月4日中午，一支全副武装的中国联队徒步通过美国代表团的驻地，违反了双方关于会议地点半英里内不准有武装部队的协定和开城半径5英里之内所有人员只许配备腰配武器的中立区规定。虽然中国马上表示了道歉，但美国还是单方面宣布立即休会。 休会5天以后，美国同意赴会。赴会的第9天，一件更为严重的事件发生了。8月19日清晨，中国军事警察一支9人的巡逻队在中立区内突然遭到伏击，排长姚庆祥当场中弹牺牲。当天上午，双方联络官赶到现场，在各国新闻记者实地采访中进行查证。事实很清楚，凶手是南朝鲜的武装人员，约30人从美方阵地潜入中立区。事件发生两天后，美方答复说，联合国军不能对游击队的活动和治安问题负责。就在美方答复的当天晚上，8月22日夜间10:20，一架美国飞机潜入中立区，低空盘旋了5圈后，投下4枚燃烧弹和12枚杀伤弹，并对中国代表团驻地多次俯冲扫射。这是当时采访会议的记者拍摄下来的现场勘察的镜头。 第二天，8月23日，中国和北朝鲜通知美方停止谈判会议。事实上，在此5天以前，继8月18日联合国军已经发动了大规模的夏季攻势，美国人说“让大炮和机关枪去辩论吧”！ 空中绞杀战 1951年初夏以后，李奇薇已经清醒地认识到，面对兵源占绝对优势的中国地面战线，美军再不可能像战争初期那样长驱直入，即使突破对方某一处防线也是十分困难。由于在狭窄的北朝鲜境内压满了成体系配置的77万中国志愿军，美军两栖登陆的可能已不存在。美国唯占优势的是海空力量。 几乎是在开城谈判中断的同时，美军开始了一场长达三个月之久的空中绞杀战。二战期间，美英空军曾在意大利亚平宁半岛向德军使用的铁路干线发动长期的攻击，成功的实施过一次空中阻滞战役。六年以后，它又重新翻版用在朝鲜半岛。它的具体战法是在朝鲜北部划定一个阻滞地区，以大批量的空中力量进行长时间的轰炸，以切断志愿军的后方补给线，窒息中国的作战能力。在制定这个计划时，李奇威说，“我们就是要用空中力量这根绳子，一下子把中国巨人勒死”。 据当时美军情报部门分析，在前沿战区内，中朝部队有60个战斗师，每一个师每天至少需要40吨补给品才能维持有限的战斗。这样中国后勤部门就要每天将2400吨补给送往前线。以每辆卡车载重两吨计算，运送一天的补给就需要1200台卡车，从鸭绿江到前线往返需10天，以5天计算，大约需要6000以上的量次。如果用火车，每天就必须有120节车皮到达前沿战区。因此，切断北朝鲜有限的公路和铁路就是对中国军队的绞杀。 按照作战计划，美军将北纬38度15分到北纬39度15分这一宽度地区定为主要封锁区，把通过这个封锁区的7条交通干线又分化成3个责任区，分别由空军第5航空队、海军陆战队第一航空队和第77特混舰队按区域进行轰炸，摧毁每一条公路上的每一辆卡车和每一座桥梁、每一条铁路上的每一节火车和每一座车站，以彻底瘫痪39度线上的全部运输能力。 这一时期正值朝鲜雨季，由于战火对水利设施的破坏，北朝鲜境内发生了40年未见的特大洪水，仅洪水冲毁的铁路桥梁就有94座，洪水还冲毁了50%的公路桥梁，仅洪水造成的运输中段就长达一个月之久。这对李奇微的空中绞杀行动可谓是个千载难逢的机会。他命令远东地区2000多架海空军的战机不分昼夜轮番出动，不惜代价狂轰滥炸。在重点地区，平均每天出动5至6批次，每次60至100余架大编队机群集中向目标投弹。到8月底，重点封锁的兴安州、西浦、界川这个三角地带所有的铁路和桥梁已没有一座和一段是完好的，尚能通车的也只有几个地段，总长度不过150公里。在一条长73公里的重点铁路线上，美国扔下的炸弹竟达到了38186枚，平均不到2米就有一枚炸弹爆炸。这种轰炸逐日逐周逐夜的在加剧。据统计，9月份美空军出动飞机3027架次，10月份增加到4128架次，11月份陡增到8343架次。被美军炸毁，又被志愿军工兵修复，而后又被炸毁，再被修复的桥梁达到了190座次。破坏又被修复，修复再被破坏的铁路达到4000多处。 中国每月必须运往前线的物资仅有一小半运达。8月底之前这段时间，前线部队就已经发生了粮荒，许多二线部队靠野菜充饥，弹药运不上去。前沿阵地曾发生过在弹尽之后往山下滚石头阻击敌人的事。在这危难的时刻，彭德怀派志愿军副司令洪学智亲自去抓后勤保障，随即成立了志愿军后方勤务司令部，洪学智任司令员。彭总对他说：“前方是我的，后方是你的，你无论如何要打破李奇微这个天门阵。”朝鲜战争到了这个节骨眼上，已成了一场拼后勤的战争。历来以“肩上后勤”著称的中国军队遇到了一个全新的课题。顺便提及的是我们在片头讲到的那支北平和平起义的原国民党部队，这时也以解放军第23兵团番号入朝轮战，改称志愿军第23兵团，兵团司令即北平绥远起义的国民党将领董其武。该部队就是负责保护那条炸不烂的钢铁运输线，他们的任务就是负责排除美军扔下的定时炸弹及空袭预警。 在这段时间里，中国国内驻军几乎所有的高炮分队都进入朝鲜轮战，平均每月击落敌机60架，总计击落了430架美军飞机。中国军队中唯一的一支铁道兵部队，这时连司令部一起搬到了朝鲜，番号改称志愿军铁道兵团。据铁道运输司令部统计，美军9月份出动飞机3027架次，10月份出动飞机4120架次，死死咬住志愿军铁路运输的咽喉，9月轰炸铁路648次，炸断桥梁57座。10月破坏铁路1336次，炸断桥梁53座。但是正是这支用镐、用铁钳的英雄部队，最终保障了铁路的通畅，保障了时间跨度为3个月的这场反绞杀战的胜利。就连美国第8集团军司令范波里特也不得不承认，“中国人创造了惊人的奇迹”。 在空中绞杀战全面展开的9月间，北朝鲜的天空突然出现了中国战机，那是机头喷涂着一层红色的苏式喷气式歼击机，这使美军大为意外。在此8个月之前，1951年1月，北朝鲜北部曾出现过飞机拦截美军飞机。美国情报部门从电波中监听到的俄语通话判明，有两个苏联航空师的近200架飞机已入朝参加空战，负责平壤以北青川江约100公里交通线上的制空权。苏联对此缄默不已，驻在中国丹东的苏联空军人员一律穿中国志愿军军服，美国政府也不表态，佯装不知。但到了9月，当美国人在电波中听到的不再是俄语，而是华语时，他预感到在天空中又多了一个新的对手，中国人民志愿军空军正式参战了。在整个战争期间，志愿军空军总计出动了飞机26491架次，击落美国飞机333架，击伤95架，自己被击落231架。 1951年的整个夏季，美国为了给予摆脱在朝鲜半岛的困境，在后续兵员严重不足的情况下，已考虑重新武装日本，这使美国在亚洲，特别是在东南亚丢掉的比朝鲜战场还要多。这里看到的是1951年美国准备单独与日本缔结和平条约时，各种国际会议的镜头。一年以前，1950年夏季，美国刚介入朝鲜战争的头几个月，就已经抽空了它在日本的占领军。随着战争进入相持阶段，参加联合国军的16个国家已决定不再增兵朝鲜，美国自己也决定不再往远东增调一个师或一个团。麦克阿瑟在职时获白宫批准，授权日本建立一支75000人的警察后备队。这支名为警察的队伍在朝鲜战争打得如火如荼的时候，还进行了营级对抗军事演习。美国陆军部在杜鲁门的授命下，把向日本这支警察队伍提供30亿美元的计划列入国家预算。美国政府甚至计划在52年的6月1日前将这支警察后备队按10个作战师装备起来。 据战后美军资料披露，在联合国军越过三八线北上时，担负元山港扫雷任务的就是原日本海军人员和舰支。美国的这一切行径都需要有一个所谓的法律依据做保证，这就是1951年夏季出笼的《美日安全条约》。 美国对日本的单独苟合激起了深受日本军国主义压迫的亚洲各国的不满。美国拟定于9月在美国本土旧金山召开签约会议，中立的印度首先表示拒绝参加，一直称为被美军解放的菲律宾爆发了大规模示威游行，缅甸、印尼也纷纷发表抗议声明，甚至就连日本政府自己也不同意重新武装本国警察。现在看到的镜头就是那时日本人反对缔结《美日安全条约》，东京出现的骚乱。 1951 年10月8日，《美日安全条约》正式签字，苏联、波兰、捷克等国拒绝签字。十天之后，在朝鲜战场，美国地面部队为配合空中绞杀战发起的夏季攻势也偃旗息鼓。这次战役，美军集结了3个师的兵力，在东海岸大约80公里宽的北朝鲜军队的防御正面实施主要突击，战时一个月只攻占179平方公里，却付出了伤亡78000人的代价，而这其中美国士兵就占22000人。 板门店 美国夏季攻势失利后，9月17日，李奇微主动给彭德怀发了一封信，对美机误炸中立区表示歉意，这实际上是个信号。两天后，9月19日，彭德怀复信李奇微建议恢复谈判，并提出要换个地点。几经确商，最后决定在文山至开城的公路上，那个只有一间草房的板门店。10月25日，双方代表团的车队按约定时间几乎同时到达不在任何一方控制下的新会址。从7月10日算起，世界瞩目的开城朝鲜停战谈判用了44天时间，开了32次会议，除了达成一项会议议程的协议外，没有任何结果。在开城谈判中断了63天后，双方又开始了重新谈判。谈判的焦点仍然是军事分界线的划分。开城谈判时，中国曾建议以三八线为界，双方各自后退5公里，中间地带为非军事区。 美国反建议提出，战场上除了地面战线，还有一个海空战线。军事分界线只能在地面战线和海空战线之间划分。美国的观点很明确，同时也很荒谬，即它的海空优势必须在划分界限时得到补偿。如果按美国的建议，中国军队要让出12000平方公里的控制区域。如果按中国的建议，美国要退回到三八线以南。 在一次小组会上，中国代表谢方指出：“目前双方战线胶着在三八线附近，这应该说是双方综合军事实力形成的现状。”根据当时的速记稿，美方代表是一个叫霍志的将军，他说：“如果按你们的方案，以三八线化界，根据地形，我方在东线后撤后难以重新攻取，而你方在西线后撤后易于重新攻取。” 谢方当场问他：“我们在这里到底是讨论停战，还是在讨论停火一下再打更大的战争？”霍志甚至还提出，“要不然咱们现在丢硬币，各自选一面，谁赢了就按谁的来。”北京、华盛顿、莫斯科、平壤、汉城，谁也不会同意用丢硬币的方式来划分南北朝鲜的国土。美国在空中绞杀战和夏季攻势中被打掉了78000人，而战线仅向前推荐 2-8公里，最后还是回到谈判桌上。 板门店重开谈判后，中国马上提出一个新的方案，即“就地停战”。经过整整一个月的谈判，双方签订了一个协议，以实际接触线为军事分界线。美国在协议中加进一条条款，此协议在批准后30天之内签字生效。协议于11月27日双方批准通过。也就是说，在30天之内，美国李奇微、中国彭德怀，朝鲜金日成，只要同时签字，朝鲜就实现停战了。 但在这时，另一个问题出现了，它就是战俘问题。12月18日，谈判停战的双方代表按程序开始交换各自掌握的战俘名字。美方认为名单出入很大，联合国军司令部记录的失踪人数是11500人，而名单上只有4417人，差了7000多人。南朝鲜军记录的失踪人数是88000人，而名单上的人数只有7142人，相差的数目是8万多人。 美方代表质问北朝鲜代表，在战争头几个月，平壤的新闻广播公布的俘虏人数就已经是65000人，怎么现在才拿出11000人的名字呢？中国代表指出，志愿军曾在前线释放了成千上万的美军战俘，美国代表反驳说，只有177人回到了部队。这就是美军情报部门侦察到的设在鸭绿江边的关押联合国军的战俘营。这些战俘营，原是由北朝鲜军队看守的，因战俘死亡率太高，后由志愿军派出警卫部队接管。在谈判中，美方承认，根据他们的情报，中国接管看押联合国军的战俘营后，战俘生活待遇确有很大改善。在谈判中，因战俘人数问题双方僵持不下的时候，美国又提出了一个新的方案，使本以棘手的战俘问题更加复杂化，这就是美国提出的战俘自愿遣返原则。具体解释就是，双方交换战俘的时候，战俘可以根据自己的意愿，选择愿意或不愿意回国。李奇微在新闻发布会上公开声明，联合国军将执行这一方案。美国认为，如果有大量的北朝鲜和中国战俘拒绝回到共产党方面，这无疑是心理作战中的一个胜利，是在世界面前对共产主义的一个反击。 12月27日，30天的有效期终于过去了，停战协定成为一张废纸。从这一天起，谈判双方虽然按时开会，但会议的时间越来越短，从一分钟到半分钟，有一次竟创下了25秒的记录。双方刚刚坐下，美方宣布现在开会，但同时马上宣布现在休会。说完起身走出会场。美国人用这种到会即提休会的办法来阻挠谈判的正常进行。 1951年的冬季，板门店沉寂在一片瑞雪之中，同时整个战线也相对的静谧。 细菌战 当朝鲜战争僵持到第二个冬天的时候，又一个敌人出现了，这就是瘟疫。2月下旬的一天，北朝鲜电台突然广播说，在平壤北部发现了美国的一枚细菌弹，里面装满了可以在冰天雪地里生存和飞舞的带菌的苍蝇。社会主义各国的报纸广播纷纷报道了这一消息，西方却把这看作是一条新的战线上的宣传攻势。美国沉默了一段时间。据战后资料披露，1951年夏季，北朝鲜已经大面积流行霍乱、伤寒和天花。美国情报部门判断，由于平壤估计瘟疫在天暖后还将泛滥，所以开始嫁祸美国。一个月以后，平壤公布美军在朝鲜北部散布的细菌达804次之多，范围遍及7个道44个郡。同时，中国卫生组织公布，在中国东北和青岛也发现了带菌昆虫。这时，细菌弹已演发成细菌战，前线的志愿军遂成立了以第一副司令员邓华为主任的总防疫委员会。在世界舆论的一片谴责声中，美军才在缄默中开口，断然否定使用了细菌武器的行为。美国国防部指示李奇微，一旦对方在板门店提出这个问题，要尽力明确否认。与此同时，美国国会向日内瓦国际红十字会主席发去邀请，表示美国欢迎全面调查。 国际红十字会接受邀请，但平壤拒绝该组织进入北朝鲜。3月3日，金日成在平壤接见了由苏联邀请的由欧亚拉美一些国家的法学家组成的国际民主法律工作者协会调查团。这个调查团听证了北朝鲜和中国医务工作者的各种检验报告，并查看了由北朝鲜提供的细菌弹实样和昆虫标本。调查团还当面听证了两名被俘的供认投掷了细菌弹的美国飞行员的供词。 3月31日和4月2日，调查团用两天的时间发表了一份长达数页的调查报告，确认美国在朝鲜进行了细菌战。 战后40年来，美国有关朝鲜战争的机要档案陆续解密，但是唯有细菌战的问题一直予以否认，就是这位当年向国际调查团供认投掷了细菌弹的被俘美国飞行员，在当时的听证会中，利用与一位调查团中的奥地利人同时进厕所的机会，偷偷说了一句，“我的话全是假的”。1954年释放战俘后，他回到美国，马上否认了他曾供认的罪行，这是他当时发表声明的资料镜头。 但是历史学家最终还是找到了一份有关细菌战的美军文件。在这份文件中，美国陆军司令部曾制定了使用毒气和生化武器的作战计划。然而，历史学家同时指出，遗憾的是，它仅仅是一份计划。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-抗美援朝（二）","slug":"共和国战争-抗美援朝（二）","date":"2023-06-17T12:19:33.000Z","updated":"2025-09-16T02:08:42.967Z","comments":true,"path":"2023/06/17/共和国战争-抗美援朝（二）/","link":"","permalink":"https://naosense.github.io/2023/06/17/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E6%8A%97%E7%BE%8E%E6%8F%B4%E6%9C%9D%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"仁川登陆 9月15日凌晨，联合国军的500架舰载飞机分别从6艘航空母舰上起飞，在夜空中飞进朝鲜大陆。同一时刻，由联合国军的7艘巡洋舰、32艘驱逐舰、86艘战斗舰艇组成的一支特混舰队，从公海突然抵进朝鲜西海岸。清晨5时整，美军4艘巡洋舰和驱逐舰将2800余发重型炮弹排山倒海的向目标倾泻，这个目标就是仁川港。 美军的仁川两栖登陆作战计划代号为“烙铁行动”。1小时后，美军的火箭发射船又发射了1000发火箭弹，同时美国飞机低空辐射向目标扫射。在炮火的掩护下，大约1800名海军陆战队员开始向滩头冲击。这一天，麦克阿瑟坐镇在旗舰麦金立山号上，亲自督阵，232艘各型舰只这时正鱼贯进入仁川湾。6时30分，由美国海军陆战一师和第7步兵师新编组的第10军约7万人开始强行登陆。12小时后，美军攻克仁川。5天以后，继9月20日美军已逼近汉城，麦克阿瑟同时命令坚守釜山的第8集团军发动反攻，与在仁川登陆的第10军南北呼应，形成夹击之势。这是美国陆军当时的作战演示图。 在这最危急的时刻，北朝鲜军队竭尽全力，对釜山一次又一次的发起进攻。一场惨烈的战斗又持续了三天。有几次釜山防线险些被突破，美军差点就被赶下大海。但这时北朝鲜军队经过汉城的补给线也完全被切断。到了23日，北朝鲜军队终于不能支撑，开始后撤，在以后的7天时间里，乘胜追击的美第8集团军与美军第10军把北朝鲜全部主力合围在南朝鲜中部山区，北朝鲜军队由全面后撤，形成全面溃散，建制全部被打乱，重武器全部丢失。这时，距离北朝鲜军队越过三八线已整整3个月，距离麦克阿瑟仁川登陆仅10天。 这是美军战地记者拍摄到的美军在追击中抓俘北朝鲜士兵的实况镜头。 这时的汉城已被美军攻克，沿三八线全线的退路已被切断，北朝鲜主力几乎全部被阻隔在南方，大约有5万人成为战俘。 现在，让我们引一段麦克阿瑟在仁川登陆的前一天，面对从日本神户即将起航的舰队所发表的演讲。他说：“如果说这次登陆是个大赌注，我认为这是往盒子里放5美元，然后打开盒子将捞到5万美元，这5个美元就是仁川。” 9月27日，美军攻克南朝鲜首都汉城，这是当时记录的镜头。 收复汉城的前一天，从釜山反击的第8集团军和从仁川登陆的第10军的两支先头部队会师。三天以后，麦克阿瑟从麦金利山号旗舰上直接踏上了朝鲜国土。这是他在朝鲜战争中第三次，也是最特殊的一次巡查朝鲜，整个南方已被美军收复。这时他不可能想到，几个月以后，当他第四次，也是最后一次视察朝鲜时，被美国报纸骂成是一个杂种和大混蛋。据史料记载，美军走进汉城时，看到了当年他们进入德国时所目睹过的战争罪行，无数被处决的人摆在大路上，然后用坦克碾压的面目皆非的尸体，铺盖了几公里长。这就是当时被记录的电影画面。现在没有资料可以查明这些镜头的真实性或者是虚假性。 美军记者还记录了这样的镜头，为北朝鲜军队服过务的人，是如何受到他的同胞的唾弃。因为这些镜头同属于这场战争火气拼杀和心理搏斗的一部分，所以我们记录于此。 9月28日，也就是距离6月28日，南朝鲜政府丢掉汉城整整三个月后，李承晚被接回了汉城。 美国人有这么一种特点，愿意把简单的时间和地点含附上所谓的寓意。据史料记载，欢迎仪式中，李承满应该致辞，他从口袋中取出讲稿，但是被颤抖的双手握得瑟瑟发响，他用手绢擦眼泪，但泪水总是不断地涌出眼眶。他索性不要讲稿，不擦泪水，大声地喊了一句：“千言万语归结一句话，让我们感激我们民族的伟大拯救者吧！”麦克阿瑟这时俨然是一个救世主，他说：“总统先生，现在我把汉城重新交给你。” 李承晚政府返回汉城的第三天，南朝鲜军队在几乎未遭受抵抗的情况下就跨进了北朝鲜，而美军却在三八线上停了下来。当天上午，麦克阿瑟在东京通过广播电台向金日成发出投降敦促书。他说：“我最后一次要求你及你指挥的军队立即放下武器。”这一天是1950年10月1日，是新中国成立以后的第一个国庆节，在当晚的国宴上，刚刚获悉朝鲜最新战况的毛泽东把话题引到了中国出兵的问题上。民主人士黄炎培说：“自古道出师有名，不正则言不顺。”周恩来插话说：“我们打算叫支援军，支援朝鲜人民。”黄说：“谁派出去支援的国家吗？那我们是不是要和美国宣战？”毛泽东一听，说对，伸手拿起一支毛笔，把“支援”两字改为“志愿”，“中国人民志愿军”就如此定名。 两天以后，即10月3日凌晨1点，由于中国与英美没有外交关系，政务院总理兼外交部长周恩来紧急召见了印度驻华大使潘尼加，请他代为转告，如果美军越过三八线，中国将出兵参战。印度总理尼赫鲁当时将这一信息转告了英国。一天以后，继10月4日中午12点，身为西北军政委员会主席的彭德怀正在西安召开干部会议。他的秘书走进来，悄声对他说，中央派专机来接他开会。当天下午，彭德怀来到北京，当他带着大西北的经济开发计划走进会场时，他才发觉这气氛凝重的会议是讨论中国入朝参战的问题。会后，毛泽东与他单独交谈。毛泽东只说了一句，得贤将者，兵强国昌。千军易得，一将难求。彭德怀已经心领神会了。 10月7日，美国操纵的联合国为了不使苏联使用否决权，没有召开安理会，而是召开联合国大会。当天，联合国大会通过一项美国提案，这个提案虽未明确说出来要征服并占领北朝鲜，但是在玩弄的政治辞藻中，已经清楚地表明了这个意思。提案原文如下：一、应采取适当措施，以保证实现全朝鲜稳定的条件。二、应在联合国指导下，采用所有合法行动，以使朝鲜建立统一的民主政府。在这个决议通过的第二天，美军越过了三八线。 就在这同一天，10月18日，中国中央军委主席签署命令，任命彭德怀为中国人民志愿军司令员兼政委，命令十三兵团所辖4个野战军、3个炮兵师立即准备完毕，待命出动。志愿军以东北行政区为总后方基地，由中央政府副主席、东北政府主席高岗负责指挥调度。 就在这天晚上，周恩来乘专机秘密飞往苏联。同机的有林彪和中共中央办公厅主任兼俄语翻译施哲，中央原拟定林彪统领志愿军出国作战，但他推脱有病，同机前往苏联疗养。周恩来一行次日飞抵莫斯科，斯大林此时正在克里米亚半岛的黑海之滨休假。中国专机再次起落，于10月10日晚间飞往斯大林在索契的别墅。 在周恩来飞往苏联的同时，10月11日凌晨，彭德怀飞抵丹东。他刚一出机场，隔江相望，就看到了鸭绿江对岸，朝鲜边城新义州已经被炸成一片废墟。 这一天上午，在彭德怀视察集结于中朝边境的部队时，周恩来正在苏联与斯大林进行会晤。中国通报了已决定出兵的情况，并请求苏联给予军事援助和空军支援。斯大林满口答应，并当着中国客人的面吩咐国防部长布尔加宁立即着手去办。会谈后，周恩来马上返回了莫斯科，用中国大使馆的电台向北京通报了情况。几乎是在同一时刻，彭德怀在丹东也草拟了一份电报发往北京。彭德怀电告毛泽东，在鸭绿江铁桥还未遭美空军破坏前，中国军队应及时过江，在江南集结更为主动。3个小时以后，毛泽东即批示同意。40分钟以后，代总长聂荣臻就已将批复电文发回丹东志愿军前指。 这时已是十二日凌晨，也几乎是在同一时刻，在苏联的周恩来刚刚把与斯大林会谈的情况用密码发出去几个小时，突然接到苏联外交部长莫洛托夫的电话。苏联外长告诉他，苏联不准备派空军支援，理由是还没有准备好。在苏联的周恩来立即将这一意外情况用电文通报给毛泽东。毛泽东接电后，立即给在丹东的彭德怀发了一份急电。彭德怀当夜飞回北京。第二天即13日，中央召开紧急会议。会后，毛泽东旋即给等在莫斯科的周恩来拍去了急电，通报中央会议的情况。周恩来接电后，迅即启程，再往黑海面见斯大林。斯大林原以为周恩来可能是为空军的问题来讨价还价的，但周恩来一见面就告诉斯大林，中国政府已经决定，没有苏联空军的支援，中国也将出兵朝鲜。 10月15日，中国已确定入朝的4个野战军分别召开大会，以志愿军的名义号召干部战士自愿参加，结果是其所属的部队，整个团、整个师、整个军，以至于整个兵团都集体加入了志愿军。在10月15日的同一天，美国总统杜鲁门从华盛顿飞往太平洋上一个名叫威克的小岛，与此同时，他的远东总司令麦克阿瑟也从东京飞往这个威克岛。两人面对面的在这里会晤，是讨论一个问题，就是中国和苏联出兵的可能性。麦卡阿瑟对杜鲁门说，中国如果真出兵，就应该在美军仁川登陆之前，现在时机已经过去了。他通过印度的传话完全是一种嘘声动喝。这位联合国军总司令向美国总统保证说，再有一个月朝鲜战争就能结束，中苏想干预也已经来不及了。在他们谈话时，已越过三八线的美军进展顺利的出人意外，其第八集团军沿开城、沙里院、平壤轴线正面推进。同时，美国海军陆战队从西海岸的新南向平壤迂回包抄。10月19日，美军在越过三八线的第10天，北朝鲜首都平壤沦陷。按麦克阿瑟的作战计划，第10军从西海岸仁川登陆，绕到东海岸元山强登陆。但第10军登陆时，元山早已被南朝鲜军队攻克，这样美军在几乎没有任何有效抵抗的情况下，全线逼向鸭绿江。 在美军攻克平壤的当天，也就是10月19日，中国人民志愿军26万人从以河流分界的中朝边界上的三个地段，跨过了鸭绿江。 出国第一战 仅仅一江之隔，志愿军一踏上朝鲜国土就没入在浓烈的战火硝烟中，志愿军奉命夜行晓宿隐蔽前进。每到夜晚，这支急进向南的队伍和向北溃散的北朝鲜军队就拥堵在公路上，人挤车塞，常有人拦住中国军队，问，有飞机吗？有坦克吗？当听到没有时，就连连地摇头失望而去。 出入朝鲜的13兵团所部是四野最有战斗力的部队。奉调时，军委命令刚完成海南岛战役的15兵团机关与驻军中原的13兵团机关对调。这样实际上是原15兵团机关的全班人马统辖13兵团建制的部队，除政委赖传珠、在京养病司令员邓华、副司令员洪学制、韩先楚以下，全部随军入朝。彭德怀带着一部电台、一个秘书、4个警卫员，早于大部队6个小时提前过江，由朝鲜外交部长带路，在北部山区四处寻找踪迹不明的金日成，最后在边界地区的一个金矿山洞里，两人见了面，时间是10月21日。这时志愿军已经入朝三天。 在这一天，美空降187团在平壤以北的顺川一线实施了空降作战，又一次切断包围了北朝鲜回撤中仅存的部队。按照麦克阿瑟的最新命令，攻陷平壤的第8集团军和元山登陆的第10军，不必再对进合围，只要各自穿越过最后一片军事空白区的北部山区，只要跑到鸭绿江，这一仗就算打完了。 这时，在江界那个北朝鲜作为临时首都的山洞里，金日成悄声告诉彭德怀，他手上已经基本没有部队。彭德怀后来回忆说：“我当时已经很清楚了，对付美军最后的攻势只有靠志愿军自己了。”志愿军临出国前曾拟定了一个防御地域，这就是朝鲜半岛上最窄的蜂腰部，它横贯整个半岛不过170公里，但到21日时，美军距这一地带最近的只有50-70公里，而志愿军按夜行军的速度，至少还有3天的路程。这时北京及入朝的13兵团都与彭德怀失去了联络。 在北京运筹帷幄的毛泽东在这一天的凌晨，每隔一小时给13兵团发电一次，接连三次指示“现在是争取战机的问题，是在几天之内完成战役部署，以便在几天之内开始作战的问题，而不是先有一个时期部署防御，然后再说进攻的问题。”这时的美军，其第8集团军和第10军分头冒进，已犯了兵家大忌。 在北京的毛泽东和在朝鲜的彭德怀同时看到了这一点。21日上午，电台与北京恢复了联络。与金日成谈完话的彭德怀立即向毛泽东拍发了急电，拟调整原定部署运动歼敌。在他急等回电时，秘书向他报告说40军的118师强行军路过这里，现在就在沟口。彭德怀为之一振，当即召见118师师长邓月和政委张玉华。他先讲了敌情的变化，又拿出刚刚拍发的给军委的请示电报，让两位师职干部一一过目，然后指着地图命令这支偶然路过的部队，让他们立即抢占温景以北的有利地形，预设阵地，掩护主力部队在这一带展开。118师受命出发时，给只带了4名警卫、只身闯进战场的彭德怀留下了一个连做警卫。 这一天的中午，十三兵团邓华和洪学智在那个叫大洞的林子里找到了彭德怀。这时，彭德怀才知道，毛泽东电报中对军事形势的分析，与他的判断一样，两人不谋而合。10月24日，彭德怀率13兵团机关进驻紧靠前沿的大鱼洞。在作战会议上，彭德怀说：“我已向毛主席请示，把13兵团部改为志愿军领导机关，同时，原兵团指挥员也升任志愿军领导成员。”就这样，当天晚上，彭德怀打给毛泽东一份急电。第二天，即10月25日，毛泽东以中共中央军委的名义批复了彭德怀的急电，批准成立志愿军总部及相应的人事命令，任命彭德怀为司令员兼政委，任命邓华为第一副司令员兼副政委。任命洪学智、韩先楚为副司令员，任命谢方为参谋长，任命杜平为政治部主任。颇有意味的是，在毛泽东的任命发到朝鲜之前，战斗已经正式打响了。 洪学智在他的回忆录中描述：“这场战争的序幕是这样拉开的，10月25日凌晨2点，司令部作战值班室的电话突然响了起来。118师司令部报告，我们的正面发现了敌人，与敌人不期而遇的如此之快，以至于接电话的参谋长谢方都不相信。他大声问，你们是不是搞错了？电话里说，没搞错，确实是敌人，说外国话听不懂。那你们的位置在哪里？在北镇至温景的公路上。” 25日上午10:20，战斗打响了。当南朝鲜第60第2团一个先头加强步兵营进至118师354团在风中洞、雨水洞之间的埋伏圈时，志愿军当即以拦头截尾斩妖的战法向敌人发起了突然而猛烈的攻击。首先发现敌人并与之展开战斗的这个师，就是三天前彭德怀临时抓住并面授机宜的那支过路的118师。他们现在包围敌人的位置，正是彭德怀三天前指着地图命令他们抢先到达的温景。10月28日晚，志愿军第40军主力开始向温景以东归头洞地域之敌发起进攻，激战至29日晨将伪军第6、第8师各两个营大部歼灭。 该军第118师趁敌动摇之机，于29日晚向伪第7团发起进攻，经一夜战斗将其大部歼灭。志愿军首长遂令第38军迅速攻占西川，而后向新兴洞、球场、军隅里方向出击，向敌侧后实施迂回。第38军由于把西川之伪军误认为美军未及时展开攻击，以至于迟至29日黄昏发起攻击时敌已难逃，失去了歼敌良机，伪第2军团，遭我打击后，敌人虽已发现中国军队入朝参战，但对兵力估计不足。 10月31日，美第24师继续向朔州前进，美第一军预备队骑兵第一师从平壤调至云山、龙山洞地区，增援伪第一师。敌军虽然调整了部署，但其兵力仍处于分散状态，而且不明我军的情况。据此，志愿军首长决心采取向敌侧后实施战役迂回，结合正面突击的战法，集中兵力各个歼灭云山泰川球场地区之地。毛泽东电告同意了这一决定，并指示此战只要我第38军全部及第42军一个师能确实切断敌人青川江后路，其他各军师能够勇敢穿插至各部分敌人的侧后，实施分割敌人而各个歼灭之，则胜利必能取得。 第39军原定于11月一日19:30向云山之敌发起攻击，是日15:30，发现云山敌人有撤退的迹象，遂乘机以8个步兵团在炮兵火力支援下，提前于17时发起进攻。激战至2日凌晨攻占云山，歼灭美伪军各一部，并在云山以南堵住了由云山撤退的美骑兵第一师第8团直属队及其3营的退路，将其压缩包围于诸仁桥地区。2日至3日骤减，该敌在飞机、坦克的支援下拼命突围均未得逞。3日夜，中国军队将被围之敌全部歼灭。 与此同时，志愿军第115师343团在云山以南龙城洞、龙头洞地区击溃了由泊船方向北原、云山至美骑兵第一师第5团。云山战斗，我军首次以劣势装备歼灭了具有现代化装备的美骑兵第一师第8团之大部，以及伪第一师第12团余部，共计毙伤俘敌2000余名，其中歼灭美军1800余名，缴获飞机4架，击落飞机3架，击毁与缴获坦克28辆、汽车170余辆，各种炮119门，打击了号称王牌军的美骑兵第一师的嚣张气焰。11月3日，我西线各军遵照志愿军首长的电令，转入追歼逃敌的作战。 感恩节 10月25日，一路乘胜挺进的美军突然在朝鲜北部山区遭到了顽强阻击，美军一时大为疑惑。战斗中，第8集团军抓住25名志愿军俘虏。经审讯，美军情报部门才弄清，中国军队已经入朝。他们是成建制的正规部队，但兵力数目不详。当时美军估计中国军队可能约有5个师的兵力，最大的战斗单位是团级。根据这一情报，美军全线停顿下来，前出的部队也紧急收缩，原地待命。 美国国务院经过全面分析，不知为什么竟向杜鲁门报告说，中国人进入朝鲜完全是为了保护中朝边界上的水风水利发电站和鸭绿江沿岸的发电设施，所以应指示麦克阿瑟公开宣布，美国没有任何破坏中朝边界上水利发电站设施的意图。在这之前，美国外交部曾通过英国请印度尼赫鲁传话给北京。关于这段鲜为人知的史料，我们可以引证1950年10月24日周恩来在一次会议上的讲话。他说，仁川登陆后，尼赫鲁曾经传话给我们，说美国人不会越过三八线。10月初，美军过了三八线，我曾找印度驻华大使指出，和尼赫鲁说的情况可不一样。不久，英国外长贝文又通过尼赫鲁向我们表示，美国人虽然过了三八线，但距鸭绿江40英里时就会停止。据近年的白宫解密的朝鲜战争文件披露，美国在那时还不打算与中国冲突。在一份美军参联会发给远东司令部文件中明确指出，你们的部队绝对不允许越过朝中边界，而且作为一种政策，在连接中朝边界的地区必须使用韩国地面部队。此外，在三八线以北的军事行动也不包括海空军对中国的领土采取行动。现在中国军队突然出现在北朝鲜，致使美军揣测不定，踌躇不前。 志愿军第一次战役后没有乘胜进逼，而是主动脱离，回撤中还扔下不少武器装备，坛坛罐罐，佯作败退。中国军队在朝鲜北部的群山中突然出现后又突然消失，使朝鲜战争在初冬的瑞雪中更显得扑朔迷离。 11月10日，法国在联合国安理会抛出一个提案，以其进一步稳住中国。美英等6个国家马上举手通过这项决议，是呼吁中国军队撤出朝鲜，并同时向中国保证联合国的政策是保证中国的边界不受侵犯，并充分保证中国人在边界线区域的合法利益。这个合法利益指的就是鸭绿江南岸的朝鲜水风发电厂，它的电力一部分输往中国边境的地区使用。对于这个决议，苏联代表使用了否决权。这是自朝鲜战争以来，苏联第一次也是仅有的一次否决一项提案。后来的历史证明，由于这次否决，迫使才建国一年的新中国和美国在朝鲜半岛上狭路相逢，殊死搏斗，大打一场。 11月23日，麦克阿瑟从东京直接飞到北朝鲜第8集团军临时指挥部。这一天正是西方的感恩节。一个半月前，他在威克岛向他的总统保证说，感恩节前结束朝鲜战争。现在他又把结束战争的最后日期定在一个月以后的圣诞节。这一天的中午时分，他乘一架喷气座机沿鸭绿江飞了一圈，在5000英尺的高空向地面观察。他得出结论说，进入朝鲜的中国军队不会超过3万人，冰天雪地上有10万军队，早应该被空军侦察到了。这时的麦克阿瑟已经拟定好了代号为“最后攻势”的作战计划。这时，仅在朝鲜本土，联合国军总数已超过42万人，其中地面部队33万人，分属第8集团军和第10军。远东空军36600人，作战飞机1100架，远东海军54400人，各型舰支320艘。至11月上旬，美军战线已经推进到分别距鸭绿江30至120公里的地段。北朝鲜政府在仅存的这一贯穿东西、背水无险的狭长地域里，已经失去了有组织的军事抵抗能力。 在此之前，美国空军已经把鸭绿江上的桥梁炸断4座，其余严重毁坏。出现在北朝鲜的中国军队的后勤补给线基本被切断。基于以上兵力、战场及态势的判断，华盛顿旋即批准了麦克阿瑟最后公示的计划。这是美军战地记者在航空母舰上拍摄到的当时美军以每时计算的战争损耗。据战后资料披露，美国当时在并未摸清中国军队的真实情况下，急于完成麦克阿瑟最后攻势计划，是因为它已经耗不起在朝鲜半岛上的时间、人力和财力。 也是在11月23日感恩节这一天，美国军方把国内的歌星请到前线，战场献艺，借此缓解士兵战前的紧张情绪。但是美军那时还不知道，仅一周前，中国人民解放军的第9兵团改番号为志愿军第9兵团，三个野战军已相继入朝。这样，在北朝鲜，中国军队已达到9个野战军，30个作战师，共计38万余人，超出联合国军前线兵力的一倍半以上。此时，他们正潜伏在白色的雪原里，等待着这些沉迷在思乡歌曲中的美国大兵。 当这些美军的军官和士兵按等级每人分享一份分量不等的，但是从美国本土直接空运来的火鸡腿时，他们也许并没有意识到，朝鲜战争才刚刚开始。这时，整个前线的气温骤然下降，气温达到零下20度，交战双方的枪栓都冻得几乎拉不开。在如此恶劣的自然条件下，一场恶战即将展开。 在第一次战役结束时，彭德怀即于11月4日提出如敌再进则让其深入后歼击之。同日，毛泽东批准了彭德怀提出的上述方针，同时还确定第9兵团立即入朝，担任东线方面的作战，转变该线战局。根据这一情况，志司命令东线第九兵团以一部进至旧经理以南布置阻击阵地。命令西线38军以一个师在球场至西川公路上，第42军以一个团在德川至球场的公路上组织运动防御，命令第40军准备由西向球场方向配合第38军夹击敌人。 9日，毛泽东批准了这一部署，并要求志愿军争取在一个月内在东西两线各打一两个仗，歼敌七八个团，将战线推进到平壤至元山间铁路线区域。11月7日、12日、19日，志愿军第九兵团三个军在司令员兼政治委员宋时轮率领下，先后入朝，担任东线作战任务，使志愿军前线作战兵力得到了加强，已达9个军、30个师38万余人，为美军前线地面作战部队的1.72倍。其中东线美军9万余人，志愿军15万余人，西线美军13万余人，志愿军23万余人。东西两线志愿军兵力均占优势。 从11月6日开始，英第27旅、美第24师和美骑兵第一师北渡青川江，作为其发动总攻势的攻击开始线，敌人开始试探性进攻，中国军队，节节阻击，诱敌深入。11月9日，西线中国军队主动放弃飞虎山一线阵地，东线中国军队也于7日放弃黄草岭。16日志司电令各军继续北撤，并停止向进攻之敌进行反击。这时美军果然为志愿军后撤的行动所迷惑，错误的判断志愿军是怯战退走，并断定志愿军的兵力最多不超过6至7万人。11月21日，西线敌军已进至其预定的发起总攻势的攻击开始线，完成了战役展开。当西线美军推进至其攻击开始线时，麦克阿瑟于24日发表公报向全世界宣布他们已经开始发动“圣诞节结束朝鲜战争”的总攻势。 西线志愿军第50、第66、第40、第38、第42军主力已全部转至预定的集结地域。东线志愿军第9兵团3个军、12个师也已全部秘密的完成了战役集结。当天，麦克阿瑟乘飞机亲临前线指挥，与东西两线对志愿军展开了全面进攻。11月25日黄昏，西线志愿军第38军、第42军和第40军在正面各军积极配合下，趁敌立足未稳，出敌不意的首先对德川、宁远地区的南朝演军第6、第8两师发起攻击。第38军以3个师分三路穿过南朝鲜军两个师的结合部，由新平里涉过大同江，击破了南朝鲜第6师一个团的阻击，于26日到达德川以南遮日峰，切断了美军南逃退路，从而完成了对德川之敌的包围。 志愿军第42军以第125师和第124师从正面和侧后对南朝鲜第8师实施攻击。志愿军第40军主力配合第38军方向作战，于25日晚向美第2师发起进攻。中国军队在青川江以东发动反击后，美军基本上停止了在原地同中国军队对峙，志司估计西线敌人有极大可能退向青川江南岸。志司遂命令第38军、第40军以主力迂回截断美军退路，命令第39军、第50军、第66军从正面分三路攻击美军。 27日晚，西线中国军队开始按照部署行动，第39军、第50军、第66军从三面逼向美军，第38军，14小时行军140里，于28日晨切断了美第9军逃跑的退路，打乱了敌人的整个布置。 29日，西线美军开始实施全线退却，同时美骑兵第1师及位于平壤地区的英第29旅各一部向北增援接应，猛攻志愿军38军113师，企图打开通路。12月11日美军突围无望，为摆脱被歼命运，被迫遗弃大量辎重装备，于8时开始转向安州方向突围。中国军队各部乘机各个歼击。第40军紧紧尾追，突围的美军于当晚占领安州，第42军未能按时切断突围美军的退路，使美军趁机退向平壤。 原子弹 11月28日晚，美第8集团军军长沃克和第10军军长阿尔蒙德被仓促招到日本。麦克阿瑟召开了一次紧急作战会议，对25日开始的最后攻势。三天之后如此惨败，美军可以说是毫无思想准备了。会议从28日的21:50持续到29日凌晨1:29，茫无头绪。最后麦克阿瑟决定第8集团军在必要时准备撤退。第10军紧急收缩阵地，全线由进攻转入防御。 在美国本土，华盛顿美国军方最高决策机构参谋长联席会议也正在紧急磋商朝鲜战局。这一次参联会没有按照惯例向其下属的远东司令部下达具体作战指令，他们自己也在惶惶之中，毫无良策，所以仅是向麦克阿瑟谨慎的建议，在朝鲜半岛蜂腰部的地段建立一条横贯东西的防线，在那里堵住中国军队。麦卡阿瑟断然否决，他说，一线摆开，7个美军师，每个师要分担20英里宽的防线，最终要被各个击破。麦克阿瑟实际上还做着另一手准备。 28日上午，也就是东京紧急会议之前，麦卡阿瑟就已经急电蒋介石，要求他派出国民党52军急赴朝鲜战场，并同时告知他已命令美军派出飞机和舰船直往台湾，从空中和海陆接运该军至朝鲜平壤。蒋介石接电后，当天下午在阳明山召开紧急军事会议，随即命令52军24小时内完成作战准备。第二天凌晨，奉命派出的美舰已分别从冲绳和菲律宾紧急起航。当美军参联会和远东司令部在相距1万多公里的两地讨论在朝鲜半岛建立退守防线时，国民党军先遣代表团已飞抵汉城开始与美方接洽52军入朝后指挥作战、补给等问题。第三天11月30日，美军运输机和运输船均已抵达台湾，随时准备运送整装待发的国民党52军。 就在这一天，杜鲁门在白宫发表讲话，他承认“我们可能要节节败退”，但他又声明，“联合国部队不打算放弃他们在朝鲜的使命。”这时有记者问他，“总统，您对朝鲜的事态打算如何应付？”杜鲁门答，“我们将采取必要的步骤。”记者追问，“那是否包括使用原子弹？”杜鲁门犹豫一下说，“包括我们所有的武器。”记者又追问，“总统，您说的包括所有的武器，是否包括原子弹？”杜鲁门一下亮了牌，“我们一直在积极的考虑使用原子弹。”这个头号新闻立即传遍全世界，全世界的舆论都在谈论的一个话题，那就是第三次世界大战。 事后美国白宫发言人又发表了一个声明，力图准确的说明杜鲁门原话的真实意义。这是当时的电视镜头，但这为时已晚，全美国已经陷入到一种激动不安的气氛之中。美国陆军在朝鲜遭到有史以来最大惨败之后，美国公众又听说总统要使用原子弹，一时间舆论大哗，有褒贬，有责难，有的干脆指着鼻子骂娘。 英国首相爱德里匆匆赶到美国，西方盟国都显得惶惶不安，他们担心朝鲜战争的升级会影响美国在西欧的军事势力，以至于苏联人乘虚而动。杜鲁门最后私下里向爱德里保证说美国不会削弱在西欧的军备，同时在朝鲜不会使用原子弹。朝鲜前线美军不可挽回的颓势所导致的美国外交上的困境，促使杜鲁门最后拍板美国决定战略总退却。 12月6日，美国通知台湾蒋介石取消52军驰援朝鲜的行动计划。12月8日，麦克阿瑟将总撤退计划拟成命令下达全军。按照计划，第8集团军放弃平壤，一直后撤到三八线以南。第10军从元山港撤退，用船运至釜山。从战后披露的美军资料看，当时还有另一个撤退方案，即第8集团军撤到汉城后，随即从仁川登船，第10军从元山登船。两军全部撤回到日本。但是，杜鲁门和爱德里最后商量决定，“绝不主动撤出朝鲜，除非被打出去”。美军大步回撤，在于尽快脱离接触，以使在三八线以南站稳脚跟，重新建立新的防线。毛泽东看准这一点，即电彭德怀以三个的兵力尾追上去，穷追猛打，促其溃散。12月5日，志愿军39军116师相继攻占平壤，收复了北朝鲜首都。 美军的机械化在撤退中占了优势，跑得比兔子还快。12月12日，美第10军的人员和装备从元山起航后撤，乘用75艘货轮、15艘运输船、40艘坦克登陆舰，总吨位达到40万吨。这是美军在志愿军第二次战役后退回三八线以南时的真实镜头。 正当联合国军急促退过三八线的时候，朝鲜战争的舞台上又出现了一个角色：中立的印度。平壤易手的第二天。12月7日，印度驻华大使潘尼加当面向中国外交部副部长张汉夫递交了一份备忘录。潘尼加称，13个亚非国家联合倡议先在三八线停战，而后举行有直接关系的各大国会议，和平解决朝鲜问题。这位大使还解释说，这是所有非欧非美国家第一次联合起来提出的建议，所以不能认为是支持美国的。如果中国政府宣布不越过三八线，将得到这些倡议国道义上的支持。他同时还表示，几天之内，印度将向联合国提出这项提案。中立国突然插手斡旋，反而使得中国左右为难，拧腕棘手。 周恩来马上派外交部亚洲司司长约见了印度使馆参赞，向他提问，为什么在美军打过三八线的时候，13国不讲话？为什么13国不宣言从朝鲜撤退外国军队？为什么13国不反对美国对朝鲜和对中国台湾的侵略？7天以后，12月14日，第五届联合国大会将印度提案一分为二。第一提案是要求交战双方在朝鲜停战，以51票获得多数通过。第二提案是召开国际会议，和平解决朝鲜问题被无限期搁置，美国终于有了喘息的机会。 第二天，即12月15日，杜鲁门发表了广播讲话。他说，“现在我哈里杜鲁门美利坚合众国总统正式宣布国家进入紧急状态。”他同时宣布实行扩军计划，使美国军队增加100万，飞机和坦克增加5倍。战后历史学家指出，1950年末美国实际已经进入战争状态。杜鲁门唯一尚存的理智是他没有正式对中国宣战，而当时在中国正掀起一场轰轰烈烈的抗美援朝运动，中国实际上也已进入了战争状态。据战后资料披露，中国在派出志愿军的时候就已经做好了对美国宣战的准备，但最终美国没有宣战，18个卷入朝鲜战争的国家都没有宣战，这在人类战争史上是史无前例的。现在影片记录的是当时新疆人民送子弟参加抗美援朝战争的情节。 新中国开国即开始的这场对外战争，牵动着全国人民的心，他们决心保卫自己的土地，保卫自己的祖国，保卫自己的和平生活。12月中旬前后，志愿军后续部队源源过江。我们在各种影片资料中最常见的这个镜头并不是志愿军10月下旬入朝时的情况，那时是秘密的，而这时已是大张旗鼓。 12月11日，周恩来会见了印度大使，周恩来对他指出，实际上也是让他给美国传个话。周恩来说，因为美军已经越过了三八线，因此三八线现在已经不复存在。言外之意很清楚，中国不能宣布不越过三八线。据战后资料披露，在周恩来讲这个话的前7天，也就是印度大使向中国外交部递交备忘录的前几天。中国政府曾作出决定，打到三八线后停下来，准备休整。但一个星期以后，印度横插一杠，联合国决议，中国必须在三八线以北停战。中国一下子被激怒了，既然联合国已组成军队与北朝鲜和中国作战，联合国就是交战一方，敌对双方的一方，有什么道理限制另一方的行动？ 12月13日，毛泽东电令志愿军要克服一切困难和忍受一切困难，坚决打过三八线。毛泽东在电报中告诉前线指战员，哪怕是打过线不远再休整，也要坚决过线。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-抗美援朝（一）","slug":"共和国战争-抗美援朝（一）","date":"2023-06-17T10:07:46.000Z","updated":"2025-09-16T02:08:42.967Z","comments":true,"path":"2023/06/17/共和国战争-抗美援朝（一）/","link":"","permalink":"https://naosense.github.io/2023/06/17/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E6%8A%97%E7%BE%8E%E6%8F%B4%E6%9C%9D%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"40多年前，在亚洲，在三面临海、一面隔江的朝鲜半岛上，18个国家同时卷入了一场战争。中国在百年屈辱的历史长河中，第一次成为那场战争的真正主角。她的上百万儿女与世界上最强大的对手生死搏杀，历时3年，曾几次几乎突破朝鲜地域的概念，生成一次新的世界大战，最后终于在全世界的关注下，迫使对手停下了那场至今没有结局的战争，以致使世界历史进入了跨度30多年的冷战时代。也正是由于这场战争，使中国在历史面前从屈辱走向尊严，开始走向民族的中心。 我们在搜寻有关这场战争的电影资料时，惊异地发现了这样一组镜头，其实是中国观众非常熟悉的一个片段，这记录的是1949年北京和平解放时，两支军队正在交接城防。进城的部队，是戴着狗皮帽子的从塞外浩浩荡荡进关的东北野战军的胜利之师。而同时出城的部队，是成瓮中之鳖后被迫起义的国民党的傅作义集团的败军之将。一年之后，这两支部队同时奉国家之命，先后入朝作战，英勇之至。经过考证，这支在西苑机场受到毛泽东检阅的进城部队，就是首批入朝的中国人民解放军第13兵团。那支出城的部队当时正在北平郊区接受整编，而后定编为解放军第23兵团。 这就是我们这部片子所追溯的全部主题，中国，特别是她的近代历史以来，第一次以一个完整的国家形象同仇敌忾，共敌外侮，回首那场发生在40年前的战争，许多历史的悬疑至今困扰着人们。澄清它的来龙去脉，从战争的第一天起，西方各国就认定中国参与预谋那次战火的发端。与之巧合的是，毛泽东的确在开战前三个月访问过莫斯科，在中国也同样认为是美国一手挑起了那场欲亡中国的大战。近年，白宫已将朝鲜战争的档案全部解密，从历史资料判明，美国是在开战后仓促中开动战争机器的。近年来，中国许多亲历那次战争枢密的当事者在回忆录中也都阐明，中国是在战争爆发的当天与全世界一样，从外电获知她的北方邻国发生了战争。如果这些都是事实，应该说是历史把中国和美国的必然碰撞放在了1950年，朝鲜战争爆发时，新中国建国伊始解放战争尚未结束，中国人民解放军的主力还分布在国土四疆，其第一野战军尚在进军新疆的途中。当时中国的西北还是地方土匪割据的天下，第二野战军正挺进在大西南的丛山里，准备进入西藏。第三野战军正在东南沿海与国民党军进行着争夺岛屿的作战。第四野站军在一个月前的5月份，刚刚结束了解放海南的战役。中国自1911年辛亥革命到1949年成立共和国38年间，内战外患从未间歇。新中国初创，就其国力而言，完全无意也无力打一场对外战争。况且当时分布在西北、西南、华东、中南各省结合部、偏僻山区，还有100万以上的国民党残匪尚未肃清。这是法国记者拍摄的淤塞在中国边境地区的成千上万国民党残兵败将的镜头。 可以说，在中国的内战尚未结束时，朝鲜战争突然爆发了，爆发在新中国开国的第八个月，爆发在新中国正在百废待兴之时，爆发在自鸦片战争以来，历经百年国耻的古国，刚刚把一切帝国主义残渣余孽统统赶出大陆，其灾难深重的人民正要挺直腰杆的时候。现在，就让我们把这个故事从头说起。 这是一条军事分界线演变成的国家边界线。这也许是世界上最荒谬的分界线，它不是按照山川河流的走向、传统习惯的沿袭以及行政管辖的范围而划分的。它是按照地球仪版图刚才标有的经度和纬度，在大地上画出的一条界线。它横穿朝鲜半岛，人为的把一个完整的高丽民族分割成两个截然不同的国度。 历史学家认为正是它源起了40年前的朝鲜战争。政治学家认为，可能正是它还要源起一场朝鲜半岛的战争危机。 1945年2月，第二次世界大战已进尾声，美英苏三国首脑在苏联克里米亚半岛的雅尔塔聚会。美苏两国首脑在雅尔塔签订秘密协定，协议结束欧洲战争后共同对日本作战。双方的交换条件是美国单独占领日本，苏联则恢复19世纪除日俄战争中俄国在远东所丧失的一切权益。对夹在远东和日本之间的朝鲜，雅尔塔文件中是这样记录的。 罗斯福总统说，在他的心目中，朝鲜要由一个苏联代表、一个美国代表和一个中国代表进行国际托管。他认为托管期也许要20年到30年。斯大林元帅说，托管期越短越好。同时他询问是否有什么外国军队将进驻朝鲜。罗斯福总统回答说，没有。对此，斯大林元帅表示同意。于是，在20世纪被日本沦为殖民地的一个有着5600万人口的朝鲜民族，就这样在20世纪中期又被另外两个大国决定了它未来的命运。雅尔塔会议3个月后，苏军攻克德国首都柏林。在苏军胜利阅兵式尚未举行时，斯大林即命令从欧洲前线抽调25个师赶赴远东。 这时，美国和日本在太平洋上进行着殊死的海战。当苏军在中苏边界地带已集结了近200万兵力的时候，美国已攻占了距离日本本土1000公里的冲绳岛。这样，苏联出兵远东攻击日本关东军，美国两栖登陆近战，日本本土的联合作战态势已经形成。 从目前解密的美苏两国军事资料来看，在美苏联合对日作战之前，苏军参谋总部和美国参谋长联席会议就不约而同地把注意力从远东和日本延伸到了朝鲜。在他们各自拟定的作战计划中，又都不约而同地突破了两国首脑在雅尔塔达成的国际托管的形式。1945年8月，在对日本联合作战的前一周，美英苏三国首脑再次聚会于柏林近郊的波兹坦，公布了《波兹坦宣言》，最后通牒日本无条件投降。 这时苏军总参谋长才通知美国：苏联对日宣战后将进攻朝鲜。其实那时美国已授权太平洋战区司令麦克阿瑟把朝鲜汉城和日本东京等同对待，首先加以占领。8月5日，美国总统杜鲁门在从波斯坦返航的巡洋舰上下了一道命令，当夜，3架B29重型轰炸机从太平洋上一个叫提尼安的秘密基地起飞，航向日本。在其中一架飞机上，美国安放了一颗在此之前世界上几乎无人知晓的新式炸弹，这就是原子弹。这时的美国想借一两颗原子弹的威慑，震撼日本，无条件投降。 美国投下这颗原子弹的时间，比波斯坦会议拟定的苏军对日本发起攻击的时间提前了整整半个月，美国甚至希望拒绝苏联对日参战，以至拒绝苏联与它均沾远东的利益。在波斯坦会议上，双方的军事代表在地图上画出的两军的分界线，是一条横穿中国满洲的红线，规定红线以北是苏军接受日本投降的地区，这一地域不包括朝鲜，朝鲜被空了出来。 现在我们看到的镜头是当时美国向日本投下原子弹的真实镜头。 8月6日上午9点，美国第一颗原子弹降落在日本广岛。三天后，8月9日，第二颗原子弹又降落在日本长崎，日本没有投降。 就在这同一天的零时，苏联200万大军从三个方向上越过中苏中蒙边界，向日本关东军发起了总攻，这是当时苏联向日本宣战的真实资料镜头。 战争形势的瞬息演变，倒使美国一下子手足无措起来。仅一天之后，即8月10日，日本即将崩溃的迹象已渐显现。在美国本土华盛顿，陆军部作战处的参谋人员奉命立即起草接受日本投降程序的总命令。起草人是一名叫伯尼斯迪尔的上校军官，在那天深夜，他仅有30分钟时间起草第一段落，因为总参谋部和国务院陆军海军协调委员会正急切的在白宫等待着批准这一命令。当时伯尼斯迪尔上校非常清楚，苏联军队可以在美国军队未到之前完全占领朝鲜全境，因为距离朝鲜最近的美国军队也在1000公里远的冲绳岛，美国所面临的问题是如何拟定一个苏联人所能够接受的军事分界协定，而又能阻止他们独吞整个朝鲜半岛。开始，他设想受降界限以朝鲜的行政区域划分，但他办公室墙上那张地图是世界地图，没有朝鲜行政区划。于是他盯着地图注意到北纬38度线差不多正好从朝鲜中部穿过，一半对一半，无论是杜鲁门还是斯大林都应该乐于接受。于是伯尼斯迪尔上校把北纬38度线作为受降区域的分界线写进了第一号总命令中。 8月11日凌晨，当这个三八线草案送达白宫讨论时，苏联海军已在朝鲜东北部的元山港登陆。这个时候，美国海军部又建议把军事分界线建立在北纬39度，这样就可以把中国辽东半岛的大连港划入美军占领的范围内。但白宫认为苏联不会接受这个方案，而且美国军队要在苏联之前到达那里也完全是不可能的。在美国还在讨论军事分界线的时候，8月12日，苏联对日开战的第三天，苏军已从西伯利亚的滨海省向朝鲜半岛倾巢出动，其前锋已达汉城以南的开城、春川一线。 8月15日匆忙之间，由于东西半球的时间差，美国总统签署的接受日本投降的总命令竟早于日本天皇录音广播的投降诏书提前发布。 华盛顿等待着莫斯科对美国命令的反应。熬过了一段焦躁不安的时间，让白宫庆幸的是，克里姆林宫第二天即发来回电，没有对三八线方案提出任何异议。这样，美军第一支先遣队才得以在20天后于9月4日在朝鲜半岛登陆。与他们所预料的相反，苏联人没有占领南朝鲜首都汉城，严格遵守了美国人提出的三八线方案，美苏两军在朝鲜半岛的三八线上胜利会师。从此确定了这条从不同角度越过高高的山脉，截断了12条河流，穿过了284条土路、23条公路和6条铁路的人为臆造的分界线，朝鲜被拦腰切断。 平壤与汉城 1945年9月开始，美国陆军在朝鲜南半部接受日本军队投降。随后，美国把流亡在中国重庆的朝鲜临时政府运送回国，但每个回朝鲜的人都要签署一项拥戴美国占领军的声明，早一步进入朝鲜的苏联军队这时已经封闭了整个三八线以北地区，随苏军入朝的是数以万计的抗日期间在苏联居住学习的朝鲜劳动党流亡者。 三个月以后，美国仍然坚持它的国际托管原则。12月下旬，美国促成与英国、苏联三国外长在莫斯科制定了一个包括中国在内的四国对朝鲜进行为期3年的托管协议。消息传到了朝鲜，南方发生了骚乱，美国占领军进行了残酷的镇压，朝鲜人开始把美国看成是第二个日本。 在同一时间里，朝鲜北方实施了土地改革，千百万农民第一次获得了自己的土地，他们由衷的感激苏联培植起来的北朝鲜政府。这时苏联开始撤出了大部分驻军，这样一来，整个1946年期间，在朝鲜比较被动的倒是美国，美国占领军成了南朝鲜人民反抗新的外国统治者的目标，为此南方政府颁布了军事管制法，但这样更加引发了频繁的暴乱。1947年，美国开始改头换面，它以一个新的面貌出现，这就是一年前在美国华盛顿成立的联合国组织。10月份，美国在联合国提出议案，建议于次年3月31日以前在朝鲜南北同时进行选举，由联合国监督建立统一的朝鲜。这个议案被通过。 1948年5月，联合国坐镇朝鲜开始进行选举，北朝鲜宣布既不参加也不承认选举结果。8月15日，南朝鲜单方面选举了李承晚为国号“大韩民国”的总统，联合国随即接纳它为联合国成员国。这是美国太平洋战区司令麦克阿瑟亲自赴汉城参加南朝鲜总统李承晚就职典礼时的资料镜头。 不到一个月，9月9日，北方自己选举了金日成为国号“朝鲜民主主义人民共和国的”主席。苏联及东欧各社会主义国家立即予以承认。一个有着近2000年文明史的民族，一个有着1200年统一史的国家，就这样在一个月之中分裂成两个互相敌视的仇国。第二次世界大战后，世界上有两个国家落下如此命运，一个是战败国德国，一个就是可怜的朝鲜。1948年12月31日，苏军全部撤出了北朝鲜。半年之后，1949年6月30日，美军全部撤出了南朝鲜，这时朝鲜半岛一下子被抽成了真空，两个大国留下了两个互相敌对的政权，任何外部压力都会使之破裂，朝鲜半岛的战争正是来源于此。 6月25日 1950进入时的朝鲜已迥然相异。五年之中，两个不同意识形态的政党在狭小的半岛上组成了两个不同社会制度的政府，而两个仇视的政府后面又分别屹立着两个敌对的大国。内战的危险每一天都存在，从已经解密的美军军事情报中可以看到，1950年初美国在加紧向南朝鲜调运军事装备时，已经注视到了三八线以北异常的动态。美国陆军部二处在开战前一个月5月份的情报中指出，三八线以北两公里范围内所有居民已经疏散，铁路的民运、货运业务已全部停止，仅供军需运输。边境地区有大批武装部队集结。其远东司令部情报处的谍报中已经明显判明，北朝鲜入侵南朝鲜的时间可能从3月或4月推迟到6月。而这时，美国人做了一个使南朝鲜大为震惊的举动。1950年1月12日，美国国务卿艾奇逊在华盛顿国家新闻中心发表演说时说，美国在远东的防御战略把朝鲜和中国的台湾划在了美国的防卫线之外。 李承晚吓得出了一身冷汗，他亲自飞到日本东京，当面质问美国太平洋战局总司令麦克阿瑟。当时许多西方观察家指出，这等于明白无误的告诉苏联和北朝鲜可以放心大胆的去占领大韩民国，于是朝鲜半岛的局势更趋紧张。 但40年后，历史学家分析说，美国当时这样做正是为了缓解远东的紧迫压力，才抛出了南朝鲜和台湾。当时美国的全部紧迫感都集中在西欧。这就是今天我们从已经解密的美国国家安全最高机密的68号文件中看到的。这份文件的主体和关键内容就是美国要不惜一切代价全速加强西方防务，加强美国和西方盟国在欧洲的军事势力。 但是我们在追溯朝鲜战争缘起的真实历史成因时，不能不披露另一个秘密，这就是斯大林的秘密。斯大林同样为了缓解苏联在西欧的紧迫压力，与北朝鲜金日成有过这么两次秘密会见。 斯大林之后的苏联领导人赫鲁晓夫，在他的回忆录中是这样记述的：“大约在1949年底，我从乌克兰调到莫斯科的时候，金日成率领代表团前来与斯大林会谈，北朝鲜人要用武力解决南朝鲜问题。金日成说，第一仗就会触发南朝鲜的内部爆炸，斯大林劝金日成好好考虑一下，然后带着具体打算再来。金日成回去了，当他把一切详细拟定好了之后，又回到了莫斯科，他对斯大林说，他一定会胜利的。在斯大林别墅里举行了一次兴致极好的宴会，预祝金日成胜利。到了预定的时间，战争打响了。” 赫鲁晓夫在回忆录中没有讲明预定的时间是几月几日，朝鲜战争爆发的时间是6月25日，而就在6月18日，一个名叫杜勒斯的美国大人物恰巧撞进了那个敏感的时间区。当时他在三八线上举起望远镜向北方窥视，这一切都被拍成了新闻照片。七天之后，战争突然爆发了。这个镜头被所有共产党国家的报纸所登载，被认定是美国发动了这场战争的确凿罪证。杜勒斯3年后成为美国国务卿，但当时他还仅仅是个美国共和党的外交发言人。美国事后解释说，当时杜勒斯是赴东京与麦克阿瑟讨论对日合约问题的，顺道访问汉城时被邀请到三八线看一看。有记者说，没想到他第一个代表美国卷入了那场战争。 1950年6月25日凌晨4点，战争打响了。上午9点，平壤向全世界播发了一条电讯：“南朝鲜伪政府的所谓国防军于6月25日佛晓在三八线全县地区向三八线以北开始了出其不意的进攻。朝鲜民主主义人民共和国内务省已命令共和国警备队击退入侵三八线以北地区的敌人。现在共和国警备队正开展着激烈的防御战争抵抗敌人。” 联合国军 这时，战争已经打响了5个多小时，美国在东京的远东司令部才获得了一条内容与北朝鲜政府截然相反的讯息。汉城的美国武官处报告说，北朝鲜主力已经全线越过了三八线。90分钟后，这一重大军情传回华盛顿。在西半球的美国，时间是星期六之夜，杜鲁门还在密苏里州他的家中度假。而这时，美国新闻界已经早于总统闻风而动，美国立刻要求联合国安理会迅即赴会。美国时间6月25日下午2点，战争打响整整24小时后，安理会召开了紧急会议。令人瞩目的是，苏联代表缺席。苏联缺席的原因当时被解释成是因为5个月之前，苏联曾提出一项恢复中华人民共和国在联合国合法席位的提案，遭到了否决。苏联代表团当即宣布退席，表示不再参加以后的会议。一个月以后，在讨论朝鲜战争的关键会议上，由于苏联的缺席没有使用否决权，致使联合国听任美国一手操纵，以致组成联合国军卷入一个内战的朝鲜。这是记录苏联宣布退席那一时刻的历史镜头。 6月25日的安理会以9票赞成，0票反对，通过美国提案，南斯拉夫弃权。由此联合国裁断朝鲜正在爆发的不是内战，而是北朝鲜对世界和平的威胁。 在安理会作出决议4个小时以后，杜鲁门召开了一次由正副国务卿、国防部长及包括陆海空三军全部首脑参加的会议。会议决定：命令远东的麦克阿瑟以所有能动用的武器弹药供应李承晚，命令远东的空军和海军立即出动，给予南朝鲜部队以有效支援。命令美国第七舰队进入台湾海峡，阻止中国可能同时开始的对台湾的进攻。 现在我们可以回过头去读一下40年后苏联老资格的外交部长格罗米科写的回忆录中的一个片段：“1950年，南朝鲜傀儡政权在华盛顿纵容下发动了战争，安理会立即召开了会议。斯大林看了苏联驻联合国代表马立克从纽约发回的电报后，晚上打电话给我，说：‘你认为目前情况下应该下达什么指示？’我说：‘马立克应该使用否决权阻止通过这类决议。’斯大林说：‘我认为苏联代表不应该参加安理会会议。’我不得不提醒斯大林注意一个重要情况，如果我们的代表不出席会议，安理会就可能通过任何决议，直至打着联合国军的旗号，从其他国家派遣军队到南朝鲜去。但是40分钟后，斯大林还是口授了一项指示：‘苏联拒绝赴会。’”格罗米科在回忆录中也提出了疑问，他写道：“这件事似乎不符合斯大林的思维方式，但事实正是如此。” 在历史的进程中，事实也正是如此。美国不但卷入了朝鲜战争，也卷入了中国的内政即台湾问题。由于美国第七舰队进入台湾海峡，致使中国无限期的推迟了计划。在此半年前，中国人民解放军已经开始了扫清台湾前沿的金门战役，虽然严重受挫，但更大规模的海战准备正在筹措之中。美国对朝鲜问题的卷入，使盘踞于孤岛上的蒋介石得以苟延残喘。 也正因为这样，在朝鲜战争爆发的第三天，迫使新中国也介入朝鲜问题。6月28日，毛泽东在中央人民政府的会议上严肃指出：“全世界各国的事务应由各国人民自己来管，亚洲的事物应由亚洲来管，而不应由美国来管。”他第一次提出一个口号，即“全世界人民团结起来，打败美帝国主义”。 6月27日半夜10:55，联合国安理会又紧急通过一项美国提案。这项以7票赞成、南斯拉夫1票反对、埃及、印度弃权的决议，公然建议“所有联合国成员国向大韩民国提供为击退武装进攻所必须的援助。” 仅仅一天前，格罗米科在电话中向斯大林预言的严重情况，这时终于出现了。联合国组成了联合国军。当这项决议在联合国举手通过的24小时后，在战争打响的第三天，北朝鲜军队攻克了南朝鲜的首都汉城。 在汉城陷落的第二天，麦卡阿瑟，这个一生都在演戏的美国五星上将，乘坐一架双引擎飞机，带着5名参谋人员和4名记者，从东京直接降落在汉城以南仅50公里处，一个叫水原的地方。然后，他带着等在那里的南朝鲜总统李承晚和美国顾问团的将军，驱车北进，直抵最前沿阵地。 在那里，他听取了美国顾问团的报告，报告说：“目前南朝鲜有效的防御已经不存在了，10万大军已经溃散，大部分混在难民群中仓皇南逃。国防部能及时调用的部队为8000人，另外还有8000人渴望在当天傍晚能够收拢，用这1万多人抵抗近10倍的北朝鲜军队，等于是以卵击石。” 麦克阿瑟下午返回水源机场，即刻向华盛顿派发了一封他个人的报告。报告说：“驻守目前阵地的唯一保证和收复失地的唯一途径，势必通过美国地面作战部队介入朝鲜战争。假如没有一支有战斗力的地面部队而继续使用海军和空军，就不能取得决定性的成果。假如授权于我，我的意图是立即调动美国团级战斗部队，用以加强关键地区，并从驻日部队中提供两个师的兵力，以便能尽早进行反攻。” 这份报告于当天午夜前一个小时电传到华盛顿，4个小时后即得到了杜鲁门的批准。一个小时后，陆军部发布总统的命令，又迅速传回东京。命令说：“你关于向战场调动一个团级战斗部队的建议已获批准。”当天，迈克阿瑟即命令美国陆军第24师从日本调往朝鲜。两天后，即7月1日、2日从日本本土上调动的一个营的美军约600人在朝鲜南部港口釜山的空降机场登陆。这支先遣部队隶属美国陆军第24师21步兵团，指挥官是史密斯中校，配属给这支队伍的是52野战炮营的一个分队和中型坦克营的一个连。登陆两天后，他们到达指定地域，马上开始了掘壕布雷预设阵地。与此同时，美军24师的余部、第34和第19步兵团及21步兵团的另外两个营也火速调往朝鲜战区。这样，至7月5日前，也就是麦克阿瑟视察朝鲜的第五天后，美军已经有一个完整的作战师从日本陆续进入朝鲜。 7月5日清晨8点，北朝鲜军队的30辆T34坦克及后面跟随的步兵出现在美军先遣部队的阵地前沿。美军和北朝鲜军队在这个称为武山的地方展开了第一次交锋。美军虽然占有绝对的空中优势，但在北朝鲜两个主力师面前，美国陆军仅为一个加强营，战斗前他们显出了无知的狂傲。 美军士兵普遍认为，北朝鲜军队只要一见到美军就会吓得扭头就跑。战斗很快打响了，这是二战后美国第一次和亚洲人打仗，而这时吓得扭头就跑的不是北朝鲜人，却是美国士兵。这支600人构成的美国阻滞防线，在北朝鲜军队第一次冲击时就土崩瓦解。按美军公布的大大缩小了的数字，当场阵亡的就有150人，跑出来了约200人，其余全部失踪。 北朝鲜军队3天攻克汉城后，7天又突破了南朝鲜的水原防线，大军进逼朝鲜南部的中心地带，李承晚临时首都大田。 麦克阿瑟立即命令当天下船的第24步兵师在大田一线迅速展开阻击防御，同时命令动用一切运输舰支，并征用日本货船再运第25步兵师和机械化骑一师入朝参战。又命令抽调第7师骨干力量，补充以上两个师的缺额，保证齐装满员，这样美国在日本的占领军，共计4个师的第8集团军，除第7师剩了个空架子留守日本外，其基本主力从7月7日至20日的13天里已全部调入朝鲜。这支部队是第二次世界大战中美国在太平洋战区的王牌部队，曾对日军进行过60多次水陆两栖攻击作战，参加过攻占菲律宾的战役。此时进入朝鲜总兵力接近10万，与北朝鲜的10万大军已成均势。 当美国加紧调兵遣将时，7月7日，它的盟国英国和法国向联合国安理会递交了一项提案，联合国大会当天就以7票对0票获得通过，埃及、印度、南斯拉夫弃权。这项决议非常明确，要求美国杜鲁门总统作为安理会执行代表，具体实施联合国在朝鲜的行动，即凡投赞成票的成员国所提供的部队要在美国的统一指挥下作战，由美国选择一位指挥官，并授权这支军队使用联合国的旗帜。苏联仍然缺席这次至关重要的会议，没有使用否决权。在朝鲜战争出现了复杂国际背景的情况下，金日成从平壤赶到前线，亲自指挥督战。 7月20日，北朝鲜军队以第一、二军团实为6个师的作战兵力，发动了继汉城水原后的第三次战役总攻。仅一天时间，大田的防御即被中央突破。美军第24师从大田撤退，整个师的伤亡达到30%。在历时17天的战斗中，他们丢失了220余门火炮、20多辆坦克、1300多辆汽车和足以装备一个整师的物资，被追赶了160公里，回撤到釜山地区。北朝鲜主力穷追不舍，继续南进。 这时，朝鲜半岛的军事形势已经很微妙了。由于大田防线迟滞了北朝鲜军队南进速度，刚刚登陆的美军主力已争取了展开和部署的时间。在大田战役中，美24师师长上任18天的迪安少将被俘，这是朝鲜战争期间，美军被俘的军衔最高的军官。 大田战役三天以后，7月24日，麦克阿瑟授权在日本东京成立联合国军总部，美军远东司令部的所有军职人员同时被指定在联合国军司令部担任相应职务。美国国务院明确要求有关朝鲜前线的军事报告每周一次送联合国安理会，以期让全世界注意，美国在朝鲜是为联合国而战，并非为了美国。 大田丢失的第七天以后，麦克阿瑟感到朝鲜局势已经进入了关键性阶段，他再次亲临朝鲜，明确告诉第8集团军司令沃克中将，美国在朝鲜不存在撤军的可能，不存在英国的敦刻尔克。两天后，沃克发布了一道命令：“第8集团军不再撤退，因为他已无路可退。每一个士兵必须在目前的战线上要么顶住，要么战死，别无选择。”于是，美第8集团军被压缩在朝鲜半岛东西与仅存的一块立锥之地上，决定着美国在朝鲜的最后命运。这条美军的防线主要位于洛东江天险西段，并从釜山呈扇形展开，从北到南约160公里，这就是后来在战史上著称的“釜山环形防线”。 在同一时刻，一直密切注视着朝鲜局势的毛泽东似乎已经看到了什么，他又一次查询了中央军委部署。早在7月7日朝鲜战争突发的第12天，中央就已决定，空余中原的战备总预备队、三个野战军和3个炮兵师全部调往东北，组成东北边防军。此时，驻河南信阳的38军、驻漯河的39军、驻洛阳的40军以先后近抵中朝边境的鸭绿江畔。 军委炮兵第一、第二和第八3个师和3个高炮团、3个汽车团及战防战车工兵团也相继进入集结地域。原在黑龙江已集体转业准备从事军垦的第42军也同时奉调丹东前沿。这时美国也开始全国征兵。7月下旬，美国国内主力部队仅保留一个空降82师，其第二、第三步兵师、海军陆战第一师共计8万补充兵力陆续起运远东前线。 在7月7日联合国大会上投赞成票同意用武力反击的国家中，有14个国家已决定向朝鲜派兵，它们是英国、法国、澳大利亚、加拿大、新西兰、荷兰、希腊、比利时、卢森堡、泰国、菲律宾、土耳其以及哥伦比亚、埃塞俄比亚。它们将分别提供海军、空军和战勤保障部队。其中地面作战部队主要是英国和土耳其的两个步兵旅，计25000人。这时，台湾的蒋介石也通过在华盛顿的大使向联合国通报，准备提供33000名士兵的地面作战部队。但是美国担心，一旦国民党中国卷入朝鲜战争，共产党中国也就可能马上卷入战争，所以杜鲁门婉辞予以谢绝。 但节外生枝的是麦克阿瑟，在7月30日，继他在视察南朝鲜的第二天，率领16名高级军事官员专程访问了台湾。两天之后，他回到东京时公开对记者说，他和蒋介石探讨了国民党军队入朝参战的事宜，杜鲁门得知此事大为光火，立即委派参谋长联席会议的科林斯上将飞抵东京，警告麦克阿瑟涉及中国台湾的一切有关事宜一律提交国务院，接不接受外国政府提供军事援助的决策，最好由华盛顿的最高层来决定。 这时苏联似乎也看出了朝鲜局势中凶险不测的端倪，所以趁着8月份正好由苏联轮任安理会主席的机会，于8月1日重返联合国。在朝鲜战争爆发的35天后，苏联第一次公开露面。 三天后，苏联代表马立克即提出一项提案，要求立即停止朝鲜境内的一切敌对行动。但朝鲜战争这时已是张弓射出之箭，谁也抓不住了。 美国空军在轰炸朝鲜北方的同时，也轰炸了中国边境城市。在解放台湾无望的情况下，新中国的军事力量开始从东南沿海北移中朝边境，其态势随时可能前出朝鲜。这时的毛泽东似乎已对朝鲜战局的发展有了自己的判断，他下了一道命令：“各军区限期6个月内完成剿匪任务，整装待命。”1950年8月15日是北朝鲜解放5周年纪念日，这时北朝鲜已经解放了南朝鲜90%以上的地区和92%以上的人口。金日成向全军发出命令：“要在8月份解放朝鲜全部国土，向胜利进军。” 总攻釜山 8月31日，北朝鲜军队发动了第五次战役暨釜山战役的总攻，北朝鲜军队很快突破了洛东江南朝鲜军队的防线，先遣部队直逼釜山。 釜山战役的第二天，9月1日，联合国否决了苏联停止一切敌对行动的提案，全世界都漠视着朝鲜战局的发展。5天以后，北朝鲜军队已经打到北纬35度线，美国军队就要被赶下大海了。北朝鲜军队的兵力几乎全部集中使用在釜山攻坚战中，补给线贯穿整个南朝鲜，后方几近空虚。而美国入朝参战的部队4个整编师近10万人，拥挤在一个仅5000平方英里的地区。 就在这时，战局似乎凝固了，两军战线呈焦灼状态僵持在原地。一直严密注视着战况演变的中国军队总参谋部，在详尽研究了麦克阿瑟的作战特点后，向中央军委递交了一份绝密报告，明确判断美军在坚守釜山环形防线的同时，可能实施第8集团军最擅长的两栖登陆作战，以拦腰切断北朝鲜军队，关于登陆的地点。报告中拟出了4个地区即仁川、海州、镇南浦和兴南，而美军当时正制定的作战方案，最后从预定的三个登陆地点即仁川、海州和镇南浦中确定了仁川。这组镜头就是美军参联会代表到东京与麦克阿瑟最后确定仁川登陆方案时的情景。 毛泽东审阅了这一情报后，随即指示立刻通报金日成，至今没有资料可以查明北朝鲜是如何对待这一来自中国的及时忠告的。但从当时的战争进程看，金日成没有采取任何措施，以至最终失去了唾手可得的最后胜利。战后几十年中，历史学者还有一种审度中国的观点，认为，如果那个时刻中国及时出兵北朝鲜，填充它的空虚的后方，朝鲜战争也许是另外一种结局。这个观点也许是对的，但历史不是一种想象。从战后披露的资料看，由于战前苏联和朝鲜没有向中国通报这场战争的真正意图，致使在6月下旬开战后的两个月中，中国完全无从把握出兵的最佳时机。所以，历史把这个瞬息万变中显露的最后时机留给了美国。美国终于能在朝鲜战争的90天后一举挽回颓势，这一举就是留载现代战争史的著名的“仁川登陆”。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-珍宝岛自卫反击战（下）","slug":"共和国战争-珍宝岛自卫反击战（下）","date":"2023-05-27T21:18:47.000Z","updated":"2025-09-16T02:08:42.968Z","comments":true,"path":"2023/05/27/共和国战争-珍宝岛自卫反击战（下）/","link":"","permalink":"https://naosense.github.io/2023/05/27/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E7%8F%8D%E5%AE%9D%E5%B2%9B%E8%87%AA%E5%8D%AB%E5%8F%8D%E5%87%BB%E6%88%98%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"1969.华盛顿 珍宝岛的战斗只是两个巨大的火药库间蹦出的小火花，却使两个大国的全部神经都绷了起来。在苏联的五大军种中，排在头一位的是战略火箭军，它是世界上规模最大的导弹力量。战略火箭军之下是陆军，是五大军种中人数最多的军种。60年代末期拥有兵员182万人。在这个总数中，摩托化步兵师占70%，坦克师占25%，空降师占5%。 据美国国防部公布的情报，自60年代中期以来，苏联开始实行一项提高地面部队素质的计划，以确保执行进攻任务的能力。计划范围极为广泛，包括大规模提高机动力、火力、突击力、指挥和控制越过障碍的能力、防空能力、电子战能力以及后勤保障能力。苏联用于这项计划的国防预算连年增加。 在文化大革命中，中国的军事工作遭受到了严重的挫折和损失。但在国家安全受到威胁和国内动乱的情况下，军队又必须抵制和排除各种干扰，克服一切困难，努力加强战备工作。珍宝岛自卫反击战之后，中央军委针对苏联地面部队可能的入侵方向及其作战特点，组织实施了一系列模拟实战的大规模演习，特别是模拟反苏军坦克多路冲击的大规模演习。 在战备中，尤其重视对坦克的冲击以及对机降伞降的防范。 鉴于苏联对边境的武装挑衅，中央更加强调要重视战备工作，提出要做好反侵略战争的准备，告诫全国人民绝对不准冲击部队，并加快了中型坦克、歼击飞机、轰炸飞机的研制和生产，并很快装备了部队。珍宝岛自卫反击战之后，毛泽东认为国际形势有可能恶化，更强调了要突出战备的问题。毛泽东曾说过，“我国不应有大国霸权主义思想，但在国内建设中则要切实做好战备工作，要进一步挖深挖好防空掩体”。这就更进一步给原有的战备热潮加了温，使中国的经济战略重点全面转到了备战方面。 在全国军民秣马厉兵之际，林彪则利用了这一形势大做文章。他认为苏联存在突然袭击的可能，于是在1969年10月17日，在苏州擅自发出了《关于加强战备，防止敌人突然袭击的紧急指示》的第一号命令，要求全军进入紧急战备状态，抓紧生产武器，指挥班子进入战争指挥位置。这一命令引起了国内各方面极大的震动。第1号命令下发后，全国进入紧急战备，部队随时准备打仗。中国陷于内乱与动荡之中，战争的主动权在莫斯科手里。苏军原在中苏边境驻有12个师，珍宝岛冲突数月之后，陆军增至55个师，空军、防空军24个师，海军13万人。导弹打击目标也做了调整。苏联的导弹打击目标主要是北约，而现在在亚洲也部署了35个导弹基地，其中洲际导弹基地10个，中程导弹基地25个。这些基地大部分目标对准了中国。 勃列日涅夫尽管瞄准了中国，但它的战略重点还是以美国为首的北大西洋公约组织，而不可能东移。60年代初期，与美国相比，苏联的导弹力量明显处于劣势。但到60年代末期，美苏间的洲际导弹与潜射导弹大体上处于均势，只是苏联的洲际导弹命中精度差，而且大部分装在未经加固的发射井中，经不起袭击。但苏联具有无可比拟的地理优势，它是欧洲国家，无需使用洲际弹道导弹，仅凭部署在境内和东欧卫星国中的中远程导弹就可以摧毁北约欧洲国家境内的战略目标和军事设施。 而美国与欧洲隔着一道大西洋，如果苏联果真从中欧向西欧下手的话，美国人恐怕来不及救火，西欧就完了。白宫1969年是新总统理查德尼克松任期的第一年，他必须干点什么来打破美苏间的僵局，当然，最好的杠杆就是中国。早在他未担任总统时，就曾在外交季刊上著文说，“在这个小小的星球上，容不得7亿最有才能的中国人生活在愤怒的孤立状态中”。但美军一直在越南作战，而中国则是坚定援越的，只要越南问题存在，美中就没有多少靠拢的机会。 据基辛格在回忆录中说，中美之间最初的靠拢迹象出现于1968年苏联武装入侵捷克斯洛伐克之后，中国强烈的谴责了苏联。对照1956年匈牙利事件之后，中国充当和事佬，这次使美国人第一次感到与中国人在国际重大问题上有了共同语言。接着尼克松在旧职演说中暗示了美中对话的可能性，重谈了一个民族不能生活在愤怒的孤立中的老调。可惜的是，当时的中国人没有被这一含混的说法所打动。 但珍宝岛事件之后，情况出现了转机，中国人加强了国防科研，也在大力研制导弹。中国人已经更多的处于苏联的核威胁之下，与同样处于苏联核威慑之下的美国有了点心照不宣的意思。而就在这时，仍懵懵懂懂的勃列日涅夫干了件蠢事，加速了中美和解的进程。 1969.外科手术 苏联在中国东北边境武装挑衅后，又在西北新疆边境铁列克提地区制造事端。铁列克提是中国边防部队巡逻的必经之地，中国边防部队对苏军的意图有所察觉，并将自己的意见汇报到了新疆军区，建议取消在铁列克提的例行巡逻，但军区对此事竟没有明确指示。1969年8月13日晨，副连长杨正林带领37名战士执行例行巡逻任务，在铁列克提以东10公里处被设伏的苏军围歼，无一生还。 当晚，在中央人民广播电台的新闻联播节目中广播了这一消息，并广播了中国外交部向苏联驻华大使馆提出的抗议照会。北京的居民听到这一消息以后，没有举行大规模的游行示威，高呼口号，表示义愤的时期已经过去了，全国掀起了备战高潮，全民皆兵，全民备战。人们向地下开掘，准备迎接战争。早在数年之前，由于对国际形势的估计过于严重，毛泽东强调“要突出战备问题，要储备粮食和布匹，要挖防空洞，要修公事”。根据这些精神，1969年8月，中共中央正式决定成立全国性的人民防空领导小组，各省市、自治区也纷纷成立各级人防领导小组，在全国广泛的开展了群众性的挖防空洞和防空壕的活动。于是，人防工程规模在已有的基础上迅速扩大，人防工程的规格不断提高。 毛泽东将当年隐士朱新为明太祖朱元璋成就帝业所建之策“高筑墙、广积粮、缓称王”改为“深挖洞，广积粮，不称霸”。一时间，举国上下深挖洞，以至很多年后，有不少当年深挖的核隐蔽所被改造成各大中城市的地下商城。 从大战略的眼光来看，铁列克提的38名中国官兵在苏军入侵时拼死一搏，无意间撬动了一根巨大的杠杆，把通向另一种世界战略格局的大门别开了一条细细的缝隙。当38名中国军人的忠魂仍飘荡在中国西北边陲时，美国副国务卿理查森发表了被基辛格称为“革命性步骤”的讲话，讲话称“不断改善同中国的关系是符合美国国家利益的”。与此同时，美国政府通过巴基斯坦总统叶海亚向中国总理周恩来捎话“美国愿意改善同中国的关系”。但由于中美长期对立等全然可以理解的原因，巴基斯坦渠道一时没有反馈回中国方面的信息。 苏联在中苏边境陈兵百万，又在世界范围内与美国争夺霸权。面对一个扶摇直上的军事巨人，中美两国也不得不靠拢了。但这时的勃列日涅夫仍在放试探气球，苏联著名的自由撰稿记者维克多放出风说，“苏联有可能对中国的罗布泊核基地实施核打击。如果这件事情真的发生了，那么世界只能在事后才能得知”。这种说法形同于暗示苏联要先发制人，对中国的核报复手段，实施核突然袭击。苏联放出这种试探气球的目的是要看看中国政府的反应，中国政府果真很快作出了反应。1969年9月28日和29日，美国地震监测站、苏联地震监测中心以及两国的卫星几乎同时收到了能量巨大的震动信号。他们马上作出了判断，中国成功的进行了第一次地下核试验和高爆核试验。这是中国进行的第八次、第九次核试验。 但是一连几天，中国的所有新闻媒介都悄无声息，好像什么事都不曾发生过。美联社对这种反常的现象评论说，中国最近进行的两次试验不是为了谋取某项成果，而是临战前的一次检测。 这就是北京对莫斯科释放的试探气球的回答。 苏军内部有一伙鹰派，素来主张与中国先打后谈，到这时，他们也多少掂出了一些中国的分量。勃列日涅夫真正发愁了，这位克里姆林宫的主人所面对的，是历届沙皇都未曾遭遇过的自信而又自尊的中国。新中国不可能与任何入侵者签订城下之盟。20世纪中兴的中国，不惧怕武力讹诈，不惧怕原子弹。 在中苏边境上，苏军已进入一级战备，警铃长鸣。在边境地区，苏军总参谋部部署了55个步兵师，12个战役火箭师、10个坦克师、4个空军军团，总兵力达百万以上。这支大军有强大的常规武器装备，随时可以引发战争。 中国人民解放军总部把这一情况及时通告全军，所用词汇是“苏军百万大军压境，亡我贼心不死”。 中国有500万常备军，是世界各国中数量最多的军队，同时又有广大的基干民兵，当时叫做“八亿人民八亿兵，万里江山万里营”。在那个时代，这并非仅仅是口号。如果中国把对手放进来打，人民战争处处开花的时候，任何力量都会陷入一片泥沼之中。 第二次世界大战中，苏军在欧洲战场大局已定时便往远东集结，歼灭关东军的兵力。西伯利亚大铁路昼夜不停地运输了几个月，运量已达到极限，才在远东集结了三个方面军共150万军队以及相应的装备。现在苏军无论在中苏边境的哪一段集结兵力，国家的运力以及后勤支援也远远不敷需要。重要的是，长期以来苏军的主要假想敌是美国，苏联的兵力主要部署在西线，这个大目标是不可更移的。 美国的洲际弹道导弹射程远，命中精度高，同时多弹头分导技术也远远领先于苏联，加上长期以来便优先发展预警系统，从而形成了一个很难被对方摧毁，同时又可以准确的摧毁对方的洲际导弹体系。对于苏联来说，主要威胁来自日夜瞄准着苏联的美国，而不是来自于从不想夺取别国一寸土地的中国。如果在中国方向上用兵太多，势必会忽略主要的危险方向。 这是60年代末的莫斯科，这时的苏联已陷入了深深的苦恼之中。在莫斯科掌权的勃列日涅夫也和赫鲁晓夫一样，感情用事，他在中国问题上操之过急，刚走出几步便陷入了死胡同。核威慑中国不怕，常规战争又肯定打不赢，这样的局面不知会拖到何年何月。为了保证北约这个重点，莫斯科也有意要和北京坐下来谈一谈。作为一个超级大国，它自然不能卑躬屈就，它在寻找一个契机。 1969年9月2日，中国人民的亲密朋友、越南劳动党主席胡志明在河内病逝，越南人民在河内为胡志明举行了盛大的追悼会。中国和苏联都派出了高级别的党政代表团参加追悼活动。胡志明是1920年在法国加入共产党的，在他波澜壮阔的革命生涯中，先后与苏共、中共产生过密切的接触。据说，周恩来总理到达河内以后，范文彤总理向他转达了胡志明的临终遗嘱，“老大哥、老大姐，不要再打了” 苏联总理科西金也来参加胡志明的葬礼，柯西金很想借这个机会与周恩来接触一次，但周恩来当晚就回国了。9月11日，柯西金在从河内返回莫斯科途中，在北京首都机场与周恩来总理举行了会晤。双方谈了55分钟，就两国边界和两国关系问题交换了意见。两国总理一致同意，中苏之间的原则争论不应妨碍两国国家关系的正常化，两国不应该为边界问题而使用武力。双方一致同意，应该首先签订一个关于维持边界现状、防止武装冲突双方部队在边界争议地区脱离接触的临时措施协议，并进而谈判解决边界问题。中国方面参加会谈的有李先念、谢富志。苏联方面参加会谈的有卡图谢夫、雅施诺夫。 10月7日，人民日报刊登中国政府的声明指出，中国政府一贯主张通过谈判和平解决中苏边境问题。根据两国总理的商定，从当年开始在北京举行副部长级的边界谈判。据基辛格在回忆录中披露，中苏两国总理会晤及两国举行副部长级边界谈判触动了美国的神经，使尼克松总统分外不安。中苏缓和显然对美国不利，他想摸中国的底，而巴基斯坦渠道彼端的中国又固执地沉寂着。无奈之际，他甚至曾托罗马尼亚总统齐奥塞斯库向中国转达美国要缓和的愿望。 让尼克松宽心的是，中苏副部长及边界谈判未达成任何协议，中苏关系无缓解的迹象，苏军的大部队仍滞留在中苏边境地区，一点也没有撤回欧洲的意思。更让尼克松宽心的是，苏联在寻找进攻中国的借口了。他们发表文章说，“社会主义国家为了自身的利益，或者那些受到威胁的国家的利益，有权干涉彼此的事务。”苏联军队一直在观察着中苏边界的情况，注视着中国军队的动向，例行向上级汇报。但是他们很少了解这个世界上将会发生什么。1971年4月，正当苏军总参谋部召集会议时，在日本的名古屋举行了31届世界乒乓球锦标赛。比赛期间，中国乒乓球代表团负责人向美国队队员科恩发出了到中国做一次免费旅行的邀请，这就是被世人称道的中国“乒乓外交”。美国乒乓球队从香港进入广州，又从广州乘飞机抵达北京。这时科恩向他的队友说，“用毛主席的话说，我们点燃了燎原的星星之火。”这支乒乓球队住在北京新桥饭店，到人民大会堂观看了样板戏、芭蕾舞剧红色娘子军和京剧智取威虎山。4月14日，周恩来总理接见了他们，并对他们说，“我们翻开了中国和美国人民关系方面的新的一页。”还说，“现在美国记者可以分批来华了。”乔治布什也打起了乒乓球。他是一位优秀而温和的政治家，在中美正式建交之前，担任美国驻北京联络处主任，这个位置是他政治生涯的转折点。直到他后来担任了美国总统，都与这段经历有直接关系。在美国乒乓球队离开北京的当天，尼克松总统宣布放宽已有20年之久的美国对华贸易禁运，北京则恢复了同华盛顿和伦敦的电话联系。紧接着的是巴基斯坦渠道突然畅通了。周恩来通过巴基斯坦人捎信，北京同意接待美国总统的特使。此事在当时是中美之间的头号政治机密。经过精心的安排，美国总统尼克松的国家安全事务助理基辛格在东南亚巡游了一圈以后，突然来到巴基斯坦首都拉瓦尔品地，然后从那里乘一架巴基斯坦客机，于7月9日秘密抵达北京，当天就与周恩来总理举行了会谈。7月15日，双方共同发表会谈公报，宣布尼克松总统应邀将在近期内访华，基辛格的秘密访问，为尼克松总统的中国之行铺平了道路。此后他10次到过中国 5次会见毛泽东，当时毛泽东所关心的国际大局是苏联。毛泽东曾说，“目前美国发动侵略的可能性很小。”言外之意显然是说苏联是他最担心的对象。 中美接近的冲击波使世界政治形势发生了巨大的变化。在这一年10月26日的联合国大会上，阿尔巴尼亚等国接纳中国驱逐台湾的提案已压倒多数通过，而尼克松政府所搞的中台双重代表权提案甚至都没有付诸表决。很显然，美国一方面帮助中国加入联合国，另一方面要装出努力防止台湾被赶出联合国的样子。 1972年2月21日，周恩来等中国党和国家领导人来到南苑机场，美国总统尼克松和夫人以及罗杰斯、国务卿基辛格博士等已乘坐总统专机空军一号飞越了浩瀚的太平洋，在上海稍事停留后飞往北京，飞机降落在北京南苑机场，他们是来谋求中美关系正常化的。 尼克松和夫人走出仓门，沿舷梯走下，他微笑着伸出了手臂，周恩来也伸出了手。据尼克松回忆说，鉴于18年前杜勒斯在日内瓦会议期间拒绝与周恩来握手，因此他这次特地远远地向周恩来伸出了手。而基辛格事后说，为了突出这个有历史意义的时刻，此时有一名粗壮的副官挡在空军一号机舱的通道里。等到尼克松单独一人和周恩来的历史性握手结束之后，才让美国代表团其他人像变魔术似的出现。此事让苏联当局大为恼火，他们打听出巴基斯坦曾在中间牵线搭桥，因而随即与巴基斯坦的老对头印度签订了友好条约。 这次是基辛格博士第三次来到这个机场了。据他在回忆录中说，他几次经过这个机场，都从来没有看到过其他任何一名旅客或任何一架飞机在这里起降，中国方面事先并没有告知是否会组织群众欢迎。后来，当车队徐徐往市中心开去时，美国代表团的其他成员还抱着一线希望，以为真正的欢迎仪式会在天安门广场出现。结果车队驶过天安门广场时，巨大的广场却空无一人。基辛格在回忆录中说，“在这个到处是人的国家里，行人这时候都被挡在横街小巷里了。” 基辛格回忆说，“这次是美国总统首次访华，而欢迎仪式却简朴到了极点，除了一个由350人组成的仪仗队以外，没有在机场欢迎的群众。这种简朴的、低调的欢迎仪式表明，中美两国是由于最紧迫的必要性而走到一起来的。为此，一切形式上的东西已显得多余了。” 美国代表团被安排在钓鱼台国宾馆分住两幢小楼。吃完中午饭不久，2:30左右，有人通知基辛格，周恩来有急事要见他。据基辛格事后说，这一次周恩来没有像以往那样见面后先开开玩笑，而是直截了当的说毛主席想见总统。这样，在尼克松到达北京后才3个小时，便带上基辛格和作为记录员的温斯顿洛德乘车前往中南海，毛泽东在自己的书房里会见了他们。 毛泽东与尼克松的会晤原定为一刻钟左右，结果双方说了一个小时。尼克松与基辛格的回忆录中分别谈及了这次会晤的经过。基辛格说，“当毛泽东站在那里时，身上发出了一种几乎可以感觉到的压倒一切的魄力。”他又说，“见到毛泽东时，的确能感受到他发出力量、权力和意志的颤流。”会晤中，当尼克松说到中美两国谁也不威胁对方时，毛泽东说，“目前美国发动侵略和中国发动侵略的可能性都很小。”基辛格认为，这显然说明毛泽东在安全方面主要担心的是苏联。毛泽东还说，“我说过，全世界人民团结起来，打倒帝国主义、修正主义和一切反动派。”当听说有人居然认真的对待这类口号时，毛泽东放声大笑起来。在笑声中，基辛格分明感受到美中订立了一个无形的互不侵犯条约，从而解除了一个方面的敌情。按他的说法，从此之后，一个三角政治的格局形成了。在这种格局，中苏之战似乎已十分渺茫了。 尾声 20多年过去了，珍宝岛依然存在，而苏联则不存在了，变成了独联体，三角政治亦随之瓦解了。在这二十几年间，世界上发生了那么多的事情，也有不少叱咤风云的人物纷纷作古。勃列日涅夫于1982年11月辞世，在他去世前已是儿孙满堂的老人，却又在中苏边界西段的小国阿富汗打了一仗。1979年底，苏阿边境的苏军分六路从东西两线侵入阿富汗，同时向阿富汗首都喀布尔空运了大批部队，阿富汗人开展游击战争，反抗入侵。从此，苏军在这片贫瘠的山地中打了10年仗，不仅自己背上了沉重的包袱，而且造成了在国际社会上的空前孤立。1989年春，苏军全部撤离了阿富汗，但元气大伤，加速了国家瓦解的进程。 苏联解体后，随着阿富汗边境的平静下来，中苏边界西段也渐渐相安无事了。70年代前期，毛泽东对国际形势逐渐形成关于三个世界划分的估计，1976年9月，这位伟人逝世了。毛泽东关于三个世界划分的估计虽然在理论上有不合乎实际之处，但目的在于反对霸权主义，对中国的援越和中美关系正常化都起过积极作用。越南全国解放后，越南当局热衷建立地区霸权，并自视苏联的支持，在反华道路上越走越远。 1979年2月17日至3月5日，中国广西、云南边防部队为了保卫边境地区的安全，被迫进行对越自卫还击作战，达到预期目的后，又立即撤回中国境内。对越作战期间，中国边防部队严守战区群众纪律，把中国援助越南的库存粮食和生活物资开仓济贫。在回撤过程中，中国政府信守诺言，没占越南一寸土地，更没在越南留下一兵一卒。正由于此，在对越还击作战结束之后，中越两国关系渐趋缓解，中越边境又恢复了正常。 尼克松已于近年逝世，他为中美两国关系正常化作出了努力，但直到他下台数年后，中美两国才正式建交。 尼克松执政时期，适逢美国的全面收缩，中美谈判后，亚洲形势变化很快，他力图使美国从越战中拔出脚来，到美军从越南最后撤退时，中国人民多年来对越南的无私援助也见到了最后的结果。 珍宝岛自卫反击战至今已经过去近30年，在中苏边境的两侧，军队依然存在，坦克和导弹也依然存在，但战争的阴影远去了，漫长的国境线上形成了一个又一个边贸点。近30年的时光如江水一般流淌过去，但每个和祖国一同熬过最困难时期的中国人，仍能清晰地回忆起那个时期，带着复杂的思绪回味它，掺杂着酸甜苦辣咀嚼它，珍宝岛 ，0.74平方公里，不折不扣的弹丸之地，却几乎引发出一场中苏大战，满清政府在半个世纪间向沙俄割让出去150万平方公里的国土，国民党政府不发一枪一弹把东三省让给了日本人，而新中国政府却准备倾国力保住这块 0.74平方公里的弹丸之地。这种胆识和胆略，当有待后人细细品味，而这种骨气和傲气，足以万物流芳。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-珍宝岛自卫反击战（上）","slug":"共和国战争-珍宝岛自卫反击战（上）","date":"2023-05-27T10:59:05.000Z","updated":"2025-09-16T02:08:42.968Z","comments":true,"path":"2023/05/27/共和国战争-珍宝岛自卫反击战（上）/","link":"","permalink":"https://naosense.github.io/2023/05/27/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E7%8F%8D%E5%AE%9D%E5%B2%9B%E8%87%AA%E5%8D%AB%E5%8F%8D%E5%87%BB%E6%88%98%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"在中国人民革命军事博物馆的广场上，陈列着一辆苏制特62型陆军主战坦克，这是一件令人瞩目的战利品。1969年初春时节，苏联边防军入侵中国领土珍宝岛，这辆坦克闯入了在乌苏里江西岸我国江叉的反坦克雷区，被炸断了履带。苏军曾出动过一个营的兵力，企图把它拖回去，又企图用火炮彻底毁掉它。炮弹把附近的冰层炸坍了，致使它沉入江底，中国边防部队用绞车把它从江底拖了上来。 珍宝岛属于中国黑龙江省虎林县辖境，而虎林县则是中国北部边陲一个人烟罕至的县份。现在这个小岛上驻守着沈阳军区边防部队某部一个班的战士。在他们的驻地附近，到处散落着当年同苏军战斗的遗迹。实际上，在珍宝岛附近，苏军曾进行过一场规模远比珍宝岛战斗大得多的战役。那是在第二次世界大战中，日本关东军在虎林县虎头镇修建了虎头要塞，日军称之为“东方的马奇诺防线”。1945年8月，苏军出兵中国东北对日作战，对虎头要塞实施强攻，固守虎头要塞的数千关东军仅有五十几人生还。这一仗被称为“二战中的最后一次地面战役”。而这个给二战地面战斗画句号的地点，距珍宝岛不过数十里之遥。 此一时矣彼一时，虎头战役结束近二十几年，当年曾并肩围歼关东军的中苏两国军队，却几乎在同一地点发生了战斗。这仅是一场边境战斗，却使整个世界为之屏息敛气，这是两个社会主义大国之间的兵弩相见。在边境的后面，双方各自拥有几百万常规部队，并且双方各自拥有一个核武器库。如果边境战斗控制不住，谁也不知道它会升级到什么规格的战争上去。这就是只有0.74平方公里的珍宝岛，它被西方人称为“差点引燃世界战争的小岛”。 1968.春 珍宝岛自卫反击战发生于文化大革命时期。毛泽东是中国共产党、中国人民解放军和中华人民共和国的主要缔造者和领导人，在他的晚年错误地估量了国内外形势而发动了文化大革命。这场内乱自初期就被林彪、江青两个反革命集团所利用，变得异常狂暴而难以控制。 1966年8月18日，毛泽东在天安门第一次接见来自全国各地的红卫兵。毛泽东对红卫兵造反运动的积极支持，致使全国各地分散的零星的造反行动迅速统一到红卫兵这一风靡全国的组织形势之下，发展成为一股席卷数千万青年的狂潮。在“一斗二批三改和破四旧”的名义下，许多适应社会主义制度的上层建筑和行之有效的规章制度，以及历史文化遗产被砸烂、被废除、被毁灭，造成极大的混乱。林彪则颠倒黑白的说，“这次真是代价最小最小最小，胜利最大最大最大”。中央批准了他的这一讲话以后，全国更乱了。当时越南正进行抗美救国战争，内乱中的中国依旧承担着巨大的国际主义义务中，政府应越南政府的请求，除为越南提供大量武器和其他物资外，还陆续向越南派出一批批防空、工程、铁道、后勤部队。中国军队在越南几乎与美军面对面的战斗。 1967年8月，港英当局封闭了香港的三家左翼报纸，理由是这些报纸上刊登了反对英国继续占领香港的文章，这样中国人在内乱外患交加时对欺辱有异常敏感反应。8月22日，所谓首都无产阶级革命派反帝反修联络战在英国驻华代办处门前集合，会后放火烧了代办处的办公楼，造成一起严重的国际事件。这不仅损害了中英两国之间的关系，而且破坏了中国的对外关系、国际声誉和国家形象。 这时的中国早在三年前就拥有了自己的核武器。1964年10月16日，中国制造的第一颗原子弹在中国西部爆炸成功，中国人认为自己也是一个不可战胜的强国。1967年6月17日，中国在西部地区又成功的爆炸了第一颗氢弹，使中国成为世界上仅有的几个拥有氢弹的国家之一，打破了美苏超级大国的核垄断局面。 虽然中国政府反复重申，“中国发展核武器完全是为了防御，在任何时候，任何情况下，中国都不会首先使用核武器”，但它的潜台词很明确，中国一旦受到外来侵略的威胁，已经有能力将原子弹用于实践。疯狂的文化大革命使中国在国际上处于十分孤立的地位，周边安全受到了日益严重的威胁，军队工作也受到了严重损失。这是共和国的一个极度虚弱的时期，毛泽东不得不告诫说“要准备打仗”。 1967年11月6日，中国当时最权威的“两报一刊”正式提出了所谓“无产阶级专政下继续革命”的理论，鼓吹要不断进行一个阶级推翻另一个阶级的政治大革命。第二天，恰是苏联十月革命节，莫斯科红场上举行了庆祝十月革命50周年的盛大阅兵。 在伟大的卫国战争中，苏联的军事力量迅速成熟起来。战后，苏联仍保持着一支庞大的常备军，国家不惜投入巨资使武装力量诸军种战略火箭军、陆军、空军、海军及国土防空军由于源源不断地得到新式武器系统而日益现代化。在60年代后期，苏联在核武器数量上与美国大致相当，常规武器不如美国先进，但在数量上远远超过美国。苏联在与美国为首的西方展开军备竞赛的同时，军事实力急剧膨胀。毛泽东说“美苏是在争夺世界霸权”。在此之后，苏联就做出了一件令世界震惊的事情，这就是“布拉格事件”。 1968年8月20日，苏军运输机在捷克斯洛伐克首都布拉格机场实行空降，占领了机场。接着大批空降部队、大量的轻型坦克、装甲车和反坦克炮源源不断的运抵布拉格。与此同时，苏联、波兰、东德、匈牙利和保加利亚五国共50万军队从北部、东北部和南部强行越过捷克、斯洛伐克边境，到此日傍晚便控制了这个国家的全境。 从布拉格事件，中国清醒的看到，苏联已经发展到要用武力来解决社会主义国家之间意识形态的分歧。中国作为社会主义阵营中在意识形态上与苏联争端由来已久的国家，这时也绷紧了准备武力对抗这根弦。这就是毛泽东所说的要准备打仗。捷共中央第一书记杜布切克、捷克总统斯沃伯达等均被武装押解到莫斯科，与苏联领导人举行谈判。 苏联的这一行动在世界各地遭到了普遍谴责。这是南斯拉夫总统铁托，自苏南矛盾公开后，他便坚持独立路线，这时他必须防备苏军，也对南斯拉夫动武。 濒临亚德里亚海的阿尔巴尼亚也绷紧了弦，这个只有100多万人口的山地小国，全民动员枕戈待旦，同时宣布退出华沙条约组织，不再承担这个条约所规定的一切义务。 当时阿尔巴尼亚劳动党第一书记是恩维尔霍查，这是阿尔巴尼亚部长会议主席谢胡访华的情景。那时中国在东欧只有这么一个盟友，中国人称它为“欧洲的社会主义明灯”。苏军入侵布拉格后，布拉格街头出现了一条标语，“列宁醒来吧，勃列日涅夫发疯了”。几周后，勃列日涅夫倒显出了某种条理性，称“社会主义大家庭的主权是无上的，其中每个国家的主权是有限的”。西方观察家普遍认为，这一为苏联实施武装干涉开脱的有限主权论，在很大程度上也是针对中国而发的。 6000公里边界 中国是一个大国，苏联也是一个大国。两个大国相连，形成了长达6000公里以上的陆地边境，是世界上两个国家之间最长的陆疆。中苏边界分为东西两段，东段中国的东北地区与苏联的远东部分接壤，西段中国的新疆地区与苏联的中亚地区接壤。中苏边界的西段边界线处大多是苍茫的戈壁和空旷的草原，边界标志并不很明显，有的地段长约十几公里才有一个界桩。在中苏友好时期，边界相安无事，边界两边的牧民放牧的牛羊经常不慎越过边疆，啃了另一国度的青草。对此，双方都能宽容和谅解。但到了中苏关系紧张以后，情况则大不相同了。苏联出动直升机超低空盘旋威吓驱赶中国牧区牧民。苏联边防军还用拖拉机沿边界走向，犁出一条宽10余米的简记地带。中国边民放牧的牛羊一旦靠近或踏上简记地带，苏联边防军轻则开枪射击，重则出动坦克驱赶，有时竟然越境把中国边民的牛羊驱赶到苏联国境一侧。在简记地带，苏军甚至用装甲车冲撞我国边民。 这一切都是苏联方面有意在边境制造紧张局势，挑起事端。这就是我国记者抢拍下来的苏军装甲车冲撞碾压我国边民的真实镜头。 1962年春，中国正处于经济困难时期，老百姓的日子过得相当紧，苏联当局却趁中国困难时期制造边境事端。新疆及至再往西的苏联中亚地区素来是各民族杂居地区，中苏边境两侧的居民有的属同一民族。但这时苏联驻伊犁和乌鲁木齐的领事馆及苏侨协会在伊犁塔城一带散发了10余万张侨民证，在中国边民中引起了骚动。一批克格勃人员以探亲访友为名渗入中国境内，发展了内奸。 1962年4月22日，在中苏边境发生了暴乱事件。距新疆伊宁市不远的霍尔果斯口岸是中苏边境西段的一条重要通道。霍尔果斯的骚乱蔓延到了阿尔泰、塔城、博尔塔拉、伊犁四个地区的二十几个县。在3000多公里的中苏边境上，几个重要的过境口岸，大批中国边民或开着拖拉机，或徒步，或乘坐牛拉的木轮车，冲破中国干部和边防军的阻止，涌入了苏联境内。白天苏联当局用车接，夜间则用探照灯为涌入的中国边民引路。这种状况持续了三天三夜，苏联共胁迫67000多中国边民进入苏联，中国境内有两个县，跑的仅剩几百人。 1962年春季发生在中苏边界西段的事件，是第二次世界大战之后最大的一次国际间边民外逃事件，也是中苏边境由局部紧张转入全线冲突的导火索。在这次事件之后，新疆军区副参谋长祖龙太耶夫少将、伊犁军分区司令员马尔果夫少将写报告要求去苏联，经批准予以放行。同这两名少将一同去苏联的，还有新疆军区的40多名校尉级军官。从此以后，中苏边界西段的那一侧，苏联边防军仿佛确立了某种精神上的优势，越发寻衅。 新疆与祖国的内地只有一条穿越茫茫戈壁的兰新铁路相连，而从首府乌鲁木齐到自治区的各主要城市则无铁路相连。在这种情况下，一旦中苏边境西段出现大冲突，中国方面将很难在较短时间内往边境地区调集大部队。苏联中西部分有阿拉木图、塔什干、杜尚别等工业枢纽城市，能为边防苏军提供充裕的后勤支持。 美联社记者瑞安曾就苏军在中国新疆边境地区制造事端仪式发表评论说，对于苏联人来说，绝不满足于在新疆边境上搞点动作。新疆具有激起一场大战所必要的一切因素。新疆的面积等于意大利、法国、德国和英国国土面积的总和，有丰富的尚未开采的战略资源，如石油、煤、稀有金属和制造原子弹所需要的铀。这个地区无论对于北京或是对于莫斯科来说，都具有极端重要的地理、政治、军事和经济意义。因此，把新疆从赤色中国分裂出去，很可能是苏联的既定目标之一。苏联边防军越境挑衅时，新疆军区边防部队指战员坚持说理斗争，但事态并不因质朴的中国军人的据理力争而有所缓解，反而在不断加剧。 中苏边界的东段主要由三条界河构成，它们是鄂尔古纳河、黑龙江和乌苏里江。中国在地图上的形状宛若一只大公鸡，三条界河则勾勒出了大公鸡的鸡冠。在苏联1968年出版的地图上，将中国在乌苏里江和黑龙江上的总面积达1000多平方公里的600多个岛屿划入了苏联。塔斯社还为此事发表了声明。在俄语中，黑龙江被称为阿莫尔河。1968年苏联太平洋舰队下辖的阿莫尔河区舰队和苏联边防军强占了黑龙江与乌苏里江会合处的黑瞎子岛的一部，出动军舰封锁江面，拦截中国船只，抢掠中国货船上的货物，强行剥夺了中国船只在这两段界江上的航行权。为了避免武装冲突，中国边防部门的巡逻艇被迫暂时停止了在这一水域的例行巡逻。这一水域中很难见到中国船只在航行，只有少数中国渔民在江上捕鱼。 中苏之间曾有过边界谈判，但谈来谈去总是谈不拢。中国方面总想维持现状，但现状也难以维持了。那么，中苏边界为什么会屡起争端？ 100年历史 从历史的大尺度来说，中苏边界之争的渊源在于沙皇俄国制定的东进政策，这是俄国的末代沙皇尼古拉二世送俄军奔赴一战战场的资料，他所统治的俄国已经是世界上版图最大的国家了。但众所周知，直至中国的明朝时，沙俄还仅仅是地处东欧一隅的小国。打那以后，它不断地向东扩张，一直越过欧亚大陆东端的白令海峡，同时也一块一块的把中国的早期疆土据为己有。仅在上个世纪的中后期，沙俄便先后迫使清朝政府签订了不平等的中俄《爱徽条约》、中俄《北京条约》和中俄《伊犁条约》，从中国强行割走黑龙江以北、外兴安岭以南、乌苏里江以东及新疆地区的150多万平方公里的土地。 马克思和恩格斯曾这样谴责沙俄对中国领土的掠夺，“无耻的强盗，他们就这样轻而易举地夺走了鞑靼海峡和贝加尔湖之间最富庶的地区”。这块地区等于法、德两国的面积，有一条同多瑙河一样长的河流。1900年，沙俄军队作为八国联军中的一员打入了北京城。当八国联军在紫禁城太和殿前广场联合阅兵时，各有各自的掠夺中国的盘算。但沙俄的位置似乎比其他七国更有利一些，因为在八国中，唯独沙俄是中国的邻国。凭借这一地利，沙俄于当年10月便占领了中国东三省的重要城市，以期实现尼古拉二世的“皇俄罗斯计划”。八国迫使清政府签订《辛丑条约》以后，沙俄在中国东北的一系列旁若无人的侵略行径，使早就觊觎东北的日本忍无可忍。 1904年2月，日本突然袭击停泊在旅顺口的沙俄舰队，一场为重新分割中国东北地区权益的帝国主义战争在中国领土上正式爆发。这场战争历时一年多，其规模之大、伤亡之惨重，均为近代战争史上所罕见。日俄战争以俄国的失败而结束，从此，日俄以长春为界，分割了中国东北三省，形成了南满与北满的对峙局面。 1912年，外蒙古王宫在沙俄支持下宣布独立，但1917年俄国爆发了十月革命，外蒙又复归中国。1920年9月，列宁代表苏维埃政府宣布沙皇俄国在中国的政策是一种犯罪的政策，以前俄国历届政府同中国订立的一切条约全部无效，放弃以前夺取中国的一切领土和中国境内的一切俄国租界，并将沙皇政府和俄国资产阶级从中国夺取的一切都无偿永久的归还中国。但列宁过早的逝世了，斯大林成为苏联党和国家的主要领导人。从1924年到1926年间，中国国民党政府同苏俄政府举行了数次领土会谈。在苏俄新的领导人那里，列宁曾经宣布的将沙俄所夺取的中国领土归还中国的重要决定已不作数了。 非但如此，斯大林还渴望着把日俄战争中俄国在中国东北丢失的权益再拿回来。第二次世界大战的末期，美英苏三国首脑举行了雅尔塔会议，接受了斯大林提出的苏军对日本作战的条件。这些条件包括，维持外蒙古已从中国独立出去的现状、大连商港国际化、苏联租用旅顺口海军基地、中苏共同经营长春铁路等。这些涉及中国主权的条件在中国人不知晓的情况下，被美英苏三巨头用秘密的《雅尔塔协定》确定了下来。1945年8月，苏联出兵中国东北，歼灭关东军以后，取得了上述权益。 中华人民共和国成立后，1949年12月，毛泽东赴莫斯科参加斯大林70寿辰庆祝活动，并签订了《中苏友好互助同盟条约》。在毛泽东与斯大林的会谈中，外蒙古独立被作为一个异常敏感的问题提了出来。但由于国民党政府已于1945年8月同意了雅尔塔协定的外蒙古独立，因此新中国也只有把它作为一个既成事实接受了下来。但《雅尔塔协定》强加于中国的其他规定很快便被废除了。苏联同意将中苏共同经营的长春铁路无偿的交还新中国。中苏双方确定了苏联海军从旅顺口撤军的日期，并规定将该地区的设备移交给中国政府，由中国政府支付这些设备的恢复与建设的费用。 斯大林于1953年3月5日在莫斯科逝世。斯大林逝世后不久，赫鲁晓夫担任苏共中央第一书记，以后又担任部长会议主席。在1956年2月的苏共二十大上，他做了关于个人崇拜及其后果的秘密报告，全盘否定斯大林，中国对此产生异议，中苏两党的分歧由此而产生，苏共把这种分歧扩大到两国之间。苏联政府单方面撕毁了中苏协定，继而撤走了全部在中国援助工作的专家。 1959年9月，中国和印度发生边境事件，中国政府向苏方阐明了边境冲突真相，但苏联不顾两党关系，塔斯社还是发表了偏袒印度的声明。同一个9月，赫鲁晓夫率苏联代表团访问美国。在戴维营会谈期间，美国总统艾森豪威尔希望赫鲁晓夫在台湾和发展核武器等问题上对中国政府施加压力。赫鲁晓夫对此一一照办。1960年11月，参加庆祝十月社会主义革命43周年的81个共产党和工人党代表团在莫斯科举行会议，刘少奇率中共代表团参加了会议。会前，苏共领导向各党代表散发了一封长达6万字的信件，粗暴攻击中国共产党，从而挑起尖锐的争论。不仅如此，苏联政府还要中国归还朝鲜战争中购买武器欠下的债务。要知道，正是由于中国军队在朝鲜战场流血作战，才防止了美苏的迎头相撞，中国政府决定勒紧裤带还债。这不但加重了中国经济的困难，而且深深地伤害了中国人民对老大哥的感情。中苏两国之间自17世纪以来留下的边界争端一直没有解决，中国一直在努力寻求合理的解决两国边界问题的途径。在列宁时代，列宁以博大的无产阶级胸怀处理边界问题，在斯大林时代也还有商量的余地。但到赫鲁晓夫执政时期，双方已很难坐下来谈点什么。 当国家关系紧张时，出气孔往往是领土问题。继赫鲁晓夫之后，掌权的勃列日涅夫非但不打算解决历史上遗留下来的中苏领土争端，反而拥兵自重、节外生枝的提出了新的领土要求。 珍宝岛 珍宝岛位于我国黑龙江省虎林县境内，在乌苏里江主航道中心线中国一侧，面积0.74平方公里。该岛的北端本与中国的陆地相连，后由于江水冲刷，到1915年才形成小岛。它两头窄，中间宽，形似中国古代的元宝故得名珍宝岛。西侧有数十米宽的江杈，在枯水季节仍与中国江岸相连。而当时的苏联政府却把国界线划在了乌苏里江我国岸边，把珍宝岛划在了他们的版图内。珍宝岛地区一直有中国边防部队巡逻，守卫珍宝岛的是黑龙江合江军分区公司边防站，站长叫孙玉国，他手下只有30多个兵。 在珍宝岛的对面是苏联边防军酷列比亚克内衣和夏米海洛夫卡边防战，其人数在200以上，配有坦克、装甲车、汽车，紧急情况下还可以动用直升机。从1967年1月到1969年2月，苏联边防部队先后16次入侵珍宝岛进行武装挑衅，他们出动比中国边防部队多两三倍的兵力，拦截和殴打执行正常巡逻任务的中国边防军人，强迫中国军人离岛。他们出动装甲车载运全副武装的苏军，冲撞中国巡逻队，拦阻中国巡逻队上岛巡逻。他们还打伤中国边防战士。 为了防止事态扩大，1969年2月下旬，中国边防部队停止了巡逻。 3月1日夜间，中国的一支侦察分队悄悄在珍宝岛西端潜伏下来。3月2日晨，边防站长孙玉国带领一支巡逻分队恢复了岛上的例行巡逻。中国巡逻分队接到的命令是，绝不能先开第一枪。苏军观察到之后，立即从夏米海洛夫卡和库列比亚克内衣两个边防站出动了70余人，抢先赶到岛的东端，拦住中国巡逻分队的去路。苏军一下车就展开了战斗队形，他们兵分三路，除从正面逼过来之外，还分兵向中国巡逻分队的左右两侧运动，准备合围中国巡逻分队。 带队的边防战长孙玉国见苏军来势很凶，就一面发出警告，一面命令巡逻分队向岛的西端，也就是中国侦察分队设伏的地点撤退。这个岛的面积很小，巡逻分队很快撤到了岛的西部，已无路可退了。苏军一路紧追不舍。孙玉国看到苏军端起了枪，意识到苏军要下手了，命令巡逻分队做好战斗准备。苏军首先开枪，当时就打死打伤中国边防战士6人。中国边防部队果断地发出了还击的命令，立刻，巡逻分队和潜伏着的侦察分队同时开火。苏军没有想到岛的西边还有一支设伏分队被打得措手不及，致使火力优势完全发挥不出来。在岛的另一侧，中国边防巡逻队第二小组正与苏军的一支7人小分队在冰面上争执。一听这边打响了，中国边防战士果断行动，将苏军7人全部击毙。这时，一辆苏军装甲车冲了过来，一直驶入珍宝岛北侧江叉。 苏军装甲车沿江叉一直驶到中国边防部队的侧后，形成威胁。中国边防军江岸掩护火力集中炮击，打跑了这辆装甲车。中国部队决定冲击一下，然后撤下来。 侦察分队与巡逻分队发起了冲锋。苏军开始向后撤退，一直退回到主航道的江面上，而后登上装甲车回到苏联境内。 在珍宝岛3月2日的武装冲突中，苏方阵亡31人，伤14人，中方阵亡20人，它使中苏关系迅速恶化。当天，中华人民共和国外交部照会苏联驻华大使馆，对苏联边防部队入侵珍宝岛提出强烈抗议。照会中说，“中国政府坚决要求苏联政府惩办这次事件的凶手，立即停止侵犯中国领土和武装挑衅”。与此同时，苏联政府也照会中国政府，口径居然差不多，也是要求严厉惩办这一挑衅的肇事者。多年来，在中欧对峙中，苏联军事学说极重视军队的机动能力，要求在战争一爆发时就拥有明确的优势。在武装入侵捷克斯洛伐克时，苏联已让世界看到了它们能在短时间内迅速集中强大的军队。这一次，远东的铁路和战略空运力量充分动员起来，向乌苏里江集结力量。 在短短的数天内，苏军在珍宝岛方向上的兵力迅速增强，其中坦克达到70辆，火炮380门，装甲车和自行火炮150辆，步兵达1万余人。珍宝岛的另一场大战在即，中国方面预计，苏军为了挽回面子，肯定还会入侵珍宝岛。3月14日夜间，中国边防部队在江叉的冰面上设反坦克雷场，并派出一支由11人组成的小分队，在岛西侧的无名高地潜伏下来。巧合的是，苏军这次也想到了设伏，只不过是动作晚了一些。3月15日凌晨，一支30多人的苏军分队悄悄登岛，潜伏在岛的东北部丛林中。 3月15日晨，孙玉国带领一支巡逻分队登岛后从南向北巡逻，他们知道自己在潜伏苏军的枪口之下，却故意与苏军保持不即不离的距离，诱使潜伏苏军先开了枪。枪响后，苏军的潜伏位置已然暴露，江对岸的苏军在6辆装甲车的引导下，沿着冰冻的江面，向孙玉国巡逻小分队的隐蔽处冲了过来。这股冲击的苏军，恰恰把侧翼暴露给了中国的潜伏分队。当中国的潜伏分队突然开火以后，苏军的潜伏分队才恍如梦醒。苏军这次设伏冻死两名士兵，而设伏地点又居然是在中国人的眼皮底下。在这个不平静的早晨，双方激战一个多小时，苏军有两辆装甲车被击毁，剩余兵力撤回了对岸。苏军的第一次进攻被打退。9时46分，苏军展开了第二次进攻。 苏军的潜伏分队撤出后，苏军炮兵放胆向小小的珍宝岛上倾泻炸弹。在炮火掩护下，苏军又出动6辆坦克和5辆装甲车，引导着步兵分两路向珍宝岛发起攻击。一路以2辆坦克、5辆装甲车由岛的北端发起冲击，另一路以4辆坦克向岛南江叉逾回夹击，企图封锁江叉，阻止中国军队增援，将岛上的中国边防军包围全歼。 由于苏军的攻击火力异常猛烈，岛上的中国军队伤亡较重，苏军分两路攻击，同时岸上的炮火和大口径机枪封锁江叉，初步完成了战斗企图。苏军的4辆坦克绕过了岛的南端，从江叉包抄到了中国边防军的身后，被中国边防军埋在江叉上的反坦克地雷炸断了履带，这就是为中国军队炸断履带并缴获的那辆苏制特62型陆军主战坦克。 坚守在岛上的中国小分队，在苏军前后夹击的威胁下，配合岸上的掩护部队，集中火力打击苏军坦克。经过两个多小时的激战，苏军的第二次进攻又被打退了，中国边防部队伤亡也较大。黑龙江生产建设兵团21团知识青年组成的担架队也上阵了。下午15:13，苏军开始了第三次进攻。经过15分钟的炮火准备，火力压制，正面达10公里，纵深达7公里。苏军的24辆坦克和装甲车引导着一个连的兵力，气势汹汹地扑向了珍宝岛。战斗进入了最残酷的阶段，两军的士兵以血肉之躯，对一座名不见经传的小岛拼死相争。苏军的一名中校和一名上校在这次战斗中阵亡。中国炮兵发射炮弹1200多发，击毁击伤多辆苏军坦克和装甲车，大量杀伤了苏军的有生力量。苏军的第三次进攻又被打退了。 珍宝岛自卫反击战后仅半个多月，中国共产党第九次全国代表大会在北京召开。大会始终为强烈的个人崇拜和左的狂热气氛所笼罩，使文化大革命的理论和实践合法化，加强了林彪、江青等人在党中央的地位。由于大会对战争到来的可能性做了更紧迫和夸大的估计，所以来自珍宝岛的代表受到了格外重视。这就是珍宝岛前沿的边防站长孙玉国同志，他被特邀参加了九大，他代表了那些仍在珍宝岛爬冰卧雪的战士，因此他走上主席台时显得分外激动。无论是林彪还是江青，事前都对发生在珍宝岛的事情若明若暗，事后又对珍宝岛之战在当时中国政治中的分量洞若观火，出于各自的政治需要，这个基层指挥员硬被他们造成了一名火箭杆。九大的政治报告写上了准备同美帝苏修早打大打核战争的内容。基辛格博士在回忆录中披露了美国政府当时的反应，“自朝鲜战争之后，中国一直把美国列为头号敌人，这次却把苏联也列为未来战争的主要交战国。看来中国人真正要防的其实是苏修”。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-中越边界战事纪实（下）","slug":"共和国战争-中越边界战事纪实（下）","date":"2023-05-21T12:45:21.000Z","updated":"2025-09-16T02:08:42.966Z","comments":true,"path":"2023/05/21/共和国战争-中越边界战事纪实（下）/","link":"","permalink":"https://naosense.github.io/2023/05/21/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E4%B8%AD%E8%B6%8A%E8%BE%B9%E7%95%8C%E6%88%98%E4%BA%8B%E7%BA%AA%E5%AE%9E%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"有限进攻 越南刚刚获得统一和新生，中越关系便迅速恶化了。此事足以让世界瞠目结舌。越南当局为什么会对中国突然翻脸？其源流却也无需追溯的太远。可以说，越战期间发生在柬埔寨的一次政变，为后来的中越交恶写下了伏笔。柬埔寨是越南的西南邻国，越战期间，中国的援越物资主要通过柬埔寨的西哈努克港和途经柬埔寨的胡志明小道运抵越南南方。驻越美军对这两条漫长幽深的补给走廊和大部队运动通道深感焦虑，在军事上的办法已尽，于穷尽时打出了一张政治牌。1970年3月18日，美国策动柬埔寨首相朗诺、副首相施里马达发动政变，推翻了对胡志明小道采取默许态度的西哈努克亲王。接着10万美军涌入柬埔寨，大力清剿胡志明小道。当越军的后方补给通道受到严重威胁时，其难堪与被动已尽在不言中。这就是政变后的朗诺。 朗诺集团发动政变时，西哈努克亲王正在出访途中，他很快便作出了反应，在北京领导成立柬埔寨民族统一战线，接着又成立统一战线领导下的亡国民族团结政府，领导国内人民展开抗美救国战争。 美国则在柬埔寨拼奏出一个以朗诺为总理、施里马达为副总理的内阁，接着又选出一个所谓的高棉共和国，由朗诺担任总统。朗诺一上台，立即对西哈努克港下了手，中国援越装备物资中有相当一部分被扣留，致使潜入南方的北越部队面临断炊的危险。中国方面只有加大通过胡志明小道的货运量来弥补北越部队物资的不足。但朗诺的首都金边并不太平，有一支武装力量不断对金边发起袭击，它就是被西方称为左翼革命集团的“红色高棉”。它本来是在反对西哈努克的起义中形成的，60年代还参加过农民起义和部族起义，但在国难临头时，作为柬埔寨民族统一战线的一个组成部分，又参加了反对朗诺集团的斗争，并在整个柬埔寨农村巩固了自己的势力。 红色高棉的斗争在打击朗诺集团的同时，也在保护着胡志明小道途经柬埔寨的路段。胡志明小道在柬埔寨境内的两端，北端是与老挝相连的拉塔纳基里，南端是柴珍省，该省的鹦鹉嘴地区是小道的终点，也是中国援越物资进入越南南方各根据地的转运站。朗诺的军队奈何不了这几处要地，一个重要原因是红色高棉在牵制着朗诺军队，那段时间是红色高棉与北越正规军的蜜月期。红色高棉的斗争浪潮在一定程度上以越南战场的形势变化而起伏。而在那时，美国的尼克松政府明智地认为，美国真正的利益绝不在越南的沼泽和水网稻田之中，因此不断的从越南撤军。由此，越南人民军渐入佳境，进入全盛时期。在河内举行了盛大的阅兵仪式，表示了北越对统一全国志在必得的决心，同时也向世界表明了在印支半岛的这个不大的国家中，拥有一支足以与大国抗衡的军队，这支军队的总兵力已达到150万人，是世界上军队占人口比例最大的少有的几个国家之一。 1975年初，越南民主共和国的领导人坐到了一起，商讨发动胡志明战役，就是在美军即将全部撤出越南之际，发动总攻，一举收复南方，统一全国。但这次战役并不仅仅解决越南一国的问题，还包括向朗诺政权报一箭之仇。朗诺发动政变上台后对胡志明小道的袭扰给越军造成的被动局面，人们记忆犹新，因此总攻中也要一举扫荡金边。 1975年3月，越南军民发动了春季总进攻，并顺利的进行了西元战役和顺化岘港战役，消灭和瓦解了南越第一军区和第二军区的全部军事力量，接着又于4月9日发起了以西贡为主要目标的胡志明战役。在此过程中，越军分兵一部，协助柬埔寨乔森领导的武装力量和以博尔布特为首的红色高棉向朗诺政权发起总攻，并于4月17日解放了柬埔寨首都金边。这比北越军队解放西贡还早了13天。朗诺在金边失守前跑到美国的加利福尼亚州去了。 朗诺的旧账算了了。战争的帷幕在柬埔寨也徐徐落下，但金边却在越军的间接控制之下。这时，一种似曾相识的情绪在柬埔寨人的头脑中渐渐苏醒了过来。 自19世纪后半期以来，越南成为法国的殖民地。在这个国家，法国的殖民统治很深入。越南上层人士普遍说法语，信奉天主教。在印度支那半岛上，法国的殖民地不仅是一个越南，还包括越南的西北邻国老挝和西南邻国柬埔寨。在这三个国家中，越南的面积最大。法国殖民当局是从河内对老挝和柬埔寨进行统治的，或者说，法国人在印度支那半岛建立了一个以河内为中心的越、老、柬三国殖民地组合。作为历史的一个小小的讽刺，为独立而斗争的人有时也会继承前任殖民统治者的帝国抱负。法国人从越南撤出后，在河内有些人的心目中，越南就是法国印支遗产的继承人，而这份遗产中包括了老挝和柬埔寨。在1954年签订的《日内瓦协议》中规定了以17度线划分越南南方与北方，同时规定了非军事区。老挝和柬埔寨的不幸正是在于他们的国土为北越部队绕过非军事区进入南方提供了最便捷的通道。在此后20多年的越战期间，越军充分利用了这两个国家的土地，也随之培植出了把它们与越南结为一体的印支联邦的梦。 漫长的越南战争给越南人捶打出了一支数量庞大的、能征善战的军队，他们装备着中国和苏联的现代化武器，并接收了50亿美元以上的美式装备。既然拥有所谓第三军事强国的巨大本钱，现在是步法国殖民者的后尘，建立印支联邦的最好时机。况且建立这一联邦的所有节目都已在越南战争中彩排过了。为建立胡志明小道，越军控制了老挝的南部。为收拾朗诺，并在柬埔寨树立起一个亲越政权，越军攻占了金边。在越南政府看来，印支联邦已是一锅炒好的菜，再回国热一热就行了。 很多年以来，印度支那半岛举世瞩目。在越南统一后，各大国仍注视着这个难以平静的地区接着会发生什么。为独立苦战了这么久，一旦取得独立以后又要剥夺他国的独立。中国领导人邓小平郑重警告越南，“不要在柬埔寨玩火”，柬埔寨的弦马上绷紧了。这时在柬埔寨掌权的是波尔布特。据其人自述，他年幼时当过和尚，成年后既参加过抗法战争，又曾在法国留过学，归国后以教师的身份从事地下工作，为高棉劳动党创始人之一。朗诺政变后，他领导的红色高棉揭竿而起，担任全国战场指挥部主席。在越军帮他打下金边后，出任柬政府总理、国民军总司令等职，期间大搞极端政策，造成大批人员死亡。他在一定程度上是靠越军的刺刀撑着台面的，但也要维护柬埔寨的独立主权。他要求越南从侵占的柬埔寨岛屿上撤军，又要与越南签订一个意在互不侵犯的条约。博尔布特对越南当局的戒心显露无疑，越南决意要换马了。 1977年年底，越南在苏联支持下，对两年前还肩并肩战斗的柬埔寨发动了武装进攻。这场仗先是打了3个月，在柬人民军的反击中，越军被击毙击伤近万名。而后越南重新调整部署，又以15个师、近10万越军分兵七路，于1978年12月15日再次大举入侵柬埔寨。 1979年1月7日占领了金边，次日即拼凑出韩桑林傀儡政权，博尔布特则躲进了深山。让世界惊异的是，侵柬的成功并没有使越南止步，反倒把它的胃口撑大了。城门失火，殃及池鱼，泰国与柬埔寨有着806公里的共同边界，越南为迫使泰国就犯，承认韩桑林政权，遂陈兵柬泰边界，制造边界摩擦。侵柬越军多次以种种借口对泰国发动军事入侵，不但使泰国边境居民的生命财产遭受损失，泰国的主权和安全也受到了直接威胁，成千上万柬埔寨难民拥入泰国东部边界，数不清的越南炮弹落在泰国村庄，越南小股部队对泰国边境难以计数的进犯和偷袭，给泰国带来沉重的经济负担，造成严重破坏和伤亡。 泰国是美国在东南亚的忠实盟友，但美国在越战中已被东南亚的事情搞怕了，泰国军队只得凭借自己的力量还击越军的入侵。越南领导人对美国无心回到东南亚这点认识的透彻之极，而自己背后又有苏联撑腰，所以放胆撩惹泰国。现在观众看到的画面是泰国陆军拍摄的越南军队侵入泰国边界时，被泰军重创的镜头。 在越战期间，中苏两国都在援越抗美，所以三国间以战争这个大局为重，倒也相安无事。但越战结束，中苏之间的对立又在印支问题上突出出来，而对越南领导人来说，这时已经没有必要在中苏之间走钢丝了。所以只要有苏联作为它的靠山，为它完成印支联邦霸业，而不惜在战争结束的第三年，又在印支学着美国的样子大打出手了。这里是南中国海，在南海的大陆架上发现了储量丰富的海底石油。早在越战尚未结束时，南越当局就盯上了这里的海底石油，并为夺取属于中国领土的南沙群岛，采取了一系列挑衅行动，结果迫使中国南海舰队对非法侵入中国领海领土的南越海军进行了西沙自卫反击战，一举收复了西沙。当时南北越是针锋相对的，但很难说中国海军严惩了南越海军，北越人会心里舒服。 苏联当局对这事掌握的挺是火候，此刻放风说“南海岛屿归属未定”，这实际上是鼓动越南北方政府统一全国后，继续在南海诸岛上与中国一争，默契就这样形成了，它已显示出苏越战略交易的雏形。1975年4月后，越军就占领了南沙群岛十余个岛礁，正式向中国提出对西沙、南沙的领土要求，同时煞有介事地把中国西沙、南沙作为它的领土，在南海诸岛周边领海招商，进行在中国领海开采石油的商业谈判活动。继南越海军之后，统一后的越南海军也派出军舰到南海诸岛水域游弋，以致闯入中国领海并强占中国岛屿，继而在岛上修公事。 1975年9月，继北越军队解放南越全部国土近数月时，中国领导人邓小平就向在中国访问的越南领导人黎笋指出，“中方有充分材料证明西沙，南沙群岛自古以来就是属于中国领土”。本着通过友好协商解决分歧的原则，邓小平做了以后可以商谈的表示。但此后越南不仅没有改变其错误做法，反而变本加厉的抢占南沙群岛岛礁，企图长期霸占，致使这一海域的紧张局势不断加码，并终于在中国南沙群岛的岛礁间引发了武装冲突。事情到了这一步，越南领导人的扩张欲已无法掩饰了。越南当局不顾事态扩大，一面在西沙南沙群岛与中国军队摩擦冲突，一面到处承接外国财团在那里开采石油。越是外商有意向在南中国海开发的石油项目，越南当局越是不惜一切代价，甚至准备与中国在南中国海拼一拼。 1976年12月，越共召开第四次代表大会，老资格的黎笋出任总书记。他在会上做政治报告，提出要继续发展与老挝、柬埔寨的特殊关系。一个本当迅速医治战争创伤的国家，却扭曲地走上了一条扩张的道路。越军堵塞了中越边境的通道，这些战争期间运送援越物资的门户，在战争结束后，倒被长期接受援助的乙方封死了。 越军不断武装蚕食中国领土，制造边境冲突事件，殴打中国的驻路部队。看到这些，人们通常要用忘恩负义、背信弃义来解释。其实作为邻邦国家，越南本不必如此出格。越南所做的这些，纯然是被印支联邦的战略利益所驱动的。中国茹苦寒心援越的目的绝非是为了培育一个小霸王。因此，越南领导人视中国为其建立地区霸权的最大障碍。1977年初，越南国内掀起大规模排华浪潮，仅春夏间就驱赶华侨16万多人。越南以反华换取苏联对其建立印支联邦的支持。1978年11月，苏越双方签订了实质上是军事同盟的苏越友好合作条约，这两国实际上已陷入了恶性循环，即越方对华下手越重，苏方支援它建立地区霸权的力度也就越大。 苏越结盟的次月，越军入侵柬埔寨。而在越南亲柬的次月，1979年1月，中国领导人出访美国，在同美国总统卡特签署了为恢复中美关系提供框架的几项协议后，邓小平在白宫玫瑰园中宣布，“中国将站在柬埔寨一边，反对越南侵略者，甚至不惜承担必要的牺牲”。卡特有些不安，委婉地提起美军在越南的教训，而邓小平则一笑置之，说“我们中国人说话是算数的”。就在邓小平说这话，大批中国军队正向中越边境集结。半个多月后，中国军队的自卫反击战便打响，东线部队要吃掉的头一个目标是越军驻铜登第3师第12团。在友谊关耍枪弄炮杀害中国边民诸事，就是该团所为，中国方面的忍让被他们误以为是软弱可欺，以至于曾放风说，“打到友谊关吃早饭，打到南宁过春节”，但东线部队仅用一天功夫就报销了这个要到南宁过春节的英雄团。 西线部队的第一个目标是老街。老街是名副其实的兵家必争之地，这里既有中国援建的发电厂，也有当年法国人修建的钢筋水泥工事。它们都被越军用之于对中国边防部队的作战。但中国军队的打法十分灵活，经两天激战，几条线一拧紧，便冲入了老街市区的街道。正是在老街这个地方，越南当局出于反华的需要，大肆驱赶华侨，甚至派一个师的兵力包围华侨驻区，把5万家华侨商店和企业抢光。大批华侨从老街回国途中被拦截、毒打，惨遭侮辱。这确是越南欠下中国人民的一笔血债，元江自中国的云南流入越南，在越南境内称为红河。早在抗法战争期间，红河上的界桥就是连接云南和越盟越北根据地的枢纽。在中国援越抗美期间，与中国广西相连的铜登铁路桥成为中国援越物资的运输枢纽，是美军飞机执意要炸烂中国高炮部队重点保护、铁道兵部队重点修复的枢纽。在这次自卫反击战中，越军破坏了它，而中国工程队则又一次修复了它。 从广西近期开进的边防部队，直指越南高坪省的朔江，是省会高平的西北屏障，山石林立，丛林茂密，是最适宜越军作战的地区。但中国部队毕竟是作战经验丰富的英勇之师，朔江旋即被攻克了，拿下了朔江。东线部队，又从西北向高平压过去，攻打高平的主力是广西龙州开进的另一支部队。 越军在通往高平的公路上摆下重兵，构筑了永备攻势，但中国参战部队却从山外冲了出来，一下子扰乱了越军的防御体系。越军没想到中国边防部队会从山外出击，因为这里是喀斯特地貌，到处是溶洞和怪石，很不适合坦克行动。在这种地形上开进，在各国坦克作战史上是没有先例的。但中国坦克居然从牛车小路上开辟了通路，攻下了扶和。扶和是4号公路的一个支撑点，距高平仅25公里。这里的唐场是广西壮族自治区1962年援建。中国参战部队攻克了扶和后，以坦克为先导，沿4号公路向高平急进。越南守军为阻止这支部队，竟扒开了水库，淹没了道路。由于沿途淤泥深达一两尺，中国边防部队弃车步行。 在东线的参战部队中，几乎在每个建制单位中都有一支有着光荣传统的部队，他们或是在红军时期两万五千里长征路上所向披靡的先锋，或是在抗日烽火中威震敌胆的雄师，其中更多的是解放战争中战功卓著的英雄集体。这一次，他们决定在新时期打出新的威风。由于正面进攻部队和穿插部队配合一致，全歼了高平守军，而且由于进攻部队在越军意想不到的方向上出击，大胆穿插，走远路、走险路，从守军背后齐击高平，这使高平守军也大部被歼。中国军队于2月25日一举攻克高平，市委大楼和行政机关被中国士兵占领。中越自卫反击战第一阶段结束了。中国军队在打扫战场时收缴了大批苏军装备，他们大多数是越战时期遗留下来的，也有一部分是苏联当局近年提供的。令人瞩目的是冰雹20122火箭发射架和火箭弹。 必须提及，抗美救国时期，越军的装备主要是由中国方面提供的。如中国生产的仿苏AK47型冲锋枪是越军的基本装备，它的一次装弹量仅30发。一些外国兵器专家认为，无论是外形还是内在质量都比不上美国步兵的M16冲锋枪。但从越战的实践来看，中国的冲锋枪比M16的可靠性强。这些被俘的越南军人中，有的在中国学习过，越军的许多指挥员是在中国培养和深造的，高级指挥员一般入南京军事学院和北京高等军事学院。越战期间，这两所学院中都设有越南班，营连指挥员则由桂林步兵学校训练。 打开越军的仓库，里面堆满了中国援越的物资。此情此景，连年轻的中国士兵也难免发出了与年龄不相称的沧桑之慨。1966年夏，黎笋率代表团访华，要求中国政府加大援助。周恩来重申了毛泽东的话，“凡是越南需要的，我们优先供应”。当时中国政府把越南的援助看作是援外工作中的头等重要的事情，越南部队身上穿的、携带的基本上是由中国提供的。这些往事，在中越这两个重情重义的东方民族中，本应成为中越传统友谊的佳话，却被越南当局如此轻易地抛在脑后，以至于走到了这一般田地。 正是在这一地区，在越南抗美作战期间，1972年至1973年，中国军队先后调动工程部队和民兵8000多人，配备大量工程机械和运输车辆，铺设了5条援越野战输油管线，总长159公里，连同配套建的油库、泵站、通讯设施和铁路专线，共完成土石方10多万立方米。在援越抗美4年中，中国通过这些输油管道向越南输送汽油、柴油近130万吨，占越南北方当时总量的一半。 东线部队完成第一阶段的作战任务后，又返回头去清剿战场，那些躲在丛林山洞里打黑枪的特工，一个不漏的被打扫出来。对越自卫反击战的第二阶段开始了。西线参战部队在攻下老街后，又挥师甘棠，越军急忙调316A师沿10号公路驰援。该师是越军主力之一，号称英雄师。它是苏式装备，越军各部队的班排骨干训练均由该师负责。自卫反击战打响，越南当局称随时准备用该师吃掉中国的一个主力师。 不可忽视的是，越军是经过连续30年战争锻炼出来的一支军队，与法国人和美国人都真刀实枪的打过仗，可谓实战经验丰富。从武器装备上比较，越战结束后，越军缴获了价值几十亿美元的美国先进武器，苏联又援助了大批军援，可以说是用世界上两个超级大国的装备武装起来的一支部队。 越军入侵柬埔寨后，为了推行地区霸权主义，自1978年开始重新征招已经复员的老兵入伍，征兵年龄从16岁至45岁，算是世界上绝无仅有的一个高龄征兵的国家。当时越南在柬埔寨的驻军已超过20万，在老挝驻军5万，总计在国外驻军25万以上，仅次于苏联和美国，占世界第三位。 经过长期战争和多年的扩军备战，越南自视“世界第三军事强国”，但中越双方一交战，号称越军王牌军的 316A师倒几乎被吃掉，它驰援甘棠时，被中国的阻击部队堵在了代乃。代乃阻击战打得很激烈，最终越军没有能够前进一步，而中国参战部队却完成了对甘棠的合围。甘棠并非省会，越南当局为什么要动用王牌部队守住这个不大的城市呢？在越南远不发达的工业中，甘棠是越南重要的磷生产基地。越军被命令死守这个矿区，结果仅两天就被中国军队完全占领了。 拿下甘棠后，西线部队连续战斗，兵不卸甲，马不停蹄，连续攻下朗中，攻下朗多，又攻下风土，随即向沙巴开进。沙巴山高坡陡，易守难攻。中国参战部队既沿公路实施主攻，又分兵一部分奔袭沙巴侧后。3月4日佛晓，主攻部队与穿插部队在沙巴县城会师。在西线参战部队进攻沙巴时，东线参战部队已展开了扩京谅山外围的战斗。 谅山是越南北方的战略要地，是通向河内的大门，由越军精锐部队第3师防守。谅山之战从2月27日8时开始，东线参战部队分兵三路，相继攻占了越军前沿阵地诸要点，中路主力部队由铜登向谅山进攻，左翼和右翼助攻部队进行配合，于28日兵临谅山城下，谅山之敌已被合围。在谅山的东边，东线参战部队某部为策应谅山之战而攻取陆平，合歼守敌123团及其他两团各一部，外加一支越军特工队，又于3月3日强渡齐琼河，占领了弥麦山，堵住了谅山守军南逃之路。 谅山之战是对越反击战的高潮所在。甚为巧合的是，在越南抗法战争中，中国军事顾问团团长陈赓就指挥全歼了谅山的法军勒巴热兵团。对谅山的总攻打响了，齐琼河横贯谅山市，把市区分为南北两区，中国参战部队先攻下北区，而后向南区发展进攻。经过3月4日一整天的激战，攻入南市区的部队拿下了市南部的10座高地。一个战斗班突破火网，攻占了省府大楼。 3月5日下午2时，中国战士冲上了谅山市南的主峰，谅山以南制高点全部被中国部队控制。至此宣告谅山之战结束。通往河内的大门已经打开。从对越自卫反击战开始，一直到攻克谅山，所有的战斗都是在南北部的山区进行的。在山区作战，大兵团难以展开，机械化部队难以施展。而从谅山往南就是一直延伸到河内的平原，这是谅山战斗结束后，我军军事记者拍摄硝烟未散中的我军战士，正是这些新时期我们最可爱的人，用血肉之躯捍卫着我们共和国的尊严，用他们血染的风采体现着我们共和国的光荣。他们将从抗美援朝战争、中印边界战争等等那些我们共和国的自卫战争中的无数英雄一样，永载我军光辉历程的史册。 中国边防部队攻占了谅山、高平、老街3个省会和铜登、陆平、七溪、拖浪、扶和、下浪、朔江、甘棠、沙巴、峰土等17个县市，给这些地区的越南正规部队和地方武装以歼灭性的打击，并摧毁了越军在北部地区针对中国构筑的大量军事设施。1979年3月5日晚，也就是中国参战部队攻陷谅山的当天晚上，新华社奉命发表声明，中国政府宣布，“自1979年3月5日起，中国边防部队开始全部撤回中国境内”。这个决定也是命令一直传达到阵地的最前沿。尊此，中国参战部队全线停止攻击，偃旗息鼓，鸣金收兵，拔寨回撤。 中国参战部队连续作战17天，对中越边境、越南一侧的浅纵深目标实施了多路的有限进攻，已达成了自卫反击战的目的。来也匆匆，去也匆匆。中国的军事记者抓拍了一些越南边民自愿走出家门送行的，这耐人寻味的表情，看不到一场恶战后的心急之状，足以见中越人民几十年的传统情谊是根深蒂固。在中越边界连接的地段上，有一个叫麻利坡的地方，那里有一片静肃的墓地，当年中国援越部队牺牲将士的遗骨就埋葬在那里，后来它又添了一片新x，那是中国自卫反击部队牺牲的烈士们的安息之地，那片秋雨和春雨中的陵园将让我们永远记住我们共和国有这样一段历史。3月16日，中国军队全部撤回了。中国军没有占越南一寸土地，没有在越南留一兵一卒。这表明中国进行自卫反击战所要得到的只是边境人民安全、安逸、安定和安宁。 长期牵制 用现代的眼光回顾70和80年代的历史，越南确实是绑在苏联战车上的一名马前卒。苏联为了和美国争夺世界霸权，60年代竭尽全力的支持越南与美国打仗，目的是尽可能的拖住美国，使其陷在越南战争的泥潭中，使苏联得以在西欧和中东地区加紧扩张。70年代美国从越南撤军后，苏联又竭力填补美国在印支地区留下的空白，这样它又尽力支援越南控制并入侵了柬埔寨和老挝。80年代，苏联为削弱中国在这一地区的影响，又全力怂恿越南与中国为敌。中国对越自卫反击战时，外电普遍猜测中国的作战目的之一是压迫越军主力从柬埔寨回撤。且不说这一说法是否准确，事实是越南领导人认准了中国军队的进攻是惩罚性的，而不可能直捣河内，所以亲柬越军主力按兵不动，任凭中国军队横扫北越边境浅纵深目标也义无反顾，在所不惜。 在发展中国家的大排行中，越南属穷国，其面积不足33万平方公里，4/5为山地，而人口却愈5000万。除了湄公河三角洲是世界著名产稻区外，它没有什么聊以自慰的资源。国情已如此，加之长期战争造成经济严重衰退，越南太需要迅速转入和平建设，以医治战争创伤。 既然如此，它为什么又硬要往柬埔寨的战争泥潭里跳？原因很简单，印支联邦是个无法抗拒的诱惑，况且当时它已有个雏形的毛坯。越南已于1977年夏与老挝签订了合作友好条约，加紧了对这个弱小邻国的渗透和控制，1979年初又占领了柬埔寨。从越南看来，离柬老越三国的印支联邦此时只有一步之遥了。在这种时候，越南政府断然要咬死顶住，也就必然把制造中越边境冲突作为苏联支持其建立印支联邦的筹码，当越军在中越边境所谓收复失地时，苏联则对亲柬越军提供大量军援，直至拉上华约国家，要求联合国接纳越南在柬埔寨炮制的韩桑林政权。 由此，中国边防部队再次反击，收复和保卫了中越边境上的法卡山、寇林山、老山、啫阴山。但这一线仍不得平静，越军以连以下兵力对我军阵地的全线袭扰几乎天天都在进行。在这种全线袭扰的掩盖下，越军也发动较大规模的营以上的重点进攻。越军在这一线的袭扰和中国边防部队的阵地防御作战延续了整整10年。 老山位于云南省马里坡县以南的中越边界上，其地势险要，为天然门户，从老山主峰能看至中越分界线南北各20公里。在老山战场，中越军队长期对峙，双方均构筑了工事，形成了较完整的阵地统计。越军仗着适应热带山越丛林的自然条件，自80年代初便经常对中国边防部队实施骚扰和偷袭，大至营以上规模的进攻，小至班排的偷袭几乎天天都有，偷袭不成便立即在炮火下转入强攻。中越两军的边境对峙，近者双方相距百八米，远者相距千八米。由于相距太近，我边防部队为避免不必要的牺牲，在兵力部署上少摆多屯。最前沿的少数兵员在越军眼皮底下食宿，他们就这样坚持了数年。 中越双方在前沿附近及人员可通行的间隙地，主要以埋设地雷限制对方的机动和偷袭。随着作战时间的推移，双方埋设的地雷日益增多，有的地区平均每平方米埋有数颗地雷，形成了很难识别的纵横交错的地雷区。布雷、排雷成为前沿指战员的主课。中越边界旷日持久的战斗多为分队的山岳丛林攻防、袭击及反袭击，协同主要是前沿分队与营或连属火炮之间的协同。作战规模通常不大，但事关国威，军威。前沿将士奋不顾身，寸土必争。在持续的作战中，在敌我犬牙交错，气象、地形条件异常复杂的条件下，伤亡时有发生。他们用生命和热血捍卫着祖国的每一寸土地，的确是新一代最可爱的人。又一次战斗打响了，这是发生在80年代后期的一次边界战斗。越军的来势很凶，但已是强弩之末，原因是靠山在变。苏联新领袖提出了新思维，根据这种思维，舞枪弄炮的越南失宠了。自1979年开始，越南把中国当作它最直接、最危险的敌人，军队把中国当作新的作战对象，越南党甚至向全党提出“一切为了打败中国”的口号。1979年，中国军队被迫自卫还击后，马上主动回撤，但在边境地区保持一定的军事压力。诸如在我国云南境内的老山地区，敌我双方围绕国界线长期对峙，我军依托坚固工事，不时向对方实施反袭扰。这样，越南始终处于长期的军事拼耗中。整个越南始终处在一种全国性的戒备状态，国民经济也始终处于战时体制，中国这种牵制性的策略一直持续了10年，越南也战备了10年。 倡导新思维的戈尔巴乔夫也难以安抚庞大的苏联。1991年，苏联发生了震惊世界的819事件，同年底，苏联消亡，东西方冷战已告结束。随着苏联的解体，越南开始自食其与中国交恶十年的恶果。至80年代后期，越南国内规定平均每人每月供应2公斤大米，买一公斤盐要花掉每月工资的一半。而在中越边界战事发生的1979年，苏联给予的援助平均每天为250万至300万美元。这一切都用于庞大的战争消耗。苏联解体了，越南也就无息可喘。1989年9月，越南在没有任何国际监督的情况下，宣布已从柬埔寨全部撤军。其实越军当时并没有全部撤出柬埔寨，余下的直到90年代初才撤出。 霸业的梦幻消失了，越南军队回到了属于自己的一方山水间。他们必须正视的是因长期战争而百孔千疮的国家和已经疲惫不堪的人民。而随着越南在印支半岛势头的收敛，中越边境上也平静了下来。星移斗转，今天老挝人过得挺安分，西哈努克又回到了柬埔寨，越南没有得到本来就不属于它的一寸土地，但得到了一个最大的实惠，这个国家终于摆脱了万日战争的影响，回到了宁静的、平和的建设之中。 发生在中越边境上的战事延绵达50年之久。在这半个世纪间，中越两国走过了风风雨雨，也生出了恩恩怨怨，从生死与共到反目成仇，再到重修旧好，历史绕了一个苍凉的大弯。但也正是历史江流的回旋，丈量出了中国奉行无产阶级国际主义的尺度。在历史上，越南曾几度被纳入中国的版图。公元前111年，汉武帝平定南越，设交趾，交趾共9郡，南端3郡即今日越南的北半部。交趾，在东汉时改为交州。从三国到六朝，中国移民频繁。南宋时封交趾郡王为安南国王，至明朝永乐年间，尚将安南置于直接统治之下。越南自古对中国有挥之不去的戒心，对此无需讳言。这是二千年的历史挤压出来的，是几度王朝战争积淀下来的。但20世纪中期诞生的新中国，却把援助越南获得独立和统一视为己任。然统一后的越南转身北犯时，中国军队教训了它一番，又从原路收兵。而当越南因连年征战而陷于困境时，中国又洒脱的把旧怨撒入浩瀚江河。 中越边境战事延绵50年，中国没有因付出血汗辛劳而索要一分权，更没有因巨大的军事优势而夺取过一寸土。古老的长城作证，从封建帝国到老牌殖民国家，从帝国主义列强到资本主义强国，哪朝哪代哪国可以企及今日社会主义中国所为，灵气所中，天造地设，巍峨重峦，大江聚川，培植出的气度，文明的辉煌进步抚育出的风度，拥有万里长城的国度，也就有了足令天下叹服的尺度。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-中越边界战事纪实（上）","slug":"共和国战争-中越边界战事纪实（上）","date":"2023-05-20T11:53:50.000Z","updated":"2025-09-16T02:08:42.966Z","comments":true,"path":"2023/05/20/共和国战争-中越边界战事纪实（上）/","link":"","permalink":"https://naosense.github.io/2023/05/20/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E4%B8%AD%E8%B6%8A%E8%BE%B9%E7%95%8C%E6%88%98%E4%BA%8B%E7%BA%AA%E5%AE%9E%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"大军压境 这是一条普普通通的公路，又是一条很不寻常的公路。说它普通，是由于在中国的大西南随处可见这种盘旋蜿蜒于群山间的公路。说它不寻常，是由于沿着这条弯弯曲曲的公路，可以抵达到中越边境，及至进入越南社会主义共和国境内。 1979年初，从中国内地调来的几个野战军陆续向中越边境地区集结，他们是中国陆军的作战值班部队，这次集结是准备打一场有限的边境自卫反击战，所以对外统称中国边防部队。中国的海军和空军也进入了战备，但只担负警戒保障任务，不投入战斗使用。 这里是中国边防部队西线的一个指挥所。中国有两个省与越南交界，东边是广西省，西边是云南省。集结在中越边境上的中国边防部队，也因此分为东西两线，东线部队又称为广西边防部队，西线部队则称为云南边防部队。他们分别有两名资深上将指挥，东线总指挥为广州军区司令员许世友，西线总指挥则为武汉军区司令员杨德志。让中国的指挥员们服拊膝常叹感慨万分的是，无论是从东线突入，还是从西线打入他们将要进攻的地域，正是二十几年前中国人民援越抗法开展边界战争的地带，那里有数不清的中国援越烈士的坟茔。中国军队是比较含蓄的，而对这次作战对象却保孕着难以名状的怨愤。问问每一个准备开赴前线的中国士兵，在现代战争史上哪一场战争历时最久？他们都会回答是越南战争。这场战争从40年代中期延绵到70年代中期，整整打了30年，而中国人民的心也被悬了30年。在这一万个日日夜夜，中国人民把支援越南人民抗法抗美当作自己的事。中国是一个穷国，人民的生活绝不富裕，占中国人口大多数的农民一直是面朝黄土背朝天。中国的援越是勒紧裤腰带进行的，特别是援越的高峰期，正是中国国内最困难的十年动乱时期。但中国人民宁可自己缺衣少穿，也要支援越南人民打下去。然而，只有中国军民自己知道，在胡志明主席逝世后，中国人民的一番茹苦寒心，从越南领导人那里并没有得到多少感情上的回报。对此，中国有思想准备，也能理解。援助越南救国战争的国家为数不少，也包括与中国交恶的苏联。越南领导人需要从各个方面援助，也必须在援助的大国间搞些平衡。殊难预料的是，在越南统一后，越南竟一下子走出了那么远，比所能想象到的情况还要遭，以致迫使中国要还以颜色。 1979年2月上旬，云南和广西部队已进入前沿阵地，在他们的面前，是另一个社会主义国家的青山翠谷。 亚洲最骁勇善战的两支军队已是剑拔弩张，交手在即。任何一场现代战争的起因都是复杂的，都有长久的矛盾酝酿过程，更何况患难之交间，反目成仇。在大战将临之际，不妨先坠回历史的深部，追溯曾长期作为越南人民的朋友加兄弟的中国人，是怎样迫于无奈地走到了对越自卫还击作战的阵地前沿的。 位于印支半岛东岸的越南，历史上曾几度被纳入中国封建王朝的版图，而自1883年后则沦为法国的殖民地。第二次世界大战之初，1940年9月为德国盟邦的日本为切断盟国通过印支半岛向中国输入军火的通道，出兵侵占越南，驻越法军只经过草率的抵抗便被缴械了。 由于日本与维希法国间始终没有处于战争状态，所以日军在占领越南后，在牢牢地握住控制越南的实权的同时，表面上仍承认越南是法国的领地。这样一来，数千万越南人民实际上处于风头正盛的日本和只剩半壁江山的维希法国的双重统治之下，二战期间越南境内没有发生过值得一提的战役，只是越南人民抗日驱法的斗争构成了二战史中有声有色的一章。值得一提的倒是日本也要把法国驱除越南。越南原本有个1926年继位的末代皇帝宝大，宝大是在法国受的教育，这时却成了日本的傀儡。卧榻之侧岂容他人酣睡？日本占领军借宝大的嘴宣布越南从法国殖民统治下独立，进而解除法军的武装，关押进集中营，以肆无忌惮地掠夺越南的农产品及作战急需的橡胶。 在越南人民的抗日独立运动中，崛起了一位传奇式的领袖，他就是胡志明。胡志明1890年出生于越南一安省，1920年在法国加入共产党，1925年在中国广州组织越南青年革命同志会。1930年领导建立越南共产党。1941年发起建立越南独立同盟，简称越盟。越盟的抗日游击队主要活动于中越边境地区。当时越盟最重要的北坡游击根据地就在越南高平省广县，紧邻中国广西靖西县和纳坡县。因此越南的抗日武装与中国的抗日组织有密切的联系。同时，美国政府为了支持越南抗日，由中央情报局向越盟派出了顾问，美国陆军也派出了几十名军人帮助训练越盟的游击战士。 1945年春，盟军在太平洋战争中大举反攻，势如破竹。德国无条件投降后，日本陷入完全孤立的境地，所侵占的南亚领土相继被盟军解放，这时冷战还不曾发生，盟军也来不及摸清越盟部队的根基是不是共产党。事实上，早于1941年5月，印支共产党中央第八次会议在北坡召开，与会的各方游击队领导人一致推举胡志明为越共党的总书记，直接领导越南革命。因而越南总起义的时机日臻成熟。 1945年8月15日，侵越日军无条件投降，已发展到几十万人的越盟部队发动了八月革命，迅速占领了河内。胡志明于9月2日发表了越南民主共和国独立宣言，并任越南民主共和国临时政府主席。但这时的法国却要重新确立对于印度支那半岛的控制权，而天时又偏偏给了法国老牌殖民者一个机会，《波斯坦协定》规定由中国军队解除越南北方的日军武装，英国军队解除越南南方的日军武装。英国是以殖民地独步天下的，自然支持法国卷土重来。英军在9月12日抵达南方后，法军尾随英军登陆，并与刚从日本集中营放出来的法国步兵团会合，在英军配合下占领了西贡，随即宣布越南仅是法兰西联邦的一个自由邦。 1946年5月30日，胡志明以法国政府贵宾的身份被邀请到了巴黎，与法国政府就越南南北统一、越南民主共和国的外交权等一系列问题进行商谈，但法国政府坚持要全面控制越南，双方陷入僵局，胡志明无奈间返回越南，法军这时已占领越南南方，法国政府随即把纳瓦伦将军派到了越南，由他统辖一支主要由外籍兵团组成的法国远征军，踌躇满志地准备征服整个越南。法国跟日本学了一手，也打出了末代皇帝保大这张牌。越盟执政时，保大躲到香港过花天酒地的日子。法国人来了以后，先让他在越南任临时首相，后赴皇帝位。 自拿破仑那个时代起，法国陆军便在欧洲创下了骄人的战绩，也由此形成了优良的军事传统。但在二战中，法国陆军刚打了几周便一败涂地。战争结束后，战功卓著的几大盟国军队偃旗息鼓了，而先后瑟缩于德军、日军铁蹄下的法军却不甘沉寂地杀了出来，在印支半岛的一个小国，向武器极其简陋的越盟大开杀戒。 1946年11月，法国舰队运载2万法军在越南北方的重要军港海防登陆。据布列颠百科全书记载，法国海军此次炮轰海防，杀死平民6000人以上，从而引发了第一次印度支那战争。法军占领海防后，作出了对越南北部发动全面进攻的决定。当年12月，法军对越南民主共和国首都河内发动总攻。12月20日，河内失守，胡志明被迫转移至北部山区展开游击战争。 在西方的与会中，越南抗法战争被称为第一次印支战争。60年代和70年代的越南抗美战争被称为第二次印支战争。越盟在抗法战争初期，军队已锐减到2万人，只得退到北部靠近中国的地方与法军周旋。法军在10万以上，凭借优良的装备向北方边扫荡边推进，重点是进剿越盟在抗日战争中建立的越北根据地。 法军曾一度占领过胡志明的总部。其实越盟领导人刚刚转移，炭火还是热的，越盟这时的日子不好过，他意欲以中国西南边境地区为庇护，但法国政府与的西南军事力量达成了默契，不仅共同遏制越盟，而且把少量的溃败将军秘密的编入了越南伪皇帝宝大的军队，越盟处于前后夹击之中，在它处于最困难、最危险的时期，中越两国人民的传统友谊发挥了重大作用。 1949年10月1日，中华人民共和国成立了。3个月后，中国政府与流亡在北部山区的越南民主共和国政府建立了大使级外交关系。1950年1月底，胡志明第一次出访新中国，他代表越共中央向中共中央提出援越抗法的请求。新中国才刚刚成立，百废待兴，但很快便把援越物资运入越南北部根据地，同时在中国境内轮训并装备越军主力部队。 这年夏天，中国赴越军事顾问团正式组成。自1950年12月开始，中国军事顾问团协助越南人民军部署指挥，完成了一系列战役，共歼敌6000余名，其中一半是法军的主力机动部队。自此后，在临近中国边境的地区内，法军便完全失去防卫力量了。在法国人日子不好过时，美国政府运来了武器。美国人一向标榜自己，反对任何形式的殖民主义。据美国历史学家称，美国政府起初是承认越南民主共和国的，并敦促法国政府也接受这一既成事实。但后来看出河内政权从根子上是共产党当政，于是变卦了，转而支持法国人重新回到越南。 早在二战结束后不久，美国外交官乔治凯南就提出过遏制政策，主张以军事包围、经济封锁、政治颠覆，特别是局部性的武装干涉和持续的政治冷战来遏制社会主义国家的发展和影响。这一政策对杜鲁门政府的外交方针产生了直接影响。法军和越南人民军在靠近中国边境地区的战斗，中国军事顾问和军用物资的投入，使美国政府更清楚地意识到法国人是在跟什么人打仗了。从这时起，越南被美国纳入了遏制战略的大格局中。 1950年，美国陷入朝鲜战争，而在法国国内则掀起了反战热潮，人民走上街头要求政府从越南撤军。在这种时候，法国为了不丧失它的战前殖民地，于1950年12月派原西欧联盟陆军司令戴拉德塔西尼出任印度支那法军远征军司令。塔西尼一上任，即紧急集中法国取得欧非级部队，建立起一支强大的战略机动力量，同时大规模发展伪越南政府军。美国政府也不失时机的把二战的大量剩余物资运往越南，以支持那里的法军组建机动部队。 1953年，朝鲜战争停火，美军和中国军队结束了在朝鲜半岛上的胶灼状态，仍保持着巨大战争机器的美国和急需转入和平建设的中国，不约而同地把注意力从朝鲜半岛转到了越南。在朝鲜战场上，中美两军是面对面厮杀，而到了越南，却都有意避免迎头相撞，只通过各自支持的乙方来较量。在美国，这时的总统是二战中的盟军最高统帅艾森豪威尔。1953年下半年，美国副总统尼克松来到西贡，鼓励沮丧不堪的法国人继续打下去，并捎来了美国政府的保证“法国用于这场战争的经费80% 可以向美国政府报销”。法国也相应调整了在越南的部署，撤换了印支法军统帅后，从本土和北非抽调了12个营驰援侵越远征军。 1954年春，全世界的注意力都被吸引到了越南西北山区一块小平原上，它四面环山，交通闭塞，却是接连越西北和老挝的战略十字路口。这就是军事要地奠边府。几个月前，法国伞兵在纳瓦伦指挥下，以突袭方式占领了这里。此后，法军越聚越多，达到16000人，其中一半以上是外籍军团，而且配属了空军。奠边府是一次斗法。法军的意图是凭借地面火力和空中优势，把越军主力引诱到这里，加以全歼。越军则将计就计，集中大部队，务求全歼这里的法军守军。法军决定在奠边府决一死战。当法军正检阅授勋给部队打气时，指挥奠边府战役的越南名将武元甲已命令越南人民军的几个主力师，日夜兼程，往奠边府地域集中。几万农民披星戴月的挥稿抡锄，长宽了通往中国的运输线。中国政府出动了600辆卡车，从中国境内出发，向奠边府前线赶运包括重型火炮在内的作战物资。中国军事顾问直接配备到了越南人民军主力部队师团2级。 至1954年3月上旬，越南人民军包围奠边府已近3个月。中国总理周恩来向中国军事顾问团指示，苏、美、英、法以及中国五国将于4月间在日内瓦召开会议，讨论朝鲜和印支问题。为争取外交上的主动，希望能与朝鲜停战前一样在越南打个漂亮仗，越共中央接受了中国这一建议，遂于3月13日开始最后的总攻。 越军4个步兵师、1个炮兵师共35000人，向奠边府法军展开了猛烈的进攻。在战役开展后不久，越军就占领了芒青机场，切断了法军中心防区与南区的联系。中心区不仅孤立无援，而且处在越军的炮火之下。在这个防段，法军引为自豪的空中优势被瓦解了。法军外围阵地不断失陷，逐渐往中心地带收缩。 美军为奠边府的法国守军组织了大规模空运，但由于法军控制的区域越来越小，空投作用不大，到4月下旬，法军全部被挤压在核心地带。5月7日下午5时，越军发起了总攻，奠边府法军最高指挥官及司令部人员均被俘。法军在奠边府的惨败震动了法国朝野，法国人希望以下野的戴高乐将军出山收拾残局。奠边府战役共毙伤俘法军16000人，法国政府下半旗为奠边府阵亡的将士致哀。在奠边府战役的后期，中国总理兼外交部长周恩来率中国政府代表团赴日内瓦，出席讨论和平统一朝鲜问题和恢复印支和平问题的日内瓦会谈。奠边府大捷是越南代表团处在有利地位上，有力地配合了日内瓦会议的外交斗争。 但这时的法军仍舍不得从他们已经经营了半个多世纪的印支国土上立即撤军。胡志明发出了决战决胜的号召。在人民军的打击下，法国殖民军在越北平原逐步收缩，至7月上旬，在越北红河州，法军全部龟缩到海防河内、山西一线及两侧的狭窄地区，其余全部被人民军所控制。越南形势发生了根本的变化，而这种形式又对日内瓦会议产生了重要影响。会议期间，周恩来与苏联代表团团长莫洛托夫、越南代表团团长范文同互通情报，协同步调，互相配合，力争主动在印支问题上取得了满意的结果，最后迫使法国停战，承认越南民主共和国的合法地位和以北纬17度线为临时军事分界线。 越南的国土形状像一根扁担，挑着两个竹篮，中间这根扁担则又细又长，最窄处仅50公里，17度线大体刻在扁担的中间。南方面积为17万多平方公里，北方面积为15万多平方公里。越南被沿北纬17度线划为南方与北方，但无论是南方或北方，都对过去的敌人采取了恐怖的报复手段。北越是对替法国人做过事的人，南越则是对反对过法国的人。双方隔着一条17度线疯狂掠杀，以泄一个民族分裂的怨怒。越南人也随之动荡起来，人们可以按自己的意愿选择南方或北方。按西方的估计，在迁徙人口中，大约有100万北越人背井离乡，举家前往南方，他们中间大多数为天主教徒，有的是乘美国军舰到达南方的。与此同时，大约有几十万南越人迁往北方去投奔胡伯伯。在抗法战争期间，中国是唯一向越南民主共和国提供军援的国家。当然，中国提供军援的目的是为了越南的统一，而不是为了越南的分裂。在中国参加签署的《日内瓦协议》中，要求17度线两侧的人民在两年内举行大选，统一全国。而就越南当时的情况来看，这个要求显然是空中楼阁，因为自法国人走了以后，美国人又来了。 兵出国门 这种多管火箭炮及炮弹是中国的军工企业生产的，中国曾把它们大批的无偿援助越兵，而时下又要用它来打击侵犯中国边境的越军，此一时，彼一时，曾几何时，越南当局给自己酿下了这样一杯无以下咽的苦酒。对越自卫还击作战于1979年2月17日晨打响，中国边防部队从广西龙州、靖西、云南河口、金平展开，对侵犯中国边境的越军进行自卫还击，然后发起反击，打击当面越北边境浅纵深地区的越军。 这是东线的广西边防部队在发动进攻。广西边防部队的重头戏是出友谊关，顺着滇越铁路一路打下去，先攻下越北重镇铜灯，在下河内的东北屏障谅山。而从谅山乘火车到河内，不过是数小时的路程。对友谊关铜灯谅山这个不大的三角地带，中国人是再熟悉不过了。在短短的80多年间，中国军队曾三次在这个三角地带作战。1885年春，清军将领冯子才率军与法国殖民军大战于镇南关，直至把法军驱逐出谅山等地。在50年代的边界战役中，中国军事顾问团与越南人民军曾重创谅山法军，到越南抗美战争中，友谊关、铜灯、谅山、河内一线铁路是中国援越物资的主要运输线，为了保证这条铁路的畅通，毛泽东决定拆除山西铜浦路的铁轨，连相应的机床和车厢一同运到这里。而至越南统一数年之后，中国军队第四次打到这里。如何解决对出国作战正义性的认识？部队政工人员反复向参战人员宣讲，“越南蚕食我国领土，不但向我开了第一枪，而且已经开了几千枪、几万枪，我军是被迫自卫还击”。用许世友将军的话说，“既然徒弟打了师傅，那就莫怪师傅对徒弟报以老拳了”。 在东线部队向铜登发起进攻的时候，西线部队展开了攻打老街的战斗。老街是越南西北重镇，原为黄连山省省会，它紧邻中国的河口县。当年中国援助越南人民抗击法军时，老街是重要据点。援助越南人民抗美时，老街又成为中国高炮部队的重要防空区域。从中国境内有两条铁路通往河内。广西方面是出友谊关，经铜灯谅山到河内。云南方向则是出河口经老街到河内。红河是西线部队反击当面越军的一道障碍。2月17日下午1时，中国右翼部队主力度过了红河。当中国右翼先头部队在老街以西横渡红河时，左翼部队在老街以东80余公里的地段上向越军发起反击。当年法国人和美国人之所以在越南总吃败仗，一个重要原因是他们的现代化武器适应不了越南的复杂地貌。而在山石密林间，越军却可以充分发挥游击战的特长。但中国军队既能打正规战，又是从游击战争中起家的，大有打游击战的特长。所以越军分散钻洞也好，小股阻击也好，都撞到了行家手里。 对中国军人来说，老街是一个旧战场，此次作战是故地重游，他们熟悉这里的山峦和草木，但此番重来，却失去了以往那种熟悉的情绪。当中国战士在北越的山区中攀援搜索时，对手既是过去的同志加兄弟，又是今天的敌人。中国军队昨天曾为这些同志加兄弟的民族解放流淌过汗水和血水，今天为制止他们的民族沙文主义的恶性膨胀，又一次流淌汗水和血水。自2月17日凌晨开始，中国约20万参战部队在广西和云南两个方向上齐头并进兵出国门。 1954年10月，最后一批法国殖民军在海防港登船撤离越南。而在法国人离开时，已有一个数百人组成的美国军事顾问团到达越南南方。自从在朝鲜战争中吃了亏以后，美国已决心不再卷入亚洲小国的内部冲突。艾森豪威尔总统之所以把军事顾问团派到越南来，本意只是训练南越部队，而绝不是让美军来此地打仗。吴庭艳却要把美军拴在越南的战车上。其人50多岁，未婚，是个天主教徒。宝大皇帝委任他当首相时，世界尚不知他系何许人也。到他废除了帝制，把宝大踢下了帝位，代之以吴氏家族统治后，人们才知道这个人也是个封建恶棍。他拒绝在越南全国自由大选的《日内瓦协议》，在南越搞选举，成了南越第一任总统。他的家族成员在政府中担任要职。 吴廷艳为了把总统的位子坐稳，请求美国加大援助。他说，北越是中苏控制东南亚的工具，南越是西方反对共产主义的重要堡垒，美国则把对南越的援助看成是美国战略利益的一个重要部分。1959年，北越决定用武力向吴庭艳挑战。当时越南方只有一支几十万人的军队，战斗力远逊于北越正规军。北越派遣了大批干部潜入南方，同时还有大批正规军随着难民南下，南方游击队不断壮大，两年内人数增加了5倍。60年代初期，吴庭艳政权大搞战略村，强令靠近分界线的居民搬迁到统一设防的大村落中。吴庭艳要求美国签订一个保证越南安全的协定，肯尼迪增加了对南越的军事援助，并转告吴庭艳，“如果他进行政治改革，美国将提供更多的军事援助”。吴庭艳同意了。美国第一批直升机部队到达南越，从而直升机在战争史上第一次投入地面战争。美国人用新的丛林战术对付南越游击队，但南越游击队控制的大部分农村牵制了了西贡的20万军队，战争每天消耗100万美元。 1963年5月，南方爆发了佛教徒抗议吴庭艳统治事件。佛教徒的游行引起暴力镇压，政府经开枪杀死9名和尚。6月11日，一位广德和尚用特殊方式表示了抗议，他坐在大街上安静地待其他和尚往他身上浇汽油，然后从容的划燃火柴使自己顿时化作一团烈焰。而后又有5名和尚以自焚抗议。随着事件的扩大，有40人被打死，几千人被捕。一场大的政治危机威胁着吴庭艳的家族统治。吴庭艳的弟媳对记者说：“每次看到这些所谓的圣人进行烧烤表演时，她都高兴地为他们鼓掌。”8月，吴庭艳宣布军事管制法。吴庭艳政权对此事件的反应不仅震怒了东方，也激怒了西方。美国政府从中悟到，美国的本意不过是防止越南这张多米诺骨牌倒塌，但实际上所做的却是在保卫一个臭名远扬的、不得人心的、横征暴敛的、腐败至极的寡头政权，于是决心干掉曾被他们比喻为“东方丘吉尔”的吴庭艳。 1963年8月，南越将领和中央情报局制定了一份暗杀吴庭艳的计划，美国政府秘密研究了这一计划后批准执行。11月1日，南越军人发动了政变，并于傍晚攻占了总统府，但吴庭艳及其弟吴庭儒已通过秘密通道潜逃了。次日，政变当局抓住了吴氏兄弟，立刻把他们处决了。事后，在一辆装甲运输车里发现了他们的尸体。他们身着天主教神父的长袍，满身弹洞。 三个星期后，亲自批准暗杀吴庭艳的美国总统肯尼迪也被暗杀了。约翰逊以副总统的身份继任总统，他很想像他们的前任一样干点什么。可悲的是，他把宝押到了越南战争上。正是在他的任期内，越南战争演变成了真正的战争。 北部湾，国际上统称东京湾，位于越南北部和中国雷州半岛海南岛之间，即南中国海的西北部。1964年8月2日，美国驱逐舰马克多斯号和特纳乔伊号闯入越南北方临海，被越南海军驱逐。美国方面称，美国舰艇受到越南鱼雷艇的攻击。8月4日夜间，华盛顿散布消息说，美国舰艇遭到越南鱼雷艇的第二次袭击。这就是震惊世界的“北部湾事件”。实际上，数年后，美国参议院外交委员会才获悉全部真相。这一所谓事件是美国军方捏造的，而在当时，他却成了约翰逊政府与北越军事摊牌的口实。 8月7日，美国国会给总统开了一张空白支票，让约翰逊任意对北越采取军事行动。美国国家安全委员会提出分两个阶段轰炸越南北方的方案，第一阶段，即72小时后对北越进行报复性空袭。第二阶段，继30天后连续对北越进行轰炸。约翰逊同意制定这一方案。当约翰逊宣布他的决定时，美军飞机已经离目标不远了，目标就是分界线北侧的军事设施，重点是油库和水面舰艇的停泊基地。 成百架美国战斗轰炸机越过17度分界线进入北越，各种目标都遭到了袭击，桥梁、铁路、港口都受到了严重的破坏，大批飞机进行狂轰滥炸，然后是短暂的停顿，即所谓的间歇性空袭，炸一炸，停一停，看看北越的反应，看看北越是否有妥协的意思。美国人认为轰炸可以使北越屈服，而北越则决心作战到底。战火烧到了北方，美国连续4年的轰炸从这时开始了，这是越南总理范文同在视察轰炸现场，他和武元甲为胡志明的左膀右臂。由于美国人质疑要与越南北方大打，北越也随即对美军基地开了杀戒。双方的动作越滚越大，战火也越燃越凶。越军袭击了西贡附近的波莱谷美军基地，作为报复，约翰逊下令轰炸了河内，越军又袭击了归人的美军设施，约翰逊则下令加强对河内和南方民族解放阵线控制地区的空袭。 美国轰炸机飞临北越的上空时，北越军队也潜入南方，给美军送去了炸弹。在那段时间，西贡市内美国兵经常出入的咖啡厅、舞厅遭到了炸药包的回报。北越没有轰炸机与美国抗衡，但不乏敢死队员，约翰逊把越南称为“露着屁股的四等小国”，他却未料到这个小国有如此的坚韧。 1965年3月，美国政府实施了“滚石计划”，它是五角大楼用一年多的时间制定的，用大批轰炸机轮番轰炸北方的计划。从那以后，美国在越南投下了800万吨炸药，相当于第二次世界大战总量的4倍。但约翰逊也知道，炸弹并不能使一个民族屈服，轰炸不断升级，但没有吓倒越南北方人民，反而使他们逐渐适应了战争。他们把作战物资疏散开，化整为零，避免了更大的损失。 美国政府还作出了派地面部队直接介入越南地面战争的决定。1965年3月8日，美国首批海军陆战队员3500人在越南中部的岘港登陆，它使越南南方的美军人数达到27000人。从那以后，美军就源源不断地进入越南南方，侵越战争也从此升级为以美军为主的局部战争。 约翰逊把一批又一批的美国士兵送往越南战场，而他的国防部长麦克纳马拉却开始怀疑这场耗资巨大的战争是否值得。 与此同时，在南越出现了“越南南方民族解放阵线”的统一组织，各界群众数以万计的人民奋起自求解放。 至1966年，美军参战人数已达30万人，南越军队已达50万人，但这支80万人的大军几乎不知道战场在哪里。南越游击武装控制着农村地区的一半，以小分队的形式活动，在各村庄挖有地道，在道路上则搞伏击。美军适应不了这种打法，土生土长的南越军队的战斗力又极差，同样不知道如何应付这种新奇的战争。侵越美军司令威斯特摩兰的基本战术是搜索并歼灭，其战术单调而程式化，一旦发现所谓越共，空军就在发现地点轰炸，如离海岸不远，则用海上炮火袭击。在空中和海上炮火准备之后，地面部队就搭载直升机迅速赶到。这种战术处处被动而收效不大，美军伤亡人数则不断的增加。 越南北方对付美国空中优势的拿手戏是发动全民打美国飞机。当任何一架美国飞机出现在天空时，高空飞行的有苏制萨姆导弹拦截，低空俯冲的有中国援助的高射炮群轰击。在田间，在工厂，在城市的每一条街道，每一座民居中，所有军民使用的所有武器，有现代的轻重机枪，有二战时的单发步枪，一起把子弹向天空射去。高度现代的超音速美国飞机说不定就被满天飞舞的铅质弹丸偶然击中某个要害部位，轰然坠向地面。 但美国的轰炸还是给河内造成了巨大损失。美军轰炸机的主型是B52战略轰炸机，它是为扔原子弹设计的，机身长49米，载弹量为27吨，巨大的弹仓可装100枚炸弹，有8个发动机，可在1万米高空飞行。在当时的条件下，是一个地面看不到也听不到的高度，因此有很大的隐蔽性。 就在越南居民最困难的时刻，中国政府又加大了援助力度。1965年4月，也就是美国首批海军陆战队在岘港登陆的第二个月，胡志明主席把越南北方代表团派到北京，要求中国扩大援助规模，并向越南派出支援部队。派部队赴越是个很大的问题，同朝鲜战争类似，这就意味着中国军队又要同美军交手了。 但经中共中央审慎研究，国家主席刘少奇对越南北方代表团明确表示，“凡是你们需要的，我们这里有的，我们尽力援助你们。你们不请，我们不去，你们请我们哪一部分，我们哪一部分去，主动权完全掌握在你们手里”。当月17日，中央军委命令组建援越部队一、二、三支队。中国部队是秘密进入越南的，在越南执行对空作战、工程建设等任务。 1965年6月，中国援越部队师出友谊关，他们的目的地是越南东北群岛和几个重要港口构筑防护工程，火炮阵地，抢修被炸坏的桥梁和渡口，尽快恢复铁道运输，让中国的援越物资源源不断地运到北方支援南方。中国的高炮部队则直接参加了战斗，在越南的三年零九个月中，对敌作战2153次，击落敌机1707架，俘虏美国飞行员42名。中国是越南战场辽阔的大后方，中国援越部队和越南居民一起承受着美国的炸弹。越南战争的意义早已超出了多米诺骨牌理论的轨道，而是成了东西方在局部范围内的一次认真的又颇有耐性的较量。 美国国内掀起了剧烈的反战运动。美国人实在不明白，把美国兵派到万里之遥的越南是为了什么？被越南搞得焦头烂额，心力交瘁的约翰逊被迫作出了停止向南越增派军队和暂停对北越轰炸的决定。作为政客，他想看看河内有什么反应。河内作出了积极反应，减少了进攻次数。这一来一往间，双方都让了步，他自然产生了一个后果，双方同意举行初步和谈。不久，约翰逊下台了，他给继任的尼克松留下的是一个已坐到了谈判桌前的越南。 1970年2月，美越两国代表开始在巴黎举行秘密磋商。1972年初，美越巴黎和谈的美国代表基辛格又随着美国总统尼克松正式访华，中美关系开始正常化。这就必然在越南战争问题上反映出来。在尼克松眼里，越南问题只是同中国政府谈判的筹码，尼克松为了同中国和解而牺牲了越南，巴黎和谈达成协议：1973年3月29日，美军开始从越南撤军。美军撤走的一年半以后，越南北方决定统一全国。1975年3月4日凌晨2时，北越军队在军事分界线上发起了总攻，3个装甲师仅用4个小时就突破了南越军队的防线。南方总统阮文绍向美国紧急求援，美国政府给了他一个冷漠的答复，“不要再指望美国人了。越南的情况再糟糕，也没有美国什么事了”。 1975年3月4日至27日的23天时间里，北越军队攻克了连接越南北方的蜂腰部上最重要的战略据点西园，紧接着又马不停蹄地将进攻锋芒直指越南古都顺化，南越守军不战而溃，弃城而逃。北越军队继而将进攻势头转向沿海重镇岘港。岘港的守军达10万人，北越进攻军队仅3万5千人。这一仗原定打几个月，结果仅用了32小时。 到4月初，北越军队已控制了南方的北部和中心地区。据事后披露，这种推进速度比原定计划快了两年。南越军队唯一的一次像样的抵抗，是在距西贡东北61公里的春路展开的。4月9日，4万北越军队曾在这里被击退。但几天之后，北越军队还是打开了这座通向首都的屏障。 4月23日，北越军队距西贡仅30公里了。南越政权危在旦夕。就在这一天，美国总统福特在新奥尔良发表讲话，“宣布战争已经结束”。他说，“今天美国能够恢复越战前的尊严，但是不可能用再打一次越战的办法来恢复”。就美国来说，这场战争已经结束，攻克西贡的战斗终于开始发起。在这次最后攻势中，北越人民军投入了所有主力。 这次进攻作战的代号为“胡志明战役”。进攻发起日的代号为n日，即四月二十六日。战斗一经打响，高于南越军队3倍的北越军队兵分五路向西贡市区突入。至29日凌晨，进攻的西线部队已攻占了主要目标警察总署。当时南越的档案文件资料几乎是原封不动地放在原处。30日凌晨时，进攻的东线部队攻占了主要目标国防部、海军基地和广播电台。从这时计算，自北越军队在越南南方发动统一全国的总攻以来，历时55天，歼敌已达70万，其中南越正规军占30万。 此次最后攻势，胡志明战役大局已定，胜券在握，歼敌数达到40万，这样总计110万，南越军队在55天中已全部覆没。这时，北越军队已开始缩紧包围圈，并发出最后通牒，命令守军在24小时内投降。北越军队兵临城下，西贡市内一片混乱，由于机场的跑道遭到炮击，西贡市内的美国人只能乘直升机撤出。多年来一直作为越战象征的直升机，现在只能降落在大使馆的楼顶上和庭院里。美国政府派出了一支特遣舰队在公海接应撤退的美国人。北越军队围而不打，延迟总攻时间，保证美国人安全撤出西贡市，美国大使最后一批撤离只能带走极少数的南越人，前总统阮高奇就是其中之一。一个美国人扶持起来的政府就这样轰然间的塌陷下去，这是它留下的最后一组镜头。 自1945年越南爆发抗法战争以来，直到这最后的统一时刻为止，越南打了整整30年的仗。在越南长期的抗法抗美斗争中，中国向越南提供的军事、经济和自由外汇的援助总值超过200亿美元，其中包括足够装备海陆空200多万人的轻重武器、弹药和其他军用品，成百个生产企业和修配厂，3亿多米布匹，3万多辆汽车，几百公里铁路以及全部铁轨、机车和车厢、500多万吨粮食、200多万吨汽油、3000公里以上的油管以及几亿美元的现汇等等。中国对越南提供的援助绝大部分是无偿，一小部分是无息贷款。4月30日上午，最后一批美军撤离西贡。15年来，南越第一次没有了美国兵，北越军队可以不再担心美军飞机的轰炸了。北越军队袭击西贡机场，攻占警察总部，进入了满目狼藉的街道，占领了西贡市。 4月30日中午，一辆北越坦克突入总统府的大门，一名士兵跑入总统府，升起了越南旗帜。30年的战争胜利了，这是越南历史上最辉煌的时刻。然而三年后，风云斗转。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-对印自卫反击战（上）","slug":"共和国战争-对印自卫反击战（上）","date":"2023-05-14T12:41:31.000Z","updated":"2025-09-16T02:08:42.967Z","comments":true,"path":"2023/05/14/共和国战争-对印自卫反击战（上）/","link":"","permalink":"https://naosense.github.io/2023/05/14/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E5%AF%B9%E5%8D%B0%E8%87%AA%E5%8D%AB%E5%8F%8D%E5%87%BB%E6%88%98%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"近日观看了《共和国战争》纪录片，一共包括对印自卫反击战，对越自卫反击战，中苏珍宝岛战争，抗美援朝四个系列，共10集，台词写的审慎客观，磅礴大气，记录学习下 世界屋脊 这是被称为世界屋脊的地方，在隆起海平面4000多米的高原上，又隆起一片陡峰，这就是喜马拉雅山脉。它顶天立地的横亘着，阻隔着印度洋温暖湿润的空气，以至形成这样一种世界上绝无仅有的自然景观。它的南面是丰饶富庶的印度平原，它的北面却是苍茫荒芜的藏北高原，再向北就是世界上最大的渺无人迹的沙漠塔克拉玛干。 联系这两个不同国土地域，是蜿蜒在喜马拉雅山东西两侧的两条古代商路。在西段从印度河上游河谷经空喀山口到达中国新疆的阿克塞钦。在东段印度阿萨姆平原最北端，喜马拉雅山脉平地隆起，陡峭上升，紧贴不丹王国，东侧有一条最近的通道，其咽喉就是中国西藏的达旺。1962年，喜马拉雅山南北两个邻国中国和印度就在这两条古代商路上爆发了一场大战。 30年后，回首这场边界战争，人们竟很难相信，双方争执的这两片疆土竟是那么荒凉，那么贫瘠。荒凉的人迹罕至，贫瘠的一无鸟兽。今天，如果站在这片仍未成型的边界地带，很多人也许会用现代的眼光去凝视这场扑朔不清的战争。其实，我们只需要把眼光再远眺半个世纪，或许就能找到这场战争缘起的真正答案。 我们现在看到的是本世纪之初的欧洲街景，人类当时刚刚发明了电影，从而为历史留下了西方列强在兴盛时期的活动的画面。当人们开始用电影记录社会生活时，亚洲的印度已经被欧洲的英国征服了两个世纪。 英属印度 15世纪末，当哥伦布横渡大西洋发现一块大陆时，他把美洲当作了印度。5年以后，葡萄牙人达加马率4艘大帆船绕过非洲好望角，沿非洲东海岸渡过一片汪洋，终于到达了真正的印度。于是在16世纪，欧洲各国争先恐后，沿着这条航线登上了印度次大陆。 17世纪，英国向印度莫卧儿帝国买下了恒河口岸的一个小村庄，这就是今天的加尔各答，建立了名为东印度公司的贸易总部，得以掠夺印度的财富。18世纪，英国用武力征服了莫卧儿帝国，从此印度开始了长达两个世纪的殖民时代。也就是在18世纪中前期，英国把在印度种植的罂粟制成鸦片，沿海路输入另一个古老的帝国——中国，从而挑起那场著名的鸦片战争，揭开了中国近代历史屈辱的一面。 1919年，一个纤弱的男人从南非的开普顿回到印度，他就是甘地。1920年，甘地发动不合作运动，他号召印度人民：“英国人迫使我们到机枪阵地前与他们较量，因为他们手里有武器，而我们却没有。我们击败他们的唯一办法是把决斗引到我们有武器而他们没有的地方，这就是民心”。 这一年的3月，甘地披着终年不离身的白色虎布，脱离，向400里外的大海进发，进行宗教洗礼，成立了印度民族自己的第一个政党，即印度国大党。这是年轻时的尼赫鲁，他当时是国大党领导人之一，30年后，当他走向垂老之际，却一手挑起了中印边境战争。这是国大党成立时的情形。甘地被推选为国大党领袖，他被印度人民称为圣雄甘地。第二年，1931年，甘地深缠一块粗糙腰布，脚踏拖鞋，被英国人请到伦敦白金汉宫，与英王兼印度皇帝一起呷茶交谈。这是当时甘地到达伦敦时的情形。 甘地恳请英国给印度独立，让4个世纪之前乘木制帆船踏上印度大陆的英国人，再乘着庞大铁甲团队离开这里，给公元前的孔雀王国，公元后的莫卧儿帝国，今天的印度以独立。这似乎是一种神话，被千百万人拥戴为圣雄的甘地。这时只能用他特有的祈祷，祝福这样一天的到来，让产生过世界三大宗教之一佛教的印度，再乘着普渡众生之船，飘越苦海。从此，甘地以其独创的非暴力抵抗殖民统治而被载入近代历史史册。也正是这样，印度自甘地开始开创了世界上未有的先例，一个民族恳请他的外来统治者离开他的家园。英国断然拒绝了甘地的请求。在英国断然拒绝印度独立的两年之后，这个日不落的帝国也开始面临生存的危机。1939年9月1日，这一天，德国军队跨过德波边界，向英国的保护国波兰发动了战争。两天以后，英国和法国对德宣战，第二次世界大战正式爆发。 1941年12月7日，德国的轴心同盟国日本为称霸太平洋，把美英法的势力从亚洲驱逐出去，派出特遣舰队偷袭了美国在太平洋最重要的海军基地珍珠港，发动了太平洋战争。在此之后，日军乘胜横扫南太平洋诸岛国。接着日本进攻的矛头所指就是英国在亚洲的属国。 1942年2月，日军攻陷缅甸的首都仰光，英国守军3个旅，即刚从北非战场调来增援的一个装甲旅，丢掉一切重装备，狼狈溃逃，穿越了1400公里的热带雨林，伤亡13000余人，退守到印度境内的英帕尔地区。在欧洲和亚洲同时陷入战争的英国在挣扎之中。 历史给了古老的印度民族一个契机，死而复生的契机。8月8日子时，印度人都没有能睡觉，他们以神秘的传递方式复述着他们称为圣雄甘地的战斗（听不清）。这时候，甘地正在孟买一间大厅里平静地讲述着他的思想。他说：“我要立即获得自由，如有可能，我要求英国殖民同志在今晚就结束，在黎明到来之前就取得自由。为此，我们提出一个神圣而极为简单的方法：或者行动起来，或者走向死亡。我们将解救印度。也许我们会失去生命，但我们绝不允许奴隶制度在我们身上继续存在下去。”这时，德国人正用潜艇封锁英伦三岛，而日本陆军也随时可能突入印度。备受煎熬的英国在大不列颠历史上最晦暗的日子里，做出了一个当为权宜之计的决定，当熬过那血与火的时刻后又后悔不得的决定。英国战时，内阁首相丘吉尔代表英国政府允诺保证战败日本以后，赐予印度自治领地的地位。这样，被统治了二百年的印度民族又和他的统治者英国一起共度了第二次世界大战的日日夜夜。 1942年夏季，德国临时放弃了进攻英国本土的海狮计划，转而向东方集结重兵。6月22日凌晨，突然对苏联不宣而战。几乎是在整整三年后的同一个月份，1945年6月，苏军攻克德国首都柏林。与此同时，从法国西海岸诺曼底登陆的英美联军也突入德国本土。 德国宣告无条件投降，欧洲战争结束了。8月15日，日本天皇宣布无条件投降。在停泊于日本东京湾的美国战舰上，日本签署了无条件投降书。现在这个画面是英国伊丽莎白女皇和战时首相丘吉尔宣布欧洲解放时的情景。大英帝国终于度过了又一次世界大战的危机，在这同一时刻走出茅寮的甘地，提醒伦敦唐宁街上那个嘴上叼着雪茄的首相：“日本已经战败。英国曾允诺过给印度独立。”两年以后，英国女皇委任蒙巴顿勋爵为印度藩王，前往这个殖民地国家谈判它的独立问题。4天以后，蒙巴顿出任第20任印度总督，这也是英国最后一任印度藩王。8月15日，英国承认印度独立，英国头上这颗印度宝石终于剥落。为印度独立作出毕生贡献的非暴力运动的倡导者圣雄甘地，在印度独立后随即逝去，这是他的葬礼会议。 在这同一时刻，印度的邻国中国正在进行着一场大规模的内战。这是一场民族解放战争。三年以后，1950年1月，独立的印度宣布成立印度共和国，首都德里改名新德里。在昔日英国总督行使权力之地红宝大厅里，新任总理是继甘地之后的国大党领袖尼赫鲁。 印度成立共和国时，有一支军队进入了印度及印度支那，这就是从中国战场退下来的国民党的败军。 这是法国战地记者拍摄的真实史料。拍摄这个镜头时，人们已经知道印度东部的那个伟大的邻国正在发生着什么。 中国国耻 1949年10月1日，中华人民共和国成立了，中国人民从此站了起来。这样，公元1950年前后不到三个月的时间，亚洲大地几乎同时站起来两个巨人，一个是独立的印度，一个是新的中国。当新中国的军队打着绑腿、大喊着奔涌在这块古老的土地上时，他的领导人毛泽东同时告知全世界：“新的中国不承认一切外国机构的合法地位，尚留在中国土地上的原外交人员一律以一般外侨看待。” 至此，自1840年以来，西方列强以不平等条约与中国建立的整整一个世纪的外交关系一夜之间荡然无存。开国典礼后仅两个月，毛泽东就亲赴莫斯科参加斯大林的70寿辰活动，同时与斯大林协调两国关系。这个关系一直要追溯到清代的中国与一切瓜分过中国的国家之间的历史和现实的关系。 现在，让我们重新回顾一下中国近百年的历程。当西方列强已经进入机器工业时代时，中国还是一个锁关的封闭的帝国。其实中国近代屈辱的历史也正是从印度开始。18世纪中叶，英国商船从印度起港，其航向不是顺风回返，而是泊进中国东南沿海，向中国倾销鸦片。1840年，中英两国终于为鸦片而爆发了战争。这场战争打了16年，1856年，英法联军终于从渤海大沽口杀到皇城北京，中国的外强中干暴露于世界面前。自始，俄国、德国、日本、美国相继对着中国国门引炮轰击，中国每战败一次，就签订一个不平等条约，赔偿一批白银，割让一片土地。至19世纪末，中国终于沦落为一个半封建半殖民地的国家，这个时代的中国就像摆在世界列强面前的一盘珍肴。在短短10年间，中国被迫与一个个西方列强签订了一个个不平等条约。 进入20世纪的时候，沙皇俄国从中国得到了南满的辽东半岛，包括旅顺和大连海湾25年的租约。此外，中国还被迫允许沙俄修一条从哈尔滨到大连港的铁路支线，并可以开发沿线地区的森林和煤矿。中国已被西方列强分割成一块块国中之国，山东胶州湾的青岛及周围522平方公里的土地租给德国。99年，德国还获得在山东修筑三条铁路，并在铁路两边10英里内开采矿石的特权。法国从中国得到海南岛正对面雷州半岛99年的租约，以此作为海军军港。英国得到了从大陆到香港殖民地延伸部分的99年的租约，名为新界。同时，中国割让了台湾岛给予日本。在这些租界的领土上，中国的主权在租期内无效。 本世纪之初，中国可悲之极，外国列强开始在中国的土地上相互发动战争，争食中国的机体。1904年2月8日，日本突然袭击俄国在中国旅顺口的舰队，次年1月攻陷了这个远东最重要的军港，3月又在沈阳击溃了俄国陆军主力。经美国从中调停，一年以后，两国签订了《普斯茅斯合约》，合约的内容竟是重新瓜分中国的东北。俄国同意将辽东半岛包括旅顺和大连海湾的租界权转让给日本。九年以后，1914年日本又同德国在山东胶州湾大打了一场恶仗，攫取了德国在华的势力范围。1915年，日本迫使中国签约开放南满全境，允许日本人居住，15年后终于侵占了中国东北三省。鸦片战争以来，西方侵略者用尖船利炮和来福枪攻打中国时，清朝政府没有一次运足底气进行过抗争。历史到了1937年，中国倒是真准备殊死一战了。 自中国七七事变两年以后，英国在欧洲卷入了战争，四年以后，美国在太平洋卷入了战争。5年以后，苏联也卷入第二次世界大战。1945年2月，在德国首都最后覆灭的前三个月，美英苏三国首脑在黑海之滨的雅尔塔秘密会晤，讨论战后的世界格局，这时有着4亿人口的中国就像一个筹码，被这三大国在会议桌上颠来颠去。最后，美英以承认苏联将获取日俄战争前的在华利益为条件，换取了斯大林允诺向日本宣战。这就是著名的《雅尔塔秘密协定》。1945年8月，当苏军通过西伯利亚大铁路，从欧洲向远东集结近200万兵力时，美苏两国才把这个秘密协定向中国政府公开。协定的内容不但恢复了沙皇俄国19世纪末在中国获取的权益，甚至还要求中国政府承认外蒙古独立的现状。这就意味着在中国的版图上割让出去将近160万平方公里的土地。这时的中国已与日本整整作战了8年，死难了3200万人。也正是由于中国的抗日战争遏制了日本抽调大批兵力投入美国的太平洋战场和向苏联的进攻。 而在战争临近结束时，中国又一次被昔日的西方列强、战时的盟国又一次的出卖，中国或多或少地回到了战前以至世纪之初的状态，东北又成为昔日的俄国当时苏联的势力范围，美国海军陆战队在山东胶州湾登陆，香港，落入了英国的怀抱，澳门属于葡萄牙，法国的势力从印度支那延伸到云南境内。 我们在梳理中印边界自卫反击战的起因时，追溯中国近代史上这一段历史，无疑是要理清新中国为什么在本世纪的中后期，在中国这一段百年国耻结束了10年之后，在辽阔国土的最西端，在那人迹罕至的不毛之地大打了一仗，这里面深刻的历史原因和民族心态是什么？ 1949年10月1日，中国人民站起来了。开国典礼两个月之后，毛泽东亲赴苏联。当这位新中国领袖乘着火车万里北上的时候，他指挥的军队正千里南下，把中国人民的解放战争扩展到960万平方公里的最边沿。在这一历史时刻，一切外国在华的势力范围，包括特权、租界、金融、股券，以至趾高气扬的神态举止，顿时化为乌有。但，不是所有的问题都能用枪杆子解决，有的问题只能坐下来认真交谈。 这时的苏共是中共意识形态中的兄弟党，中国称之为“老大哥”。苏联人手上握着1945年与中国国民党签订的《中苏不平等条约》，经过三个月的谈判，除蒙古独立这一既成事实外，苏联同意把昔日沙俄及二战中的苏联侵占的中国主权全部归还新的中国。1950年2月间，毛泽东签署完中苏友好互助同盟条约后，欣然回国。这时，一个意外的事件出现，印度竟向新中国发出了挑战。事件经过是这样，1950年1月，中华人民共和国中央军事委员会命令西南军政委员会准备进军西藏，中央政府同时号召西藏当局还代表来北京谈判和平解放问题。同年7月，在西藏地方政府派出的代表团取道印度，赴京途中，朝鲜半岛突然爆发了战争。8月，新任印度驻华大使竟向中国政府提出这个谈判在印度举行，中国政府态度十分明确，西藏当局不能在中国以外以国家资格会谈，其代表只能来北京谈判，并限期9月20日前到达北京，同时宣布中国人民解放军开始向西藏进军。 1950年10月下旬，北京限定西藏地方政府代表到京的时间已经超过一个月。朝鲜半岛的战争愈打愈烈，美军反攻突破三八线，战火已经烧到中国东北边境，鸭绿江边。在朝鲜战争中，印度政府的态度是摇摆于中美之间的，他派出了一支医疗队加入联合国军，却不赞成联合国通过的污蔑中国是侵略者的决议。但在西藏问题上，印度政府却不那么友好，很有趁中国抗美援朝之机捞取实惠的意思。这时，印度政府在10天之内接连三次照会中国政府，照会的主要内容是：中国进军西藏会引起国际间的紧张局势，西藏自治是一事实，忠告中国和平解决。印度由于惯例和协定在西藏享有特权，并在西藏驻有保护邮政和电讯的军队应继续存在，除非中国命令其军队停止向西藏推进，印度政府不再劝告西藏代表团前往北京。 这是当年英国人在西藏拍摄的影片，这些镜头为我们再现了50年前的西藏，1950年的时候，中国除台湾一个孤岛外，尚没有解放的内陆土地就是西藏。由于历史的和自然条件的影响，几乎与外世隔绝的西藏，其社会形态当时仍处在落后的奴隶制社会，百万农奴在占西藏人口极少部分的奴隶主奴役下罹饥淘寒，中国人民的解放不能不包括西藏，但解放西藏又是一个比解放内陆省份复杂的多的事情。当时新中国已经卷入了朝鲜战争，以中国人民志愿军名义赴朝的中国军队已在朝鲜半岛上与美国为首的16国组成的联合国军正式交手，国际形势对中国不利，在这种情况下，中国外交部仍义正辞严的照会印度：“西藏是中国领土不可分割的一部分，西藏问题完全是中国的内政问题，无论西藏当局愿否进行和平谈判及谈判得到如何结果，中国人民解放军进入西藏，解放西藏人民，保卫祖国边疆，这是中国政府坚定不移的既定方针，任何外国不容干涉的中国内政。”这时，印度政府除用外交手段干涉中国解放西藏外，还支援藏军军火，帮助藏军调往昌都前线，阻止人民解放军进藏。派人在前线设立电台搜集情报。印度各种报纸、新闻广播，反复强调西藏是一个独立国家，中国人民解放军进入西藏是侵略行为。同时，印度当局还指使西藏亲印分子将17岁的西藏佛教领袖达赖十四世移往亚东，准备随时逃往印度。 1951年10月，中国人民解放军在西藏昌都地区击溃了阻击大军前进的藏军，西藏的大门豁然大敞。随着朝鲜战场上中国人民志愿军五战五捷，把美国及其仆从军从鸭绿江一举推回三八线以南，美国被迫在历史上第一次坐下来谈判停战。在这种国际大气候的影响下，印度政府终于在西藏问题上沉默下来。1951年3月，西藏地方政府也派代表匆匆赶赴北京，接受了中央政府和平解放西藏的条件，两个月后签署了协议。同年12月1日前，中国人民解放军和平进驻西藏各地，胜利完成了解放中国全部内陆国土的历史使命。 麦克马洪线 1953年，朝鲜战争停火，美国新任总统艾森豪威尔开始推行全球性的遏制战略。在欧洲，西方国家组成的北大西洋公约组织遏制苏联东欧集团向西发展。在亚洲，由日本、南韩、台湾、菲律宾组成的太平洋环形包围遏制着中国。这时，一个声言保持中立的不结盟的南亚邻国印度对中国就显得尤为重要。 1954年1月在日内瓦召开的国际会议上，中国代表团团长周恩来说：“在讨论面临亚洲迫切问题时，不应忽视亚洲人民自己的意愿。”他特别提到印度，“对印度这样重要的亚洲国家未能出席会议深表遗憾。”周恩来还在一次讲话中把资本主义国家分成三类，即以美国为首的好战派、以英法为首的维持现状派和以印度为首的和平中立派。 印度总理尼赫鲁对周恩来的讲话反应是强烈的，他立即指示在日内瓦他的私人代表梅农，也就是几年后中印大战时印度的国防部部长邀请周恩来访印，日内瓦会议后的6月25日，周恩来乘专机抵达新德里。一年后，即1955年4月18日，在南太平洋的岛国印度尼西亚举行了一次由29个亚非国家召开的令世界瞩目的国际会议，这就是著名的万隆会议。尽管有的亚非国家反对中国参加，但印度尼赫鲁则极力主张邀请中国。这是中国和印度国家关系史上最好的一个历史时期，同为世界人口最多的两个亚洲国家，都在极力从各自的经历中表现出要做一个泱泱大国的姿态。 在50年代中期，中国基于对当时整个国际形势的分析以及中国所处的战略地位，在对外关系中十分注意争取印度的合作，当时提出了对外关系的“一条政策和三个方针”，“一条政策”就是和平的基本政策，“三个方针”是准备力量做后盾，减少美国冒险尝试的可能；发展和平统一战线，增进和平力量；避免主动挑起战争，谨慎地贯彻和平政策。 在新中国实行的国际反美统一战线中，印度的中立以及中印的友好具有举足轻重的部分。虽然中国和印度在西藏问题上有不尽，但中国维护和印度已经建立起来的友谊之真诚。周恩来对尼赫鲁讲：“中印、中缅一部分边界尚未勘定，在此之前，我们愿意维持现状。”现在周恩来所说的这个现状，实际上已经是印度强加给中国的了。 中国和印度沿喀拉昆仑山和喜马拉雅山的走向，边境接壤达2000多公里，分为东、中、西三段，自古以来从未有过边界勘定。1950年，中华人民共和国成立尚不足一年，就卷入了其北部邻国朝鲜的战争，无暇顾及西南边陲那海拔4千米以上的几近无人烟的边境地段，而比中国早独立半年的印度，却在波及全世界的朝鲜半岛大战这段时间里，把它的边界从富庶的平原地区向险峻的中国西藏高原推进，完成了一条印度北部自己确认的边界线，其面积达到12万多平方公里。 印度把单方面划出的边界强加于中国，这是中国方面坚决反对的。1956年周恩来第二次访问新德里时，曾对尼赫鲁提出讨论边界问题，但对方断然拒绝。无论中国通过外交信电怎样劝说印度进行边界谈判，印度都加以回绝。直到有一天，由于发生了一个边界以外的事件，才使印度政府不得不回到边界地域的现实之中。 这个事件就是中国西藏地区发生的武装叛乱。1959年3月10日，原西藏地方政府的上层反动分子，经过几年的策划和准备，发动了武装暴乱。10天以后，北京发布了平叛令，3月20日开始，解放军军事打击开始向拉萨以外的地区扩展。西藏宗教领袖达赖喇嘛仓皇出逃，于1959年4月化妆抵达印度，在印度进行了一系列的宗教，印度政府按国家元首的礼仪迎接了达赖喇嘛，从而使印度国内掀起了股声援西藏独立的反华浪潮。与此同时，中印边境地区局势也开始趋向恶化，达赖喇嘛到达新德里就开始发表声明，大肆攻击中国。这些声明开始是通过印度政府的宣传机构发表，后来改由印度驻外使馆散发。达赖喇嘛在印度当局替他拟好的第一个声明中，详细说明了他越过边界进入印度的地点。他说这个地点是一个叫兼则马尼的地方，换句话就是说，那个叫兼则马尼的地方就是印度的边界。实际上这个地点距离中印传统边界线突出了62分。 印度政府之所以如此强调这个地点，是因为它勘定这个地点时，依据了一条所谓麦克马洪线，印度政府就是要把这条麦克马洪线强加给中国。 现在让我们来看看什么是麦克马洪线，它是1914年二三月间英国和西藏在印度德里秘密的以换文形式划定的一条边界线。因为这条线出自英国代表团团长亨利麦克马洪爵士之手，所以定名为麦克马洪线。其实当时的英国政府也非常清楚，西藏与中国是宗主关系，西藏不享有单独缔结条约的权利。所谓的麦克马洪线自从在地图上划定时就是一纸空文，因此，它从未正式公开过。直到1952年，印度政府才把它拿出来，以此勘定了北部边界。中国历届政府从未承认过麦克马洪线。中印边界争执不但糅杂着殖民主义者对旧中国政府的诱迫和欺诈，同时也揉进了新中国政权对一切外辱的仇鄙和自尊。这一切终于使之演变成一场边界战争。 1959年，西藏平叛开始以后，为切断叛乱分子的外逃之路，人民解放军重兵封锁了麦克马洪线以北的险关隘口，这本是中国的内政，而对麦克马洪线异常敏感的印度马上也调集了精锐的作战部队，推进到这条线最前沿。有些地方甚至越过了麦克马洪线，其中就包括朗久地区的马及墩村。 这是印军越过了麦克马洪线设在中国一方的哨所，这就是那个叫马及墩的村庄。8月25日黎明时分，印军的一支小分队进入马及墩村，与中国边防部队发生了第一次武装冲突。战后核查印军1死1伤。事件发生的第二天，印度政府立即照会中国，强硬的指责中国蓄意侵略，企图用武力来实现其领土要求。中国政府也郑重声明，中国边防部队是在忍无可忍的情况下，对印度的军事挑衅进行自卫还击。朗久事件的突发，世界舆论一片哗然。在印度国内掀起的反华浪潮中，美国会说什么，英国会说什么，都是人们意料之中的事情。但这时有一个声音却使世界为之惊异，这就是苏联的声音。此时，苏联部长会议主席赫鲁晓夫正在美国访问。莫斯科播发的塔斯社声明说：“苏联领导人深信，中国和印度不会允许那些不希望国际形势缓和而希望它尖锐化的势力在这个事件中坐收渔利。”中国当即请苏联驻华使馆转告苏联政府，“塔斯社的声明违背了中苏两国一向在国际事务中进行协调的惯例，把中苏内部分歧暴露于世。” 赫鲁晓夫访美归国时取道北京参加了中国国庆10周年的庆礼。他在谈到中印边界问题时，同中国领导人首次发生了争吵。由于这次争吵在两国关系中留下了严重的伤痕，赫鲁晓夫后来提议双方都烧毁这次会谈的记录，但是这段不愉快的历史已经无法抹掉。朗久事件发生后，周恩来曾和尼赫鲁写了一封长信，他在信中已经明确的谈到了中国的态度。信中说：“印度政府竟要求中国政府正式承认英国对中国西藏执行侵略政策时所造成的局面作为解决中印边界的根据，中国怎么能够同意被迫接受这样一个丧权辱国、出卖领土，而且这块领土又是如此之大的非法界限呢。”中印边界东段的朗久事件发生后，中印边界西段也开始紧张起来。这是中印边界的西段，印度主张的分界线的示意图，它超出中印传统分界线的距离，如此之大，面积竟达3万多平方公里。10月20日，由两名印度边防警察和一名角夫组成的一支三人小分队越境深入到中国境内。当他们出现在新疆通往西藏的新藏公路上时，才被我边防军发现并予以扣留。第二天，派遣这支小分队的印军巡逻队为寻找失踪人员，集结70余人向我边境移动。在一个叫昆卡山口的地方，与中国边防军两个哨所的13人发生了遭遇战，中国军队伤亡1人，印军9名阵亡，7名被俘。 昆卡山口事件发生后，中国方面释放了被俘的印军士兵，同时归还了缴获的装备，但无疑已经拉开了中印边界战争的序幕。 11月7日，周恩来再度致函尼赫鲁，他建议双方的武装部队从实际控制线各自后撤20公里，脱离接触并停止巡逻活动。此后，中国单方面自中印边界线后撤了20公里，在20公里内不打靶、不演习、不爆破，并在我方一侧30公里内不巡逻、不平叛、不打猎。这实在是体现了中国政府一再克制忍让、一再求同存异的现实主义姿态。 4个月以后，1960年4月19日，周恩来总理率外交部长陈毅及大批谈判工作人员分成三架专机飞抵新德里。在高级会谈中，中国方面曾明白地表示，“如果印度接受中国西段的控制线，中国就准备接受麦克马洪线。”中国代表团是直接从缅甸仰光飞来的，因为这条线的东西两端还延伸到缅甸和尼泊尔边境。中国希望这次访问真正解决问题，但印度政府拒绝一切有关边界问题的全面谈判。中国政府所能采取的唯一的现实主义方针已经忍让到最大的极限。中国不能简单的默认麦克马洪线，中国坚持必须通过全面谈判缔结新约，新条约会肯定旧的边界走向，但在中国看来，新条约就是两个平等国家协商的结果，那就可以消除旧的不平等条约的污点。周恩来曾向尼赫鲁保证说，“中国不会通过谈判来变更边境”但是印度仍然拒绝谈判。 在中国代表团离开新德里前的一次记者招待会上，面对150名外国记者纷至沓来的刁难、挑衅和哄闹的话题，陈毅元帅激愤地站起来说：“我要提醒你们注意，中国是一个受损害的国家。”这种心情只有中国人自己能够体味到。在旧中国政府腐败无能的情况下，西方帝国主义列强随便在版图上画一条线，就可以说是边界线。新中国站起来以后还让她默认这一现实，那是绝对不可能的。尽管麦克马洪线是英国同中国西藏地方当局秘密换文非法划定，但中国政府仍愿意以现实的态度对待这条线，中国在一再忍让的同时，也做了另一手准备，那就是准备打仗。毫无疑问，中印边界的争端致使边界的双方都面临着挑战。1960年4月以后，印度和中国都开始向两国接壤的几近无人的边境地区抢建公路。 这时令中国吃惊的是，随着中苏两党意识形态领域的论战激化，苏联竟在国家关系上发展到了对中国背信弃义的地步。1959年朗久事件发生后的半个月，苏联马上与印度签订了15亿卢布的援助贷款。1960年4月中印总理会谈破裂后，苏联开始向印度大量提供军火。 印军在喜马拉雅山高原地区使用的能够适应16000英尺以上高度飞行的直升机和运输机，就是苏联最新生产的，驾驶员全部由苏军培训。至此，苏联已由偏袒印度的立场转变为支持印度反华，并构成对中国的敌对行为。同时，印度开始向苏联洽购当时最新型的米格21喷气战斗机。这种飞机苏联曾拒绝向中国提供，而终于在1962年中印开战前的几个月，连设计图纸一起交给了印度，苏联并保证印度今后在制造这种飞机时向它提供全套设备。 当时有一家巴基斯坦报纸说：“印度跟中国制造麻烦，与其说是，为了争夺领土，不如说是为了找到更多的美元。每当美国国会开始考虑援外计划的时候，印度就开始莫名其妙地仇视中国，以借抵抗美国敌人的名义捞取更多的援助。现在又到了美国国会表决具体拨款的时间了，看看印度又要干什么。”果不其然，1962年入春以后，印度某些势力就像着了魔似的，突然歇斯底里的开始叫嚣战争，在新德里，几乎每天都有的集会和游行。 美国呢，自1947年印度独立后，十年间援助了这个不结盟的中立国家21亿美元。但自从1959年印度拉下脸与中国为敌，到1962年3月，两年多的时间里，美国的援助就达41亿美元，相当于前十年总额的2倍。1962年3月间，印度这么一吵一闹，美国马上以出售剩余农产品支援印度的名义，一次就拨给印度25亿卢比的贷款。流向印度的美元帮助人们解开了一个谜，原来尼赫鲁政府既要苏联人的钱，又要美国人的钱。在冷战时期，能同时从对立的美苏兜里同时掏到钱的，当时全世界也只有印度一家。印度财政部长毫不掩饰地表示，由于要对付中国，印度需要花钱。 1962年，另一个潜在的危机也逼向中国，窥视着中印交恶，中美在台湾海峡的军事对峙处于紧张状态。1949年，败北台湾的蒋介石开始蠢蠢欲动，不能不让海峡对岸的北京防患未然。但这里需要指出的是，中印边界争端激化后，美国、英国曾致电台湾，希望台湾发表声明谴责共产党中国的侵略行径，令这些仇视新中国的国家大失所望的是，台湾从政府到舆论界均保持着沉默。 这里还需要指出的是，代表中国最早向印度提出边界问题的还是国民党政府。1947年2月，刚独立的印度在中国南京建立驻华使馆时，国民党政府就提醒印度政府注意，中国从来不承认麦克马洪线。但是年事已高的蒋介石反攻复国的决心是没有变的。1962年的时候，台湾更是甚嚣尘上，口口声声要反攻大陆。这一时期，中国所处的国际环境和周边环境及国内现实状况都是极为险恶的。 从1960年开始，连续三年中国国内发生了严重的饥荒，中苏关系已从意识形态的对立转变为国家关系的全面紧张。在中印边境，尼赫鲁希冀以对华战争充当亚洲的领袖国家。台湾的蒋介石阴谋篡犯大陆，而美国则插手越南南方，在中国的南大门开始打一场特种战争，举目四望，按那个时代的语言，“中国处于国际势力的合围之中”这时中共党内也出现一种意见，建议对外有必要采取和缓方针，要避免把美帝的锋芒全部的吸引到中国身上，特别是对印度，不要把它当做我们民族的敌人。中国共产党中央当时把这一种带有策略性的意见当作右倾机会主义予以否定。 1962年7月，中国外交部长陈毅借一次国际会议与印度国防部长梅农所做的最后一次外交努力失败后，周恩来向毛泽东请示中印边界问题的处理方针。据说毛泽东曾说过，“中国有960万平方公里的土地，这是小学课本上都有的，不能轮到我毛泽东当家，领土就变成了950万，930万，我无法向6亿人民交代。” 这时印度当局的态度也异常坚决。尼赫鲁在议会发表演讲说：“我们的地图表明，麦克马洪线是我们的边界。不管地图不地图，这就是我们的边界。这个事实没有变，我们坚持这条边界，我们绝不让任何人越过这条边界。”中印两国开始走向迎面对撞。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"共和国战争-对印自卫反击战（下）","slug":"共和国战争-对印自卫反击战（下）","date":"2023-05-14T12:41:31.000Z","updated":"2025-09-16T02:08:42.967Z","comments":true,"path":"2023/05/14/共和国战争-对印自卫反击战（下）/","link":"","permalink":"https://naosense.github.io/2023/05/14/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89-%E5%AF%B9%E5%8D%B0%E8%87%AA%E5%8D%AB%E5%8F%8D%E5%87%BB%E6%88%98%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"扯冬哨卡 自1960年以后，印度政府在中印边境上出台了一个所谓前进政策的战略计划。在西段的中国境内，印军一直向前推进，步步进逼，设立了43个据点，有的据点距离中国哨所只有几米的地方，有的甚至绕到了中国哨所的后面，出现了犬牙交错的武装对峙局面。印军把中国军队再三的克制和忍让，争取外交解决的诚意看作是软弱可欺，他们在边界地区更加有恃无恐。 从1962年开始，印度又把这个前进政策扩大到中印边境的东段。在头6个月里，印军在麦克马洪线上建立了24个哨所。印军仍以为中国会像在西段一样避免对抗，但这时，中印边界战争的序幕已经在西藏扯冬的这片原始森林中悄然拉开。鉴于中印边界日渐紧张的局势，1962年9月，中央军委电令边防部队恢复自1959年中国单方面停止的巡逻，这样在东段的中国军队开始执行例行的巡逻任务。这时中国军队才发现，在一条叫做克节朗的小河南岸，印军建立的一个哨所明显的越过了麦克马洪线。 据战后披露的资料来看，印军是在6月4日建立的，这个哨所的位置，连印军自己的陆军地图上都标明是在中国境内，即麦克马洪线以北，中国地图标明这一地区叫做扯冬。7月间，印军还在该哨所附近发现一块中文写的木牌，专程派人送到后方翻译，才弄明白那上面的汉字是：“这是我国山河”。负责建立该哨所的印军巡逻队长是一名上尉，他当时已顾虑到哨所所处位置的敏感性，所以他用陆军地图上麦克马洪线以南3英里的一个叫多拉的山口名字来称呼这个哨所。9月8日上午，一支中国军队突然从印军称为多拉哨所对面一个叫塔格拉的山脊上冲下来。中国军队大约有60人左右，而印度哨所的指挥官却向上级报告说有600人之多。他在战后承认，他当时如果把比较实在的数字报上去，上级就会叫他用手头上的小部队应付局面。如果报告有几百中国军队正威胁着他，上级就会派援兵来增援。多拉哨所当时没有受到攻击，但中国军队在靠近和能够控制这个哨所的周围地区驻扎下来，就像在西段那样，中印军队犬牙交错，武装对峙着。 多拉哨所被包围的消息9月9日传到新德里。当天上午，印度国防部长梅农立即召开了会议。据后来披露的资料说明，当时在会上有的军官就提出，多拉哨所的位置确在中国境内。梅农说“不要去管地图”，就把哨所前方的塔格拉山脊作为边界。会议决定立即以武力把中国军队赶出去。这次军事行动的密码代号是“里窝那”。印度国防部立即草拟了给印军33军的电报，命令第9旁遮普联队及最靠近多拉哨所的那个营立即进驻多拉哨所，第7旅其余部队务必在48小时内赶到。据战后披露的资料，当时中国军队尚处在避免事态恶化的被动阶段，并严守“不打第一枪”的政策，实际上内部传达是“任何情况下都不能开枪”，但印军的里窝那行动却被推迟了48小时执行，原因是印军上层内部出现了重大分歧。印军33军军长乌姆拉欧辛格12月向陆军总部最后建议，多拉哨所应当往南后撤3英里，撤到地图上所标的麦克马洪线上，防止中国军队进一步推进。印度东部军区司令当天就赶到了，33军军部重申了国防部的命令“必须用武力把中国军队赶到塔克拉山脊那边去”。麦克马红线前沿的印军由于得到了用武力向前推进的命令，所以气焰十分嚣张。 9月中旬，西藏军区已获悉印军即将开始“里窝那行动”的情报，旋即上报中央，中央军委立即决定：西藏、新疆2军区准备自卫还击。周恩来亲自调拨500辆刚出场的解放牌卡车，沿川藏公路紧急输送部队。 这时，印军第7旅也已经按印度国防部“里窝那行动”计划的指令，到达指定位置。中印大战一触即发。10月9日中午，50名印军渡过了克捷朗河，企图抢占中国军队右侧的一个叫做雍错的山口。印军的里窝那行动在克捷朗河谷正式开始了。这天的晚上，这一小队印军没有爬到山顶，在一个印军称为桑崇的地方建立了一个阵地。第二天凌晨，当印度第7旅士兵又准备开始过河时，中国军队突然开炮，紧接着，中国军队的一个连开始向盘踞在桑崇的印军发起进攻。印军曾击退过一次冲锋，但在数量上约占2:1绝对优势的中国军队在炮火的掩护下，很快攻取了印军阵地。颓势之下，印军指挥官命令后撤。这时中国军队倒停止了炮火，让印军全部撤回到克捷朗河对岸。这次战斗，印军阵亡7名，失踪7名，重伤11名。中国军队以正式军礼埋葬了印度的死者。 克捷朗河谷的战斗打响后，印军战地最高指挥官、新上任的考尔中将立即飞往新德里面见尼赫鲁，尼赫鲁给他的命令是继续进攻，而前线陆军却一再请求后撤，在进也不是，退也不是的情形之下。10天以后，中国军队于10月20日凌晨5点突然发动了总攻，印军的阵地一个接着一个被攻克。 首战克捷朗河谷地区的中国反击作战部队统一归中国人民解放军藏自419部队指挥，下辖步兵第154、155、157 团和步兵第11师第32团及31团1个营，并配属炮兵第308团和工兵136团，总兵力约1万多人。当面之敌为印军参加过二战的王牌部队第4师的精锐第7旅，下属3个营计3000余人。具体到名为扯冬哨卡的主战场上，中国参战部队集中了4个步兵团和1个炮兵团的绝对优势兵力，力求一举歼灭当面之敌。 中印边界自卫反击战打响的第二天，中国政府发表声明，中国军队在自卫反击中不再受麦克马洪线的约束。在中国政府声明的同时，中国军队以三个团的兵力从扯冬地区越过了麦克马洪线，转向东南，逼近自1950年印军侵占的中国西藏边界重镇达旺。人民解放军参战部队越过麦克马红线后，原计划是进一步歼灭敢于由达旺向北增援的印军，但由于印军一再南逃，根据总参谋部相机占领达旺的指示，参战部队向达旺追击前进。 自10月20日开始，中印边境东段和西段同时打响，中国军队在中印边界西段，即我新疆阿克塞钦地区也开始了反击作战。战前判明，当面印军为1个旅部、6个步兵营、1个机枪营和若干配属分队，兵力为5600人，其中侵入我国境内43个据点，部署兵力1300人。 战斗打响的第一天，在加勒万和班公湖两个地区内的印军几个哨所曾向印度西部军区紧急报告“中国军队开始炮击”，以后就再无下文了。在东段印军第7旅被歼灭后两三天的时间里，印军西部军区命令所有没有受到攻击的哨所全部后撤。据此，印度政府的前进政策随着里窝那作战计划的全部毁灭而宣告破产。 10 月20日傍晚前，在中印边界东段大规模战斗已经结束，但各部队报告俘虏的印军却不多，原因是中国参战部队战前对印军的顽抗和增援做了充分的战斗准备，但仗一打起来，印军一触即溃，这一点中国军队缺乏思想准备。因此，各部队忙于追击，未及时搜缴逃入深山老林的印军败兵。西藏军区前指，指经过反复核对歼敌数字，发现毙敌和伏敌数与印军实力相差很大，因此立即下令投入战役预备队继续向达旺追击前进。其他各部队立即封锁克捷朗河流域各山口、沟口、路口和桥梁，转入清缴战斗。这是印军第7旅旅长达威尔准将，他潜入深山老林两天后，饥饿难耐，于22日下山寻找食物时被中国军队俘虏。在整个中印边界反击战期间，中国部队共俘虏了3900名印军官兵，其中准将1人即第7旅旅长达威尔，校级军官26人。 10月20日中印边界反击战开始后，中国人民解放军总政治部即向作战部队发布对印军俘虏的管理规定，特别强调“一律不许杀害、不许虐待、不许侮辱、不许捆绑、不许没收私人财物。受伤者给予治疗，并尊重其宗教信仰和民族习惯，对战场死尸尽可能查明其姓名和所属番号，妥善掩埋并设立标记。病伤死亡的战俘要填写病历，并由军医签署死亡证明书”。 这一切人道主义待遇对中国参战部队在自然条件和生存条件都非常困难的战地前线很好的贯彻执行，使一年后被全部释放的印军官兵无不为之动容，他们在被释放时满怀依依惜别之情的情景，是古往今来的战争中所不曾有过的情景。克捷朗河战役是中印边界自卫反击战中首战告捷的战役。10月23日印军第7旅被歼后，中国参战部队继续向南追击前进，聚守达旺的印军4000余人未放一枪即向南逃窜。其实，沿麦克马洪的印军其他几十个哨所，在中国军队的压力下纷纷后撤。25 日，中国军队进驻达旺，中印边界东段暂时沉寂下来。东线战事平息后，中国部队在西线及我国新疆阿克塞钦地区的自卫反击作战也近尾声。 西线作战开始前，新疆军区参战部队集中了步兵第10团3营、第11团3营和维族骑兵第3团总计一个多团的兵力。10月20号在加勒万河谷拔除印军据点以后，又于26日南下转战500公里，到达西藏阿里地区狮权河畔。这一地区自1954年后即被印军侵占，驻有印军300人。28日战斗打响，印军一发现中国军队逼近即撤离阵地西逃，只有担任后卫掩护的40多人被歼灭。至此，9天时间里，中国西线参战部队拔除入侵的印军据点37个，消灭300余人，其中俘虏160人。 耐人寻味的是，在中印边界西段，中印两国军队炮火连天地大打一仗，起因竟是印度把一条几乎无人知晓的“约翰逊线”说成是他们的边界线。所谓“约翰逊线”，是19世纪中叶，一个叫约翰逊的英国测量局官员，在中国新疆和田地区走了一圈，就把中国阿克塞钦地区划入了印度的版图。即便是在上个世纪中国清代将领左宗棠率大军入疆以后，英国就从未敢再跨进阿克赛钦地区一步。1962年，印度刚从英国二百年的殖民统治中独立出来十年，却要把英国上个世纪的扩张强加给中国，这当然是新中国绝对不能答应的。中印边界战争愈演愈烈的根源，恐怕正是于此。 风云印度洋 中印边界全线中国军队进行的为时5天的反击作战，致使印度政府宣布全国进入了紧急状态。同时尼赫鲁亲自接管了印度国防部，在新德里，几乎所有的华侨商店都被暴徒捣毁。 印度政府还发布一项法令，把华裔印度公民视为敌国侨民抓进集中营，印度内政部甚至按名字逮捕在法律上有合法地位的印度共产党。这又引起共产党国家的纷纷抗议，尼赫鲁被迫分批悄悄释放了印度共产党中的亲莫斯科派。这时苏联一改偏袒印度的态度，转而支持中国进行反击。 原来在中印交战的这一时期，苏联正陷入一场惊骇世界的危机之中。这就是发生在拉丁美洲加勒比海的“古巴导弹危机”。当时美国U2侦察机从1万米的高空发现，苏联正把足以摧毁美国几十个城市的战略导弹部署在古巴岛上。美国总统肯尼迪立即下令全国进入一级战备状态，并严密封锁古巴海域。一场美国对苏联的核大战一触即发。这是当时的资料镜头。 最后结局是苏联撤出了导弹，美国保证不进犯古巴，两国间表面握手言和。但就此赢了一张牌的美国，在中印边界战争突发之际，竟不顾苏联的脸面，诱迫印度公开撕掉了不结盟国家的外衣。事情的经过是这样的，11月3日，美国驻印度大使加尔布雷斯面见尼赫鲁时，递上一封肯尼迪的亲笔信。信中说：“美国政府将承认麦克马洪线是一条为现代惯例所承认的国际边界线，”同时，大使告诉这位印度总理，“美国将向印度提供10亿美元的援助。”当然，这不是军事援助。第二天，即11月4日，当第一批美国重型运输机降落在加尔各达机场时，当着众多记者的面，美国陆军准将福尔曼亲自将舱门打开，里面竟全是美制的重型武器。几小时后，全世界都知道了美国正在对战争中的印度给予军事援助。英国泰晤士报在当天的新闻报道中写道：“印度完全改变了独立以来所遵循的政策，在今天的内阁会议上已正式作出了接受美国军事援助的决定。”印度认为，“只有配备美国在数量上和质量上所能提供的装备，陆军才有可能打败中国军队。” 当印度当局把它所需要的军事援助物品的清单交给美国驻印使馆时，使美国人感到惊讶的不仅是印度要求的数量如此庞大，而且从订货单上看，印度是什么都要，美国五角大楼使用了最新式的计算机，才能够在5天后把第一批军火装上运输机，从西德威斯巴登陆军仓库起运飞往印度。这时英国的军火也横跨欧洲赶运到了印度。英国政府把头几批运送的武器算作捐赠，美国马上也表示对美国军火的偿付条件以后再说。 印度陆军把刚接手的西方军火立即空运到中印边界前线，甚至直接空投到最前沿的部队。印度甚至还向以色列求援。印度过去由于担心失掉阿拉伯国家在克什米尔问题上对它的支持，一直拒绝同以色列建立外交关系。这时印度外交机构询问以色列，他们同意提供的武器“是否可以由不挂以色列国旗的船只运载”，以色列的答复是“不让挂旗就不给武器”，结果还是用一条以色列船悬挂以色列旗，满载重迫击炮抵达孟买。 第二次世界大战后，欧洲剩余了大量的战争武器。法国提供军火坚持按国际惯用的商业规定结算。正在接受馈赠兴头上的印度当然大为不满，但法国坚持说：“印度作为不结盟国家，购买军火就应该按商业贸易进行。它如果是西方阵营中的一个成员，法国愿意无偿提供。”尴尬的印度最后只买了一些法国迫击炮，而对已经装上船的法国老式飞机则拒绝出钱支付。这时，随着古巴导弹危机的缓和，莫斯科迅速的又恢复了偏袒印度的态度，继续担当着对印度的最大军火商的角色。战后历史学家分析，如果莫斯科规劝印度放弃前进政策，是可以起作用的。然而，苏联鼓励印度坚持对边境问题的既有立场，而这又恰恰促使它走上了灾难的道路。 在这一时期，北京向亚非拉国家，特别是那些新独立的国家，分别致函，耐心解释着中印边界问题的历史渊源和现实发展。在中国全面的外交攻势下，据新德里计算，至11月7日前，世界上共有39个国家支持印度，其中非洲国家4至5个，拉美国家4至5个，亚洲国家仅有3个，1个日本、1个菲律宾，还有1个伊朗。这种态势的产生，一方面有中国外交公示的因素，但更重要的是西方帝国主义那些老牌殖民主义者在这一时期正恰当地扮演着反面教员的角色。这就是当时的非洲刚果共和国。这里记录着一个真实事件，即“卢猛巴事件”。 卢猛巴是刚果共和国的首任总理，非洲第三大国。刚果共和国于1960年6月30日摆脱了比利时52年的殖民统治，宣告独立。为了防止独立后的刚果发生内战，联合国维持和平部队随即进驻了刚果。刚独立没几天，刚果军队叛变，就开始了内乱。卢猛巴请求联合国援助却遭拒绝，最后卢猛巴在孤立无援的情况下惨遭杀害。这件事使新独立的国家和人民重新看清了老牌殖民主义者的真实面目，它们绝不甘心失去往日的殖民地。由此可见，大国在对发展中国家兵戟相见时提供的援助绝不是可以安心承受的。 而在这个时候，摆脱英国殖民统治不过10年多的印度，公开背弃自己不结盟的诺言，不能不使大多数亚非拉国家为此担忧，印度政府此时竟策划要对中国开辟一个所谓的第二战场，这就是中国的台湾。印度一家报纸公开说：“我们必须竭尽全力促使台湾实施对中国华南沿海的入侵。”中国国民党自然也准备联合印度进行敌视北京的一切活动。但当美国总统肯尼迪公开承认麦克马洪线时，蒋介石立即指令他的政府向美国提出强烈抗议。正式声明说：“所谓的麦克马洪线是英国统治印度期间单方面提出的，中华民国从未接受过这条分界线，并且强烈反对美国的这项主张。” 印度新闻界掀起了一片对美国和苏联表示感激的舆论，它们很难意识到，它们正在被大国当作反华的火箭筒。这个镜头记录的是日本公众反对签订《日美安全条约》抗议示威的愤怒人群，围攻美国总统艾森豪威尔的特使，日本政府出动大量防暴警察，竟不能护送美国特使冲出重围，最后只好乘直升飞机撤出。 这一事件对尼赫鲁不能说无所感触，所以当中印边界冲突爆发后，正赶上每年一度的联合国大会讨论中国代表权的问题，印度政府自1950年起就表态支持北京进入联合国，这一时期也没有改变态度，仍投了赞成票。 同是在1962年，在中印边界战争爆发前，在南朝鲜还爆发了由公众游行示威而引发的政变，推翻了亲美的李成晚政权。这是这一事件的真实镜头。 对于亚洲相继发生的这两件事，尼赫鲁从中多多少少悟到了自己在国际舞台上的实际处境。虽然他在议会演讲中反复强调美国的军火供应是无条件的，也是不附加任何要求的，所以不影响印度的不结盟地位。但是所有的内阁成员以至尼赫鲁本人都清楚，西方的军火援助确实影响了印度外交政策的独立性。英国和美国果然利用他们的军事援助，动辄以断绝供应相威胁，迫使印度与当时亲英美的巴基斯坦就停止了多年的克什米尔领土争端问题重新谈判。在1962年，美国军队开始大规模开进南越，美国的目的是要代替法国的殖民地位，遏制共产党在印度支那半岛防止所谓多米诺骨牌的连续倒塌，重建印度支那势力范围，而这时用美国军援支撑战争的印度政府，随时可能被美国拉上亚洲的战车。这一点，尼赫鲁是再清醒不过了。 即便如此，矛盾重重的尼赫鲁仍为历史上英属印度对中国西藏的染指所激动。他向印度公民夸张地扬起双臂，说：“印度现在强大的足以击退任何进攻者。”他不顾中国政府关于重新和平谈判的再三奉劝，叫嚣，“让我们高呼圣雄甘地的名字，把中国人统统赶走。”中国军队也在加紧备战。在22天的时间里，一条从喜马拉雅山上修下来的战备公路已直通达旺前线，战备物资源源运到。中国驻印度大使馆向国内报告说，在首都新德里市中心的公园里都挖了狭窄的防空壕，政府办公大楼的门口也堆起了沙袋。毛泽东在得悉尼赫鲁仍在叫嚣战争的消息后，说了一段精辟的话。他说：“战争与和平是一对矛盾，又是统一的。这一仗不打则已，打就打出威风，保证和平30年。”解放军西藏军区立即下达了命令，集中的藏自419部队第11师、第55师及炮兵工兵各一部，参战部队总计8个步兵团 、3 个炮兵团、1个工兵团，总兵力达2万多人。中国军队决心打一场保证和平30年的胜仗。 贝利小道 印度陆军在中印边界东段的主要战区及达旺战区重新调整了部署。印军以4个旅的兵力，沿一条公路由北向南递次展开防御。这是喜马拉雅山东段唯一的一条由西藏通往印度的古代山路。印军分析，中国军队如果进攻，穿插作战几乎是不可能的，只有循着公路轴线一路进攻，这样印军将在层层拦截中给对手以重大杀伤。但是，中印边界最后一场恶战并没有首先在达旺战区展开。11月13号，曾指挥里窝那作战计划的那个考尔中将直接飞到中印边界最东端，紧邻缅甸的瓦弄战区，这是瓦弄在地图上的位置。 第二天，印军即发动向中国军队的进攻，因为这一天，11月14日是尼赫鲁的76岁寿辰，任何胜利都将是陆军向总理献上的寿礼。清晨，印军第11旅两个连在猛烈炮火的掩护下，向中国军队控制的06高地冲击。战斗持续了6个小时，最后在离山顶仅有50米的地方，印军已成强弩之末。然而，在瓦弄前线，正有一支中国的精锐部队在等着他。这就是第54军130师。该部10月21日出川入藏，27日在机械化开进的途中，接到总参作战部电报，命立即折向瓦弄，11月7日遂进入战区。14 日当晚，中国军队发起了反冲锋。至16日拂晓，中国军队的主力在强大的炮火延伸射击下，一举突破印军主要防御阵地。眼看这场献礼计划完全破灭，考尔将军下令撤退，但中国军队猛追猛打，攻势凌厉，印军第11旅终于被穿插切割成零星小股，最后终于和第7旅的下场一样，两天之内全军覆没。 中国军队有一个几十年来形成的训条，叫做“人不犯我，我不犯人。人若犯我，我必犯人”。战幕一经敌手拉开，那么什么时候、什么地方关闭，这场战幕就由不得敌手了。16日瓦弄之敌全歼后，中国军队奉命自18日开始，在中印边界全线同时展开反击。这样，中印边界战争最关键的一仗，达旺战区瑟拉邦迪拉地段的战斗就在此拉开了战幕。这是达旺战区及色拉邦迪拉地段在中印边界的位置。印军判断，中国军队的进攻只能沿公路轴线一路推进，绝不可能穿插。但中国军队经藏民的指点，找到了一条穿插的小路，这就是贝利小道。 1913年，英军贝利上尉徒步进入西藏进行长途勘察，为麦克马洪爵士画出的麦克马洪线提供地理资料。他回城时从雅鲁藏布江出发，沿着一条由北向南的直线，翻越了高达16000英尺的山口，穿过高约14000英尺的波心山口，下到一个叫班登的村庄。这个村庄地处一条横岭之上，俯视着次拉和邦迪拉之间的主要河谷。这段电影资料拍摄的是一支1500人的中国穿插部队，经过6天午夜连续强行军奇迹般地穿插了贝利小道。 神兵天降，中国军队切断了喜马拉雅山南路唯一的一条进退之路。11 月17日突然出现在班登，印军4个旅首尾不顾慌乱起来。公路两侧的雪山和森林现在变成了平地。印军的天险。这时，在达旺地区集中的步兵第55师及配属的两个炮兵团开始循着公路向南开始正面进攻，印军以62旅守卫的主要防御支撑点，色拉阵地一天之内即崩溃。该旅在撤退中突然遇到迂回上来的中国部队的伏击，很快溃不成军，大部没入原始森林，少部退至德让宗，全军溃散。中国军队攻占瑟拉后毫不喘息，立即逼向德让宗，据守德让宗的印军第65旅不待战斗就撤出了预设阵地，掉头向已被切断退路的邦迪拉撤退。在遭到中国穿插部队的顽强阻击后，结果也像62旅一样，不成建制的各部在公路上挤成一团，中国军队一到即全军溃散。 至18日上午，驻守邦迪拉的印军第48旅是印军所剩的唯一有组织的部队，当时它接到的命令是派出一支配有轻型坦克的机动部队增援德让宗，当时印军指挥机关还不知道中国军队已攻克德让宗，正在冲向邦迪拉的路上。这样，印度的增援部队和中国的攻击部队在一条狭窄的公路上相遇了，结果是印军一触即溃，在回撤的路上又丢了邦迪拉，跑了两天，在一个叫茶库的镇子站住脚，准备再次组织防御。这时已是19日的夜晚了。午夜过后，马不停蹄的中国军队连续作战，从三个方向进攻茶库。3个小时后至20日凌晨，印军第48旅全部瓦解，17日开始，20日结束。4 天之内，中国军队三战三捷，印军4个旅全军覆没。 这时，在印度东北特区之内，也就是中印传统边界线以北，麦克马红线以南，已经不存在任何有组织的印度军事力量，中国军队在东线大捷的时候，西线新疆战区也开始全面反击。据说当时在北京，周恩来曾向毛泽东汇报说：“据新疆军区报告，在中印边界西线，印度国防部将一支所谓杰特联队从克什米尔调到了喀拉昆仑山口。”毛泽东随便问了一句“杰特联队是干什么的？”周回答：“情报上说，是印度一支老牌部队，大约有100多年的历史，是英属印度时期组建的常胜军，参加过两次对中国的鸦片战争，镇压过太平天国起义。1860年曾跟随英法联军打进北京，火烧过圆明园。1904年参与侵略我国的拉萨。”据说当时毛泽东从椅子上站起来，说了一句“百年国耻”。 第二天，新疆前线即接到总参电报，“杰特联队务必全歼”。历史终于走到了这一天。百年雪耻抗武之志，积淀了整整一个世纪的刻骨铭心的悠痛激奋着中华民族，绝不屈悲而生。然而，这场边界战争的对手却不真正是曾用铁蹄践踏过中华大地的老牌殖民主义者，而是经历过同样屈辱的另一个古老的民族。这也许就是这场战争的悲剧所在。 中印边界战争进行的那几天，中国驻印度的使领馆都被暴徒袭击，但许多外交人员承认，他们当时始终被一种无端的思绪所困扰。他们亲眼看到，整个印度的人心都紧紧地系在东西两线的战场上，印度的脉搏几乎是随着前线战士的心在一起跳动，他们太渴望赢得这场战争，或许是400年漫长的殖民统治，使这个古老民族在深深的自卑心理中，太渴望通过某种方式重建民族的自信，但是他们却可悲的选择了对中国的战争。 中国军队在中印边界全线全面反击开始后，几天时间，其东线部队已下到喜马拉雅山南麓，展现在他们眼前的是无遮无盖、无险无守的印度阿萨姆平原，其前锋直指印度边疆邦府迪斯普尔。西线部队已突出喀拉昆仑山口，其前锋逼近印度和上游的重镇楚书乐，距离印度首都300公里。 印度北大门对中国军队豁然打开的这一天，在印度首都新德里，印度议会正在举行例会，所有的议员都满怀乐观情绪，期待着印军在前线大捷的消息。中午时分，尼赫鲁总理宣布最新战况，整个大厅鸦雀无声。尼赫鲁几乎是结结巴巴的说：“印军在中印边界东段和西段全线溃败。”印度动摇了。关于这一天，也就是11月20日，美国大使在向华盛顿的紧急报告中是这样说的：“新德里出现了极度的惊慌，这是我生平第一次看到一个民族士气的瓦解。”当天深夜3点，一下苍老了许多的尼赫鲁紧急召见美国大使，他请求美国直接进行干预，要求美国派遣轰炸机和战斗机同中国军队作战。根据印度的请求，肯尼迪立即下令美国太平洋舰队的航空母舰编队紧急驶往孟家拉湾。这时候，新德里到处弥漫着恐惧和流言，说“中国军队已经攻占了边疆重镇提斯普尔，甚至要派伞兵在首都空降”。 并非流言的是，印度的阿萨姆邦已经开始组织居民撤退，银行已经烧毁了30万磅的印度纸币。邦政府正准备对电厂、自来水厂等重要设施进行毁坏性爆破。第二天，全印广播电台突然中断了正常播音，反复播放印度国歌，印度好像即将亡国。而就在这个时候，北京突然发布了一条消息，中国政府声明：“自1962年11月21日起，中国边防部队在中印边境全线停火，并宣布于9天之后，即12月1日起，中国军队后撤到开战前的实际控制线，并从这条线上再后撤20公里，重新恢复中印边界自1959年中国单方面宣布并保持的状态，中国政府这个决定同时作为命令在前线向全体参战部队宣读。”由于印度政府的通讯系统已陷于混乱，中国政府的声明尼赫鲁不是通过外交渠道获得的，而是从他的内务部长在飞机场抢购的报纸上看到的。 北京的声明发布后，中国军队开始在整个战区捡拾印军遗弃的的数以千计的武器，其中很多英美装备刚运到前线，还没来得及开箱。据战后披露的资料，当时在总理府，尼赫鲁拿着从街上买来的报纸，看着上面用大号铅字印成的标题，愣愣地坐在办公桌前。他的第一个反应是：马上召见中国驻印度大使。当他从中国外交官口中证实了北京宣布停火后撤的消息以后，径直问了一句：“你们到底是什么意思？”几天以后，当中国开始向印军移交缴获的武器时，尼赫鲁真给弄糊涂了。周恩来为此再次致函尼赫鲁：“中国政府所以这样做是为了谋求真正解决边界问题的途径。我们欢迎尼赫鲁先生来北京，如果有所不便，我愿意再次去新德里。”印度政府沉默了，中国政府等待着印度的回复。 中国从印度东北边境的公路上遣返了全部印军战俘，其中26名印军士兵因重伤抢救无效而死亡。中国移交他们的遗体时，附有详细的病历和抢救记录。据战后统计，印军死亡1383名，失踪1696名，被俘3968名。中国军队无一人被俘，死伤人数至今没有解密。印度所谓的前进政策到此时，寿终正寝，阵亡的印军士兵成为它的殉葬品。 好几个星期后，溃散的印军士兵陆续从山路地带走到平原，因为停火，有7000人得以生还。最后印度政府下达给印军的命令是，“遵守停火协定，我军队不得进行任何挑衅，印军不能再推进到麦克马红线前沿。”尼赫鲁同时把这个进阶的秘密保证通过新西兰总理班达拉耐克夫人悄悄地转达给北京的周恩来。 自中国政府声明停火撤军，并自己给自己规定了一个期限，越接近这个期限，各国新闻界越沉寂，最后一两天完全静默。12月1日，中国军队真的拔营收兵，开始回撤，世界舆论界一下活跃起来。英国报纸转引的一位外交官的话最有代表性。这位外交官说：“中国在大获全胜后，竟原线撤回，一个战胜国，不利用军事胜利索取更多的东西，有史以来是第一次。”美国一家报纸说：“中国的撤军与其说让人们松了一口气，倒不如说又使人们大吃一惊。” 面对这样一个真实的事实，世界各大通讯社展开了一轮新的新闻大战，全世界都想弄明白中国到底怎么了。巴黎一条电讯说：“外交人士认为中国是担心西方大规模武装干涉。”伦敦则发出一条消息说：“分析家认为中国屈从了来自苏联的压力。”莫斯科却评论说：“这是中国迫于国内的饥荒而不得已采取的下策。”美国援引军事专家的话术，“中国顾及战线过长，需要争取时间获得补充，下一步还将有更大的军事行动。”印度总理尼赫鲁始终以一种深谙政治的眼光，疑惑地注视着中印边界前线，他在议会上反复嘟囔着，“这是一个阴谋。”其实，早在战争开始的3年前，中印边界战争的轮廓就已经渐显，中印边界战争的结尾也已经奠定。三年前，周恩来在新德里面对150名外国记者的提问时，就已经说出了战争的结尾。当时的速记稿是这样记录的，周恩来说：“中国、印度共同有着5000年的古老文明，印度的圣河佛殿经典颂文曾经给中华民族的成长注入过丰富的营养。中国的四大发明，特别是造纸术和火药，也为印度的经济文化的繁荣做过贡献。几千年来，我们一直和平共处，休养生息。在历史的长河中，中印之间从未发生过真正的战争。”周恩来最后说：“我想再说一句，我们这一代人，即使遇到再大的问题，也应坐下来和平协商、谈判解决，切不可对上辜负了列祖列宗的遗德，对下贻害后代子孙。” 中国撤军了，一直撤到麦克马洪线以北20公里，不愧于一只威武正义之师。 一年以后，印军又进入到麦克马洪线，但这次它没有再炫耀武力。中印边境之战规模并不大，但在历史的天平上却异常沉重。在中国漫长的封建时期，没有严格的边境，通常是在军队延伸的尽头构筑烽火台，它们便成了边陲的标志。自明代以后，随着中华封建帝国的衰微，边境也不断的收缩，一座座烽燧淹没在漫漫黄沙之间。1840年鸦片战争后，中国的边境向列强洞开，疆域被宰割的不成样子。直至第二次世界大战结束，中国作为战胜国，领土却又缩小了100多万平方公里。正是由于新的人民共和国的诞生，领土和主权的尊严才重新回到了中国。中印边界自卫反击战是新中国为捍卫领土完整而被迫进行的第一次对外战争。交战地点是渺无人际的高原、莽原、荒原，却是新中国将士要用热血捍卫的热土、固土、领土。在边境上有那么多忠勇无畏的军人倒下了，却让世界看清了一个崛起的巨人本应有的庄重和自尊。","categories":[],"tags":[{"name":"共和国战争","slug":"共和国战争","permalink":"https://naosense.github.io/tags/%E5%85%B1%E5%92%8C%E5%9B%BD%E6%88%98%E4%BA%89/"}]},{"title":"Awesome Rust Software","slug":"Awesome-Rust-Software","date":"2023-02-11T14:13:45.000Z","updated":"2025-09-16T02:08:42.952Z","comments":true,"path":"2023/02/11/Awesome-Rust-Software/","link":"","permalink":"https://naosense.github.io/2023/02/11/Awesome-Rust-Software/","excerpt":"","text":"本文将会持续推荐一些我使用过感觉不错的rust软件，尽情期待！ fd fd号称A simple, fast and user-friendly alternative to ‘find’。可见fd相比find一是快，二是使用友好。根据作者的benchmark，fd字面量搜索和正则表达式搜索分别是find的5倍和9倍，除了快，它的使用更简单，更符合直觉。 说到find命令的功能强大，相信很少有人能够否认，但是要是说到它的用法难记，相信很多人都能感同身受。以大家使用find最多的场景为例，查找文件夹中某个名字的文件，通常这个名字也记不太完整，需要模糊搜索。在find中需要 find -iname '*PATTERN*' 而fd只需要 fd PATTERN 可以看到fd默认就是针对文件名的模糊搜索，可能看起来二者区别也没那么大，但是我每次用find都得百度一番，不知道我是不是个例，我觉得之所以这样就是因为find缺少符合直觉的默认选项，一个工具如果你时时刻刻都在用，它繁琐一些可能不是个事，但是如果你只是偶尔或者不那么经常用，一个符合直觉的默认选项就显得尤为重要了。 其他一些常用方法： 1、使用正则表达式 fd '^x.*rc$' 2、默认搜索当前文件夹，可以这样指定文件夹 fd passwd /etc 3、使用-e指定文件类型 fd -e md fd -e rs mod 4、使用-g精确匹配 fd -g libc.so /usr 5、使用-H和-I包含隐藏和忽略的文件。默认fd是不搜索隐藏文件和.gitignore忽略的文件的，可以同时启用两者-HI fd -H pre-commit fd -I num_cpu 6、使用-p匹配路径。默认fd只匹配文件名 fd -p -g '**/.git/config' fd -p '.*/lesson-\\d+/[a-z]+.(jpg|png)' 7、使用-x对单个匹配结果执行命令，-X对所有结果批量执行命令 fd -e zip -x unzip fd -g 'test_*.py' -X vim 8、使用-E排除某些文件 fd -H -E .git … fd -E '*.bak' … ripgrep ripgrep recursively searches directories for a regex pattern while respecting your gitignore ripgrep的优势之一也是快，根据作者自己的benchmark，在小文件上是grep快8倍，在大文件上是grep的3倍。更加重要的是，它和fd一样，也有一个更符合直觉的默认选项。 先来个quick start，使用rg搜索自己工程的README， &gt; rg fast README.md 90: because it contains most of their features and is generally faster. (See 105: color and full Unicode support. Unlike GNU grep, ripgrep stays fast while 154:### Is it really faster than everything else? 159:Summarizing, ripgrep is fast because: 164: optimizations to make searching very fast. (PCRE2 support can be opted into 而grep的输出是这样的， &gt; grep fast README.md because it contains most of their features and is generally faster. (See color and full Unicode support. Unlike GNU grep, ripgrep stays fast while ### Is it really faster than everything else? Summarizing, ripgrep is fast because: optimizations to make searching very fast. (PCRE2 support can be opted into 可以看到，和fd一样，ripgrep默认也是模糊搜索，打印匹配的行，同时还会带上行数。 rg大部分请求使用起来和grep差不多，一些常用的选项如下： 1、正则表达式 rg 'fast\\w+' README.md 2、递归搜索当前文件夹中的所有文件 rg 'fast' 3、使用-t指定文件类型 rg 'fn run' -trust 4、使用-w精确搜索word rg fast -w README.md 5、使用--no-ignore搜索.gitignore忽略的文件，-.搜索隐藏文件，-a搜索二进制文件，还有一个更简化的选项-u，-u包含所有被忽略的文件，-uu会再加上隐藏文件，-uuu会再加上二进制文件 6、使用-g设置文件过滤规则 # 只搜索toml文件 rg clap -g '*.toml' # 搜索除toml之外的文件 rg clap -g '!*.toml' # -g可以出现多次 rg clap -g '!*.toml' -g '*.rust' 7、使用-r进行替换 rg fast README.md -r FAST 8、使用-c只打印匹配次数 rg -c fast zellij 相信很多人之前都用过tmux，我自己也尝试过，但是被它繁琐的快捷键劝退。后来也忘了从哪里听说了zellij，尝试之后发现最吸引我的一点是它有个功能QuickNav，会根据你所处的上下文，将可能的快捷键展示出来，非常适合忘性比较高的人。另外，zellij的面板可以无限切分，你甚至可以切分出来下面这种不规则的界面， 它还支持浮动面板，非常适合一些临时的、一次性的命令运行， 习惯tmux的人也不用担心，它有个tmux模式，快捷键和tmux里基本相同。它是用rust软件开发的，得益于rust语言本身的安全性，高性能，以及活跃的社区，这些特性可以说是唾手可得的free lunch。相比tmux，它的界面更年轻，更现代，开发更活跃，当然这并不意味着zellij还处于“蛮荒”时期，相反它已经具有相当的可用性，支持tmux类似的session、tab、pane、plugin概念，基本可以作为tmux的平替软件。 zellij的维护者都非常nice，择善而从又不失自己的原则，特别是Aram Drevekenin、har7an，zellij更年轻，更活跃，意味着你有机会和它一起成长，一起见证、推动、或者参与一些激动人心的功能的加入，尝试一下，你不会后悔！","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://naosense.github.io/tags/rust/"},{"name":"fd","slug":"fd","permalink":"https://naosense.github.io/tags/fd/"},{"name":"ripgrep","slug":"ripgrep","permalink":"https://naosense.github.io/tags/ripgrep/"},{"name":"zellij","slug":"zellij","permalink":"https://naosense.github.io/tags/zellij/"},{"name":"tmux","slug":"tmux","permalink":"https://naosense.github.io/tags/tmux/"}]},{"title":"从乐高玩具到Parser Combinator","slug":"从乐高玩具到Parser Combinator","date":"2023-01-01T16:17:23.000Z","updated":"2025-09-16T02:08:42.963Z","comments":true,"path":"2023/01/01/从乐高玩具到Parser Combinator/","link":"","permalink":"https://naosense.github.io/2023/01/01/%E4%BB%8E%E4%B9%90%E9%AB%98%E7%8E%A9%E5%85%B7%E5%88%B0Parser%20Combinator/","excerpt":"什么是Parser Combinator 作为程序员，或多或少都会接触到解析字符串的任务， 比如从日志中解析出用户和id，这种工作可以用正则表达式轻松搞定，但是如果是解析json、xml这样复杂的结构，正则表达式就有点力不从心啦，这个时候有经验的程序员可能会想起Antlr、Yacc类似的解析器生成器，没错，这是一个可行的方案，这个方案需要你了解基本的词法、语法知识，编写一些晦涩的EBNF文件，不过好在除了这套方案，还有另一种方法，那就是今天要说的Parser Combinator。","text":"什么是Parser Combinator 作为程序员，或多或少都会接触到解析字符串的任务， 比如从日志中解析出用户和id，这种工作可以用正则表达式轻松搞定，但是如果是解析json、xml这样复杂的结构，正则表达式就有点力不从心啦，这个时候有经验的程序员可能会想起Antlr、Yacc类似的解析器生成器，没错，这是一个可行的方案，这个方案需要你了解基本的词法、语法知识，编写一些晦涩的EBNF文件，不过好在除了这套方案，还有另一种方法，那就是今天要说的Parser Combinator。 如果你去网上搜索它，上面的文章上来不是Monad、Functor，就是范畴论、幺半群这些玄而又玄的概念，以致于我虽然很早就听过Parser Combinator，但一直都只敢远观。直到最近看了Bodil一篇文章，写的深入浅出。看完之后我才知道Parser Combinator原来是两种算子，一种叫解析器，另一种叫组合器，也叫组合子，原理也很直接，就像搭积木，由一些基本的构件搭出城堡的各个部分，再由各个部分搭出整个城堡，整个过程没啥玄学。原文中的程序是Rust编写的，考虑到Rust语言的受众规模，以及Rust的一些核心理念会平白增加编写Parser Combinator的难度，比如借用引用、生命周期，我打算用Scala重写一下，并按照Scala的习惯做下调整。 我一直认为最好的学习方法是learn by doing。因此建议大家在电脑上跟着敲一遍代码，哪怕只是粘贴一下看看运行效果，你绝对能找到和玩乐高类似的乐趣。 简化版xml解析器 我们的目标是编写一个简化版的xml解析器，因为完整的xml包含namespaces、schema等一大堆琐碎的概念，要实现一个完备的解析器用来作为入门还是过于复杂了，因此我们只实现xml的一个子集，下面是一段示例， &lt;parent-element&gt; &lt;single-element attribute=&quot;value&quot; /&gt; &lt;/parent-element&gt; 可以看到，它的结构有两种： 一开一闭(open-close-element)：&lt;标识符&gt;&lt;/标识符&gt; 单元素(single-element)：&lt;标识符/&gt; 第一种通常会包含一些子元素，子元素通常又会包含孙元素，形成一种递归结构。标识符后面还会有一些空白符分割的可选属性对，比如上面的attribute=&quot;value&quot;。合格的标识符由字母开头，后面可以使用字母数字或-。 解析器的类型 让我们首先想一下，什么是解析器？一个解析器就是给它一个字符串，然后它把你感兴趣的内容挑出来输出给你，在scala中就可以这么表示， String =&gt; Try[(String, Output)] Try有两个子类Success和Failure，正好可以用来表示解析成功与否，(String, Output)是一个二元组，前面的元素表示剩余未被解析的字符串，后面的Output表示最终的输出格式，由于这个格式不定，所以表示为一个泛型。 字符a解析器 先拿一个简单的练练手，来编写关于字符a的解析器。 def theLetterA(input: String): Try[(String, Unit)] = &#123; input.toList match &#123; case first :: rest if first == 'a' =&gt; Success((rest.mkString, ())) case _ =&gt; Failure(ParseError(input)) &#125; &#125; case class ParseError(input: String) extends Throwable case class Element(name: String, attributes: Vector[(String, String)], children: Vector[Element]) 这段代码的逻辑是将input转成字符列表，如果第一个字符为a，则解析成功，否则失败。这里我们定义了自己的错误类ParseError以及最终的解析结果数据结构Element。你可能注意到输出的位置上写的是Unit，它的含义类似Java中的void，这表示我们并不关心解析器的输出，这种解析器的作用只是为了将输入的解析位置往前推进，这种类型的解析器下面还会看到。 字面量解析器 有了前面字符a的解析器基础，下面我们编写一个解析任意字符串字面量的解析器， def literal(expected: String): Parser[Unit] = &#123; (input: String) =&gt; &#123; input.take(expected.length) match &#123; case s if s == expected =&gt; Success((input.drop(expected.length), ())) case _ =&gt; Failure(ParseError(input)) &#125; &#125; &#125; 注意看，这个函数属于高阶函数，它的返回值本身也是一个函数。基本逻辑是输入的开头部分如果和字面量expected匹配上就成功，否则失败。 下面编写这个解析器的测试用例，使用的测试框架是munit， test(&quot;literal parser&quot;) &#123; val parseJoe = literal(&quot;Hello Joe!&quot;) assertEquals(parseJoe.parse(&quot;Hello Joe!&quot;), Success(&quot;&quot;, ())) &#125; 运行一下，测试通过。因为literal返回是一个函数，所以可以像函数那样调用它。作为一个小tip，如果你使用sbt，你可以使用~testOnly YOUR-TEST_CASE进行持续测试，源文件一发生改变，测试就会自动运行，可以提高测试的效率。 标识符解析器 还记得上面我们说过一个合法的标识符组成规则吗，对，首字符字母，后面是任意个字母数字或-。 def identifier(input: String): ParseResult[String] = &#123; val matched = new StringBuilder() input.toList match &#123; case first :: _ if first.isLetter =&gt; matched.append(first) case _ =&gt; return Failure(ParseError(input)) &#125; matched.append(input.drop(1).takeWhile(c =&gt; c.isLetterOrDigit || c == '-')) val nextIndex = matched.length; Success((input.drop(nextIndex), matched.toString())) &#125; 这里的逻辑是首先去检测第一个字符是不是合法，如果合法将它收集到matched中，并检测后续符合要求的字符并收集，否则直接失败退出。与之前不同的一点是，在返回值上Output的位置这次为String，这是因为标识符的名字通常是很重要的信息，我们需要将它保存下来。 同样，我们编写这个解析器的测试用例， test(&quot;identifier parser&quot;) &#123; assertEquals(identifier(&quot;i-am-an-identifier&quot;), Success((&quot;&quot;, &quot;i-am-an-identifier&quot;))) assertEquals(identifier(&quot;not entirely an identifier&quot;), Success((&quot; entirely an identifier&quot;, &quot;not&quot;))) assertEquals(identifier(&quot;!not at all an identifier&quot;), Failure(ParseError(&quot;!not at all an identifier&quot;))) &#125; 这三个用例第一个很好理解，i-am-an-identifier一整个是一个合法的标识符，第二个因为空格不能包含在标识符中，所以解析到not后面的空格就终止了，第三个因为开头的叹号不属于合法的字符，因此返回失败。 组合组合子 现在解析字符串的解析器有了，解析标识符的解析器也有了，想要解析&lt;identifier这样的字符串，还得有个将两个解析器组合起来的功能。 def pair[R1, R2](parser1: (String) =&gt; Try[(String, R1)], parser2: (String) =&gt; Try[(String, R2)]): String =&gt; Try[(String, (R1, R2))] = &#123; (input: String) =&gt; &#123; parser1(input) match &#123; case Success((nextInput, result1)) =&gt; parser2(nextInput) match &#123; case Success((finalInput, result2)) =&gt; Success((finalInput, (result1, result2))) case Failure(ex) =&gt; Failure(ex) &#125; case Failure(ex) =&gt; Failure(ex) &#125; &#125; &#125; 这里的逻辑是parser1先去解析，如果失败直接退出，否则由parser2去解析剩余的输入nextInput，如果成功，将两个解析器的结果组成一个二元组输出，否则失败退出。这意味着，两个解析器的都得解析成功，整体才是成功，否则就失败了。 有了这个组合器我们就有了组合任意两个解析器的能力，有点搭积木的意思了哈。同样地，测试用例来一个。 test(&quot;pair combinator&quot;) &#123; val tagOpener = pair(literal(&quot;&lt;&quot;), identifier _) assertEquals(tagOpener.parse(&quot;&lt;my-first-element/&gt;&quot;), Success((&quot;/&gt;&quot;, ((), &quot;my-first-element&quot;)))) assertEquals(tagOpener.parse(&quot;oops&quot;), Failure(ParseError(&quot;oops&quot;))) assertEquals(tagOpener.parse(&quot;&lt;!oops&quot;), Failure(ParseError(&quot;!oops&quot;))) &#125; 注意第一个用例的Output类型为((), String)，()其实对我们没意义，我们只想要第二个解析器的结果，这就引申出来两个通用的组合子left和right，用于对结果进行修剪。 类型转换组合子 在认识left和right之前，我们先认识另一个通用的组合子map，map在很多编程语言中都有，作用大同小异，基本上就是将一个类型转换成另一个，有了它编写left和right就水到渠成了，因为使用map配合一个映射函数很容易就可以将二元组的其中一个元素挑出来。 def map[A, B](parser: (String) =&gt; Try[(String, A)], fn: A =&gt; B): (String) =&gt; Try[(String, B)] = &#123; (input: String) =&gt; &#123; parser(input) match &#123; case Success((nextInput, result)) =&gt; Success((nextInput, fn(result))) case err@Failure(_) =&gt; err.asInstanceOf[Try[(String, B)]] &#125; &#125; &#125; 首先parser去解析input，如果成功，转换函数fn将输出转换为另一种类型，如果失败，将原始错误返回。 打扫屋子再请客 在继续前进之前，先让我们停下来看一看已经完成的代码，大量的Try[(String, Output)]，String =&gt; Try[(String, Output)]冗长的类型充斥期间，是时候对代码进行一波“打扫”了。首先，使用type alias对Try[(String, Output)]进行化简， type ParseResult[Output] = Try[(String, Output)] 然后定义一个trait Parser，然后使用隐式转换机制将String =&gt; Try[(String, Output)]转换为Parser， @FunctionalInterface trait Parser[Output] &#123; def parse(input: String): ParseResult[Output] &#125; implicit def function2parser[Output](f1: String =&gt; ParseResult[Output]): Parser[Output] = &#123; (input: String) =&gt; f1.apply(input) &#125; 然后使用Parser和ParseResult分别去替换Try[(String, Output)]和String =&gt; Try[(String, Output)]，比如map重写后的如下， def map[A, B](parser: Parser[A], fn: A =&gt; B): Parser[B] = &#123; (input: String) =&gt; &#123; parser(input) match &#123; case Success((nextInput, result)) =&gt; Success((nextInput, fn(result))) case err@Failure(_) =&gt; err.asInstanceOf[ParseResult[B]] &#125; &#125; &#125; 是不是比之前看起来比之前清爽多了。同样，重写下pair， def pair[R1, R2](parser1: Parser[R1], parser2: Parser[R2]): String =&gt; ParseResult[(R1, R2)] = &#123; (input: String) =&gt; &#123; parser1(input) match &#123; case Success((nextInput, result1)) =&gt; parser2(nextInput) match &#123; case Success((finalInput, result2)) =&gt; Success((finalInput, (result1, result2))) case Failure(ex) =&gt; Failure(ex) &#125; case Failure(ex) =&gt; Failure(ex) &#125; &#125; &#125; 同样的方式，将前面所有的代码进行下替换。 结果提取组合子 有了pair和map，left和right已经呼之欲出了。 def left[R1, R2](parser1: Parser[R1], parser2: Parser[R2]): Parser[R1] = &#123; map(pair(parser1, parser2), &#123; case (l, _) =&gt; l &#125;) &#125; def right[R1, R2](parser1: Parser[R1], parser2: Parser[R2]): Parser[R2] = &#123; map(pair(parser1, parser2), &#123; case (_, r) =&gt; r &#125;) &#125; 逻辑很简单，left将二元组的第一个元素返回，right将二元组的第二个元素返回。 老样子，测试用例 test(&quot;right combinator&quot;) &#123; val tagOpener = right(literal(&quot;&lt;&quot;), identifier _) assertEquals(tagOpener.parse(&quot;&lt;my-first-element/&gt;&quot;), Success((&quot;/&gt;&quot;, &quot;my-first-element&quot;))) assertEquals(tagOpener.parse(&quot;oops&quot;), Failure(ParseError(&quot;oops&quot;))) assertEquals(tagOpener.parse(&quot;&lt;!oops&quot;), Failure(ParseError(&quot;!oops&quot;))) &#125; 这些用例和上面pair的用例极为相似，需要注意的只有第一个用例，观察和pair的第一个用例有哪些不同，对，类型由((), String)变成了String，这正是我们想要达成的效果。 表示重复的组合子 还记得我们最开始介绍xml格式的时候说过，xml包含一些可选的属性对，它们以空白字符分割。这里面有两个关键词：“一些”和“可选”，如何表示这种含义呢？为此我们抽象出两个组合子：“一次及以上”和“零次及以上”，想想看，正则表达式也有类似的设计。 我们先来看“一次及以上” def oneOrMore[A](parser: Parser[A]): Parser[Vector[A]] = &#123; (input: String) =&gt; &#123; var result = Vector[A]() var remain = input parser.parse(remain) match &#123; case Success((nextInput, firstItem)) =&gt; &#123; remain = nextInput result :+= firstItem var break = false while (!break) &#123; parser.parse(remain) match &#123; case Success((nextInput, nextItem)) =&gt; &#123; remain = nextInput result :+= nextItem &#125; case Failure(exception) =&gt; break = true &#125; &#125; Success((remain, result)) &#125; case err@Failure(exception) =&gt; err.asInstanceOf[ParseResult[Vector[A]]] &#125; &#125; &#125; 这里的逻辑是parser解析第一次必须得成功，否则直接就失败了，因为是一次及以上嘛。之后，可以成功，也可以失败，都不重要。聪明的你肯定已经想到了“零次及以上”的写法，就是把第一段去掉呗。 def zeroOrMore[A](parser: Parser[A]): Parser[Vector[A]] = &#123; (input: String) =&gt; &#123; var result = Vector[A]() var remain = input var break = false while (!break) &#123; parser.parse(remain) match &#123; case Success((nextInput, nextItem)) =&gt; remain = nextInput result :+= nextItem case Failure(_) =&gt; break = true &#125; &#125; Success((remain, result)) &#125; &#125; 不需赘述。 测试用例 test(&quot;one or more combinator&quot;) &#123; val parser = oneOrMore(literal(&quot;ha&quot;)) assertEquals(parser.parse(&quot;hahaha&quot;), Success((&quot;&quot;, Vector((), (), ())))) assertEquals(parser.parse(&quot;ahah&quot;), Failure(ParseError(&quot;ahah&quot;))) assertEquals(parser.parse(&quot;&quot;), Failure(ParseError(&quot;&quot;))) &#125; test(&quot;zero or more combinator&quot;) &#123; val parser = zeroOrMore(literal(&quot;ha&quot;)) assertEquals(parser.parse(&quot;hahaha&quot;), Success((&quot;&quot;, Vector((), (), ())))) assertEquals(parser.parse(&quot;ahah&quot;), Success((&quot;ahah&quot;, Vector.empty))) assertEquals(parser.parse(&quot;&quot;), Success(&quot;&quot;, Vector.empty)) &#125; 注意比较这两个解析器的不同，后两个一样的用例，一个失败，一个成功。想想为什么？ 谓词组合子 盘点一下，我们可以用literal解析&lt;&gt;这样的字面量，可以用identifier解析标识符，可以用pair组合任意两个解析器，可以使用oneOrMore或者zeroOrMore多次应用一个解析器，用这些去解析空白符分割的属性对时是否已经够了呢？注意这里是空白符，不单指空格，还包括制表符、换行符、回车符，还有一堆unicode字符也属于空白符。对，我们还缺少一个空白符解析器。 如果我们有“或”组合子，可以用它将一堆空格、制表符、换行符等连起来，但这个法子太笨了。我们是聪明人，我们肯定得用聪明的法子。聪明的办法是一种更通用的方法：抽象出一个谓词组合子，通过传入的谓词判断是否是空白符，在各种语言中，这种函数基本上是现成的。 def pred[A](parser: Parser[A], predicate: A =&gt; Boolean): Parser[A] = &#123; (input: String) =&gt; &#123; parser.parse(input) match &#123; case Success((nextInput, value)) if predicate(value) =&gt; Success((nextInput, value)) case _ =&gt; Failure(ParseError(input)) &#125; &#125; &#125; 逻辑基本上就是上面所说的，只有当parser的结果符合predicate的要求时，才会返回成功，否则一律失败。 为了实现空白符解析器，还需要一个anychar，它的作用是返回任意一个字符，用来驱动解析位置往前走。 def anychar(input: String): ParseResult[Char] = &#123; input.toList match &#123; case first :: rest =&gt; Success((rest.mkString, first)) case _ =&gt; Failure(ParseError(input)) &#125; &#125; 有了这两个，空白符就可以表示为符合c =&gt; c.isWhitespace的任意字符。 def whitespace(): Parser[Char] = &#123; pred(anychar, c =&gt; c.isWhitespace) &#125; 老样子，编写下测试用例，验证下算子的逻辑 test(&quot;predicate combinator&quot;) &#123; val parser = pred(anychar, (c: Char) =&gt; c == 'o') assertEquals(parser.parse(&quot;omg&quot;), Success((&quot;mg&quot;, 'o'))) &#125; 有了whitespace，配合oneOrMore和zeroOrMore，就可以表示“一个及以上的空白符”和“零个及以上的空白符”。 def space1(): Parser[Vector[Char]] = &#123; oneOrMore(whitespace()) &#125; def space0(): Parser[Vector[Char]] = &#123; zeroOrMore(whitespace()) &#125; 引用字符串 属性的值都是双引号包裹的字符串，因此我们还需要编写一个解析引用字符串的解析器， def quotedString(): Parser[String] = &#123; map( right( matchLiteral(&quot;\\&quot;&quot;), left( zeroOrMore(pred(anyChar, (c: Char) =&gt; c != '&quot;')), matchLiteral(&quot;\\&quot;&quot;) ) ), (chars: Vector[Char]) =&gt; chars.mkString ) &#125; 这里的逻辑是，首先匹配开头的一个双引号，然后中间匹配除双引号之外的任何字符，最后再匹配结尾的一个双引号。使用left和right只将中间的值拿出来。 让我们快速写一个用例，来验证下正确性。 test(&quot;quoted string parser&quot;) &#123; assertEquals(quotedString().parse(&quot;\\&quot;Hello Joe!\\&quot;&quot;), Success(&quot;&quot;, &quot;Hello Joe!&quot;)) &#125; 不错，一切正常，胜利就在眼前！ 属性对解析器 现在，关于属性解析已经万事俱备了，我们可以先写一个解析单个属性对的解析器，配合zeroOrMore再写出解析若干属性对的解析器。单个的如下， def attributePair(): Parser[(String, String)] = &#123; pair(identifier, right(literal(&quot;=&quot;), quotedString())) &#125; 逻辑直截了当，首先匹配一个标识符，再匹配一个＝，最后匹配属性值，也就是引用字符串。使用zeroOrMore将其组合起来就可以解析多个属性对了，同时不要忘了中间的空白符。 def attributes(): Parser[Vector[(String, String)]] = &#123; zeroOrMore(right(space1(), attributePair())) &#125; 测试一下 test(&quot;attribute parser&quot;) &#123; assertEquals(attributes().parse(&quot; one=\\&quot;1\\&quot; two=\\&quot;2\\&quot;&quot;), Success(&quot;&quot;, Vector((&quot;one&quot;, &quot;1&quot;), (&quot;two&quot;, &quot;2&quot;)))) &#125; 运行，一切正常，和谐完美！ 一步之遥 随着“一块一块积木“的搭建，城堡最终的样子已经越来越清晰了。让我们稍微按捺一下激动的心情，回想一下上文说过的：xml的元素分两种，一种是一开一闭可以包含子元素&lt;div class=&quot;good&quot;&gt;children&lt;/div&gt;，一种是单元素结构&lt;div class=&quot;good&quot;/&gt;，它们有一个共同结构即&lt;div class=&quot;good&quot;部分，因此将这一部分提炼出来可能会大有用处。 def elementStart(): Parser[(String, Vector[(String, String)])] = &#123; right(literal(&quot;&lt;&quot;), pair(identifier, attributes())) &#125; 首先去匹配&lt;，然后匹配标识符和属性对，然后使用right将标识符和属性对的值拿出来放在Vector[(String, String)]。单元素的解析器如下，相比上面只需在后面匹配下/&gt;就可以了。 def singleElement(): Parser[Element] = &#123; map( left(elementStart(), matchLiteral(&quot;/&gt;&quot;)), &#123; case (name, attributes) =&gt; Element(name, attributes, Vector()) &#125; ) &#125; 类似地，open-element可以这么写， def openElement(): Parser[Element] = &#123; map( left(elementStart(), literal(&quot;&gt;&quot;)), &#123; case (name, attributes) =&gt; Element(name, attributes, Vector()) &#125; ) &#125; 注意它的返回值是我们一开始定义的Element，通过map算子将结果转成这个类型。 但是close-element咋写呢？这里的难点是开闭元素的名字要对应起来，在使用的时候将开元素的名字传进去。 def closeElement(expected: String): Parser[String] = &#123; pred( right( literal(&quot;&lt;/&quot;), left(identifier, literal(&quot;&gt;&quot;)) ), name =&gt; name == expected ) &#125; 开闭元素这一对可以表示为 def parentElement(): Parser[Element] = &#123; pair( openElement(), left(zeroOrMore(element()), closeElement(**name**)) ) &#125; 但是如何把openElement的解析结果传给closeElement呢？这就要引入另一个通用组合子flatMap，为了更好的可读性将其放在Parser中，类似地，把pred、map也加一下，虽然它们只是外面的pred、map的简单映射，但是可以极大的改善代码可读性。 @FunctionalInterface trait Parser[Output] &#123; def parse(input: String): ParseResult[Output] def map[NewOutput](fn: Output =&gt; NewOutput): Parser[NewOutput] = &#123; ParserCombinator.map(this, fn) &#125; def pred(predicate: Output =&gt; Boolean): Parser[Output] = &#123; ParserCombinator.pred(this, predicate) &#125; def flatMap[NewOutput](fn: Output =&gt; Parser[NewOutput]): Parser[NewOutput] = &#123; (input: String) =&gt; &#123; this.parse(input) match &#123; case Success((nextInput, result)) =&gt; fn(result).parse(nextInput) case err@Failure(_) =&gt; err.asInstanceOf[ParseResult[NewOutput]] &#125; &#125; &#125; &#125; parentElement使用新方法的样子 def parentElement(): Parser[Element] = &#123; openElement().flatMap(el =&gt; left(zeroOrMore(element()), closeElement(el.name)) .map(children =&gt; el.copy(children = children)) ) &#125; openElement将解析结果el返回，然会将el.name传给closeElement，这样只有open和close是一对才会成功。不过回顾xml的结构，我们还需要一个表示“或”的组合子，因为xml有两种元素结构。不过，这对已经身经百炼的你已经是易如反掌了。 def either[A](parser1: Parser[A], parser2: Parser[A]): Parser[A] = &#123; (input: String) =&gt; &#123; parser1.parse(input) match &#123; case ok@Success(_) =&gt; ok case _ =&gt; parser2.parse(input) &#125; &#125; &#125; either有两个解析器入参，如果parser1的结果成功，直接返回结果，如果失败，继续尝试parser2，直接将结果返回。这意味着，只要两个解析器只要有一个成功，那整体结果就是成功的。 最后一块积木 好吧，终于看到胜利的曙光了。让我们将最后一块积木放上去，然后好好欣赏下我们的作品吧！ def element(): Parser[Element] = &#123; either(singleElement(), parentElement()) &#125; test(&quot;xml parser&quot;) &#123; val doc = &quot;&quot;&quot;&lt;top label=&quot;Top&quot;&gt; | &lt;semi-bottom label=&quot;Bottom&quot;/&gt; | &lt;middle&gt; | &lt;bottom label=&quot;Another bottom&quot;/&gt; | &lt;/middle&gt; |&lt;/top&gt; |&quot;&quot;&quot;.stripMargin val parseDoc = Element( &quot;top&quot;, Vector((&quot;label&quot;, &quot;Top&quot;)), Vector( Element(&quot;semi-bottom&quot;, Vector((&quot;label&quot;, &quot;Bottom&quot;)), Vector()), Element(&quot;middle&quot;, Vector(), Vector(Element(&quot;bottom&quot;, Vector((&quot;label&quot;, &quot;Another bottom&quot;)), Vector()))) ) ) assertEquals(element().parse(doc), Success((&quot;&quot;, parseDoc))) &#125; 运行下，竟然报错了，好在报错信息还是比较详细。 values are not the same =&gt; Diff (- obtained, + expected) -Failure( - exception = ParseError( - input = &quot;&quot;&quot; - &lt;semi-bottom label=&quot;Bottom&quot;/&gt; - &lt;middle&gt; - &lt;bottom label=&quot;Another bottom&quot;/&gt; - &lt;/middle&gt; -&lt;/top&gt; -&quot;&quot;&quot; +Success( + value = Tuple2( + _1 = &quot;&quot;, + _2 = Element( + name = &quot;top&quot;, + attributes = Vector( + Tuple2( + _1 = &quot;label&quot;, + _2 = &quot;Top&quot; + ) + ), + children = Vector( + Element( + name = &quot;semi-bottom&quot;, + attributes = Vector( + Tuple2( + _1 = &quot;label&quot;, + _2 = &quot;Bottom&quot; + ) + ), + children = Nil + ), + Element( + name = &quot;middle&quot;, + attributes = Nil, + children = Vector( + Element( + name = &quot;bottom&quot;, + attributes = Vector( + Tuple2( + _1 = &quot;label&quot;, + _2 = &quot;Another bottom&quot; + ) + ), + children = Nil + ) + ) + ) + ) + ) ) 仔细看下报错，可以看到解析器好像解析完&lt;top label=&quot;Top&quot;&gt;就停止了，这是咋回事呢？观察要解析的xml，在标签之间有许多换行和空格，而element并没有处理这一情况。 &lt;top label=&quot;Top&quot;&gt; &lt;semi-bottom label=&quot;Bottom&quot;/&gt; &lt;middle&gt; &lt;bottom label=&quot;Another bottom&quot;/&gt; &lt;/middle&gt; &lt;/top&gt; 我们需要引入另一个组合子wrap，它会忽略周围的空白符。 def wrap[A](parser: Parser[A]): Parser[A] = &#123; right(space0(), left(parser, space0())) &#125; 这应该就是xml解析器的完全体了。 def element(): Parser[Element] = &#123; wrap(either(singleElement(), parentElement())) &#125; 重新运行下测试用例，通过，完美！真是好事多磨啊！ 让我们简单的总结下，最开始通过theLetterA第一次认识了解析器，由此隐身出来解析字符串的literal，接下来又结识了解析标识符的identifier，然后通过pair将二者结合起来完成了对xml标识符的解析，接下来又引入了map、oneOrMore、zeroOrMore、pred等完成了对属性的解析，最后引入either处理单元素结构和包含子元素的开闭结构，整个过程是不是特别像搭积木？ 下一步工作 如果想在实际项目中使用，我们这个toy解析器还是太naive了。如果大家想更深入的了解Parser Combinator，Scala可以看下fastparse, Rust可以看下nom。 Common Pattern 也许在一开始，你可能会疑问为啥要实现这些算子而不是那些算子，因为在上面的旅程中，你可能已经体会到到达终点的路不是一条，那为什么独独选这一条呢？很好的问题，事实上，上面的好多算子彼此有不少联系，一些更专有的算子可以用另一些更基础的算子重写，通过不停的分解，归并，你就会发现一些公共模式(Common Pattern)。 比如pair可以重写为， def identifier(input: String): ParseResult[String] = &#123; pair( (anychar _).pred(c =&gt; c.isLetter), zeroOrMore((anychar _).pred(c =&gt; c.isLetterOrDigit || c == '-')) ).parse(input) match &#123; case Success((rest, (first, second))) =&gt; Success((rest, first + second.mkString)) case Failure(exception) =&gt; Failure(ParseError(input)) &#125; oneOrMore可以重写为， def oneOrMore[A](parser: Parser[A]): Parser[Vector[A]] = &#123; pair(parser, zeroOrMore(parser)).map( &#123; case (head: A, tail: Vector[A]) =&gt; head +: tail &#125; ) &#125; 可以发现大部分的算子都用到了map、flatMap、pair、pred，pair有时候也叫combine，pred有时候叫filter，你可能已经在各种编程语言中找到这些算子的影子。有了这些基础算子，你就可以按照自己的喜好构筑自己的应用算子，这就是基础的重要性，或许这就是老子所说的“一生二，二生三，三生万物”吧。 完整代码","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://naosense.github.io/tags/rust/"},{"name":"parser combinator","slug":"parser-combinator","permalink":"https://naosense.github.io/tags/parser-combinator/"},{"name":"scala","slug":"scala","permalink":"https://naosense.github.io/tags/scala/"}]},{"title":"Hexo站点地图网址错误修复方法","slug":"Hexo站点地图网址错误修复方法","date":"2022-10-19T15:12:01.000Z","updated":"2025-09-16T02:08:42.958Z","comments":true,"path":"2022/10/19/Hexo站点地图网址错误修复方法/","link":"","permalink":"https://naosense.github.io/2022/10/19/Hexo%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%E7%BD%91%E5%9D%80%E9%94%99%E8%AF%AF%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"最近升级了下hexo，部署的时候发现sitemap.xml全失效了，每个网址都增加了一个%25字符，比如原本应该是https://naosense.github.io/2016/08/22/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/变成了如下所示网址， 原因应该和升级Hexo版本有关系，网上有一个办法是修改node_modules/hexo-generator-sitemap/sitemap.xml的代码，但是我的原则是“用新不用旧，谁的问题谁解决”，看了下hexo-generator-sitemap的版本才1.2.0，最新版已经3.0.1了，果断升级，重新生成sitemap.xml，一切正常。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://naosense.github.io/tags/hexo/"}]},{"title":"中国工业化成长的代价","slug":"中国工业化成长的代价","date":"2022-01-08T20:49:13.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2022/01/08/中国工业化成长的代价/","link":"","permalink":"https://naosense.github.io/2022/01/08/%E4%B8%AD%E5%9B%BD%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%88%90%E9%95%BF%E7%9A%84%E4%BB%A3%E4%BB%B7/","excerpt":"","text":"断断续续终于把《八次危机》看完了，确实带给我一些关于如何看待中国近代史一些重大事件的新的角度，比如朝鲜战争、大跃进、文化革命、改革开发、新农村、新能源汽车等等，试录一二重点以备忘。 涉及问题领域 一、意识形态 研读本书将还公平于社会主义，还正义于自由主义，还将罪恶还给资本主义。 二、政治体制 中国并没有构建&quot;中央话&quot;集权体制的经济条件，长期以来是以&quot;地方化&quot;为主的资源资本化发展过程。自1957年&quot;二五&quot;以来中央财税占比长期在30%以下，而且越是在&quot;代价很大&quot;的时期，如大炼钢铁、“大跃进”、“文化大革命”，占比就越低。这一局面直到94年被一位&quot;铁腕&quot;领导人的分税制改革所打破将地方财税占比从70%调到50%。 三、城乡二元结构 随着二胎的开发，“人口红利&quot;是近年来愈来愈家喻户晓的一个名词，而本书指出中国的比较优势既非所谓的&quot;人口红利”，也非主流舆论说的私有化和市场化的&quot;改革红利&quot;，因为这两个条件一般发展中人口大国都有，比如印度、巴西，真正的比较优势而是——在城乡二元结构的基本体制和&quot;土地均分制&quot;的基本财产关系约束下，乡村中内在形成的&quot;农户理性&quot;和&quot;村社理性&quot;得以内部化处置外部风险。简而言之，就是农民在分得土地后，进则为城市提供了大量质优价廉的劳动力和大批农业剩余，退则还能为其接锅。土地革命何其重要，堪称&quot;万物之始&quot;。 八次危机 第一次危机（58年~60年) 背景起因 工业化需要原始积累，49年建国的新中国尽管在外交策略上采取的是&quot;一边倒&quot;，但在国内经济极端困难的情况下向苏联多次求援未果，50年6月发生的朝鲜战争在中国付出巨大代价才与苏联建立了战略同盟关系。所以朝战之于中国，不仅如彭总所说列强架起几门大炮就打开中国的日子不复返了，而且客观上还为中国带来了一笔急需的&quot;天使投资&quot;。 然而，由于苏联渐渐背离初心，欲望膨胀，最终两国关系走到破裂的边缘。 中国坚持领土完整和主权独立，苏联不得不按照中苏条约于1956年交回中长铁路和&quot;大连特区&quot;，撤走东北军事基地。 直接后果是苏联对华援助在1957年中断，苏联心有不甘，于1958年又提出新的军事结盟方式，在中国构建联合海空军指挥机构和通信电台系统等符合苏联远东军事战略的要求，对此毛泽东回应道，“你把中国拿去吧，我上井冈山”。 后续演进 1、通过政治关系谈判，争取到后续数十个项目投资。 2、调动地方积极性，将财权、计划管理权、企业管理权等进行下放，由此58年地方财政支出占全国财政支出的比例由57年的29%跃升到55.7%。权力下放导致中央财政下降到20%，为了应对，中央政府以增发货币为手段加快积累。权力下放后，地方政府在没有任何学习时间的情况下，只能参考蜜月期形成的重工业模式推进地方工业化，遂形成了今人看似荒唐的&quot;大炼钢铁&quot;和&quot;大跃进&quot;。 3、强调&quot;自力更生&quot;方针。动员上千万城市人口去农村去生产自救，以弱化城市失业的巨大压力。 4、以农村合作社为抓手进行高效的国民动员，比如粮食征购、大兴农田水利、抚恤军烈属等高强度提取农村剩余价值的工作，使用农产品和矿产品偿还苏联50年投资产生的54亿美元国家债务，即工农剪刀差，关于这一点，梁漱溟与毛泽东有过一次比较激烈的争论，还是挺有意思，具体经过大家可以搜搜看看。这和56年完成的社会主义改造密不可分。 第二次危机（68年~70年） 背景起因 一方面中国处于外部全面封锁，周边环境高度紧张，“树欲静而风不止”，中印边境、中苏边境，包括台湾等等，另一方面，50年代形成的苏联重工业管理模式和&quot;自力更生、独立自主&quot;的经济方针不能一致，外部地缘政治和内部官僚上层建筑与经济方针的矛盾，加之支付巨额债务的压力，共同演化为第二次&quot;赤字+失业&quot;危机。 后续演进 国家基本建设资金一般用于&quot;三线&quot;战略建设，&quot;三线建设&quot;只是国家产业资本空间上的移动，并没有&quot;纵向&quot;的调整工业结构，转移到内陆和山区，企业布局相对分散，不易形成配套条件，投入成本显著增加。 1、集中最好的科技力量上核武器，“要饭的，也要有个打狗棍” 2、宁可遭受损失也要将沿海易受军事打击的基础工业转移到内地，形成国家工业的&quot;大三线&quot;，地方工业的&quot;小三线&quot;的战备经济，64年~80年代中央累积想三线建设投入2052亿 3、在73年中美&quot;战略接近&quot;时，三线建设已初具规模，从当时世界格局和科技水平来看，中国已经形成了打不跨、炸不烂，能长期支持战争的牢固后方基地，使工业化片面集中在沿海城市的状况得到了改变，形成了中国威慑力。今人看旧事，须回到彼时彼地设身处地的想一想再做评判，不要犯&quot;人类不感谢罗辑&quot;的错误。 与58~60类似，又有上千万知青下乡，向农村转嫁危机实现软着陆。 第三次危机（74年~76年） 背景起因 60年代末70年代初中苏发生边界冲突，毛泽东终于利用日益尖锐的美苏矛盾，与72年恢复了与西方国家的关系，从而才能参与国际分工和交换，引进西方生产设备和技术，改变过重的经济结构，试图努力形成产业门类齐全的国家工业体系。 后续演进 72年~74年农业产量由于化肥产量翻番而增加，城市也第一次有了&quot;的确良&quot;服装、尼龙袜和洗衣粉，然后是电视、洗衣机、冰箱新三大件问世。 与50年代第一次外资引进最大的不同是不再有当年的战略合作条件下的特殊优惠，那次是&quot;手把手，传帮带&quot;，很大程度上节省了技术和管理成本，本次外资引进需要支付昂贵的服务成本，即后来的第三产业，除此之外，上层建筑也需要作适配，即思想上从亲苏转变为亲西方。 这一切导致自74年财政赤字连年突破100亿元，而当年财政规模才800亿元左右。进而导致国家扩大再生产能力不足，第三次危机爆发。 74~76政府不得不以晚年毛泽东的威望动员数百万城市过剩劳动力到农村，即第三次知青下乡，实现&quot;软着陆&quot;。 第四次危机（79年~81年） 背景起因 70年代以来投资过度累积下来的财政赤字，加上78年以后政府采取的休养生息政策，福利和补贴增长过快，形成巨大的赤字压力。一方面加快投资来强化工业化建设，另一方面强调提高人民生活水平，两者都利于构建新政权的合法性。 危机常伴随着失业率的增加，失业人口不能像前三次那样往农村转移，造成社会治安环境的恶化。 后续演进 采取各种政策降低财政压力。具体如下， 1、全面推行农村基本经营制度改革（自己玩吧，政府退出），包产到户家庭承包制 2、乡镇企业和城镇化化为主要形式的农村资源，自我资本化。放松对农业产品和市场和要素时候的控制，刺激农民自主发展农业生产和非农业生产的积极性 3、压缩项目 第五次危机（88年~90年） 背景起因 产业资本的扩张带动投资大幅度增加，为基础的滞胀形态的经济危机。经济速度从87年的11.6%下降到89年的4.1%，90年进一步下降到3.8%，高通胀，18.5%物价指数。 究其原因， 一是&quot;短缺&quot;经济条件下的乡村工业化和经济快速增长带来的消费和投资需求旺盛，货币发行量过多，二是当时政府激进推行的相关改革措施，使大量隐含的制度成本被引爆。其中价格双轨制和88年推行的一系列市场化价格改革为关键原因 政府为甩掉价格双轨制的隐形制度成本而推出的激进的价格闯关，所引爆的，其实是两个被双轨制的内部化机制所掩盖的制度成本：一是部门与官倒公司结合而产生的设租、寻租成本，二是在暂时的商品短缺条件下获取投机暴利的市场化成本。 双轨制，改开初期，变计划经济为市场化经济中，提出一个双轨制，就是说保持原来的计划经济，另外创造一个计划外经济。企业生产了计划内的商品东西后，按规定的价格卖，完成指标后多余的东西即计划外的东西可以自由定价。这样导致企业不愿生产计划内商品，或者对于计划内商品倒买倒卖，囤货居奇，然后以市场价卖出，攫取超额利润。 后续演进 1、乡镇企业又一次成为转嫁对象，以&quot;沿海经济发展战略&quot;为名，要求乡镇企业&quot;两头在外&quot;，让出国内的原材料和产品市场 2、减少对地方政府和党政组织、教育和医疗等公共品的维持费用和乡村公共投入。导致农民在收入和消费连续下降，而地方政府和基层组织刚性开支造成农民大幅度增加。 最为历史性的后果为：这次城市利益取向的调控，人为压抑了处于上升期势头的农村经济和农民消费，导致内需不足，进而导致整个国民经济都不得不由此前的主要靠内需拉动增长，转而对外向性经济的依赖度越来越高，这个变化是中国进入90年代后为何迫不及待的纳入由国际金融资本主导的全球化进程中，这也为97年和08年两次输入性危机买下了伏笔 第六次危机（93年~94年） 背景起因 92~93因中央政府加快货币化和放开资本市场的同时，不得不全部承担经济过热造成的过高对外债务很快就爆发了财政、金融、外汇三大赤字 后续演进 1、城市工人大规模下岗。例如西安仅纺织系统下岗工人就有8940人，占职工总数的55%，其中70%无收入；张家口下岗工人达105000人，占全系统61.7% 2、社会公共服务部门市场化和私有化。 公共服务往往具有&quot;信息不对称&quot;的特征，而教育和医疗则具有信息绝对不对称，具有可以被个体垄断获取暴利的特征。教育经费历年比例：90年3.04%，92年2.73%，93年2.54%，96年2.46%，98年2.5%。卫生：90年2.79%，97年2.45% 3、地方基层政府将增加的治理成本转嫁到农村，社会矛盾严重。继84年，又甩了一次包袱。 4、金融资本恶化实体产业，恶化林业和环境灾难。即金融资本对资金周转慢，回收期长，经营风险大的环境资源行业天生排斥。 以林业为例，恶化表现为一方面我国需要大量进口木材及其它林产品，向其他国家支付&quot;林价&quot;，另一方面集体林区又出现大量的抛荒。90年代中期林改后，税费已达木材销售价格的51%以上。 5、土地资源资本化机制发生根本变化。 88年宪法修正案，90年《城镇国有土地使用权出让和转让暂行条例》改变了土地资源资本属性，让土地带有了商品属性——从80年代基层农村&quot;以地兴企&quot;改为90年代地方政府满足刚性开支的消费性的&quot;以地生财&quot; 应对措施， 1、外汇改革，&quot;一步并轨&quot;本币名义汇率一次性贬值57%，促进出口 2、信用扩张。国债和货币大规模增发。 3、分税制改革 第七次危机（97年东南亚危机） 背景起因 中国过度依赖出口，导致97年东亚金融危机，出口受挫，使得中国经济遭受重大影响 后续演进 1、金融改革，中央政府控制的金融资本顺势演化为独立地方实体产业的垄断资本。典型的如银行商业化改革和政府的分税制改革，这样一方面中央掌握的金融资本可以加入全球化资本竞争，另一方面地方政府资金获取能力弱化，随之而来的就是地方政府&quot;以地套现&quot;的第三次圈地运动 2、积极的财政政策——中央政府投资为主的基础设施建设。 例如1988年第一条高速公路沪嘉高速建成，真正的建设高潮是98年后，到03年政府换届时，中国高速通车历程已经位居世界第二，仅次于美国 3、&quot;政府进入&quot;成为中国应对输入性危机的基本经验 例如，99年提出西部大开发，01年提出东北老工业基地振兴战略，03年提出中部崛起战略，05年又提出&quot;建设社会主义新农村&quot;，尤为值得注意的是这些战略并没有因为政府换届而改变，反而从98年持续了12年，总规模在10万亿以上，加上省级以下政府投资，各级政府总计增加了20万亿投资。这一点实为难得，要知道别说一个国家，一个公司的政策在换届后都很难延续。 第八次危机（08年美国次贷危机） 背景起因 危机前的宏观环境 1、中国经济进一步融入美国主导的世界经济大循环 外需依赖达到66%（进口+出口/国内生产总值） 2、国内经济结构性矛盾——&quot;三大过剩&quot;与&quot;三驾马车&quot;失衡加剧 “三大过剩”：劳动力过剩、一般制造业产能过剩、金融资本过剩 “三驾马车”：投资（高）、消费（低）、出口（高） 3、公司化的地方政府&quot;以地套现&quot;：城市化主导的&quot;高投资+高负债=高增长&quot;发展模式逐渐形成 后续演进 内需：积极的财政投资带动内需增长。08年危机中央新增加1200亿元资金中，大部分用于民生，涉农投资超过1/3，仅有250亿用于基建，这和97年不同。 外需：在稳定汇率的条件下，提高出口退税率 与97年那次不同，早在3年前即05年中央就成规模的加大包括新农村建设在内的国债投资，虽然当时的初衷并不是应对危机，但客观上发挥着依靠县域经济打造&quot;第二资产池&quot;的作用。","categories":[],"tags":[{"name":"近代史","slug":"近代史","permalink":"https://naosense.github.io/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"},{"name":"温铁军","slug":"温铁军","permalink":"https://naosense.github.io/tags/%E6%B8%A9%E9%93%81%E5%86%9B/"},{"name":"八次危机","slug":"八次危机","permalink":"https://naosense.github.io/tags/%E5%85%AB%E6%AC%A1%E5%8D%B1%E6%9C%BA/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"好一个红楼一梦","slug":"好一个红楼一梦","date":"2021-11-30T18:19:08.000Z","updated":"2025-09-16T02:08:42.968Z","comments":true,"path":"2021/11/30/好一个红楼一梦/","link":"","permalink":"https://naosense.github.io/2021/11/30/%E5%A5%BD%E4%B8%80%E4%B8%AA%E7%BA%A2%E6%A5%BC%E4%B8%80%E6%A2%A6/","excerpt":"","text":"余少时尝闻红楼梦石头记云云，以为所载皆不过儿女情长之事，不屑之。及过而立之年，偶又拾得，读罢方知曹公满纸荒唐言，一把辛酸泪之所谓也，盖盛衰有时，人生无常矣。忆往昔，三十余年蹉跎岁月，庸庸碌碌，浑浑噩噩，犹犹豫豫，后知后觉，方知宝玉敢爱敢恨，至真至善，看得破，想得通之难能可贵矣 ——听喜马拉雅吉劭居读红楼梦毕，有感而发","categories":[],"tags":[{"name":"红楼梦","slug":"红楼梦","permalink":"https://naosense.github.io/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"},{"name":"读后感","slug":"读后感","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"小说时间线整理工具w4","slug":"小说时间线整理工具w4","date":"2021-07-24T13:37:39.000Z","updated":"2025-09-16T02:08:42.969Z","comments":true,"path":"2021/07/24/小说时间线整理工具w4/","link":"","permalink":"https://naosense.github.io/2021/07/24/%E5%B0%8F%E8%AF%B4%E6%97%B6%E9%97%B4%E7%BA%BF%E6%95%B4%E7%90%86%E5%B7%A5%E5%85%B7w4/","excerpt":"","text":"本人是一名小说爱好者，看多了，有时候免不了要理一下时间线，更好的理解故事梗概。之前用过思维导图整理，但是总觉得思维导图“有点重”，在作图的过程中，会陷入“到底是选择方框还是圆框”、“到底是虚线还是实线”这样的纠结中，导致最后做出来的图形式大于内容，搞得自己是精疲力尽。也曾在本子上整理，但是不便于检索和保存。其实想要的很简单：可以大致下查看事件发生的先后顺序和联系，具有一定的筛查功能就够了。 在这样的背景下，有了这款vim插件，之所以选择vim是因为自己平常用的较多，写博客、纯文本编辑一般都用它。插件名字w4，灵感来源小说三要素：地点、人物、事件，翻译成英文就是where、who、what，再加一个时间when。 大概支持以下功能： 纯文本 自动补全 设置关联 类SQL筛查 人物关系图 使用方式 安装完成后，在vim输入:W4Go命令打开浏览窗口，按enter打开输入窗口。 文本样式 文本以%% who what when where开头，如下所示： %% who what when where #0724073055 @阿Q 赵太爷儿子中秀才的时，喝了三碗酒，吹嘘和赵太爷是本家，并且比他儿子长三辈 - 未庄 #0724073430 @赵太爷 对于阿Q的强攀亲戚，说出了那句著名的话：你怎么会姓赵！你哪里配姓赵 第二天 自己家 #0724073055 #0724073803 @阿Q 头上长了癞疮疤 - - #0724074006 @未庄人 取笑阿Q：亮起来了 - - #0724073803 #0724074205 @阿Q 每次形式上被打败总能在心理上取胜：这个世界不像样，我被儿子打了 - - #0724074006 分别代表人物、事件、时间、地点，人名以@开头。可以看成一个4列的数据库表，列的顺序可以调整，如果当前列为空用-代替。列以空格分割，如果不愿意用空格也可以在文件头自己指定。例如可以在文件头加上下面的指令指定以斜杠（/）为分隔符。 %% col_split_char=/ 可以看到，示例文本是多于四列的，因为第一列相当于id，唯一标识一行，最后一列是关联列，用于建立各行之间的联系。 自动补全 输入@符号自动提示所有的人名 输入#提示之前的条目，在输入过程中可以使用Tab触发补全，可以只输入少量字符按Tab自动补全，比如示例文本最后一行可以输入#006就会自动提示。 类SQL筛查 支持： 特殊命令：以/开头，目前只有两个，/all显示所有的条目，/who显示人物关系图 逻辑表达式：与（&amp;）、或（|）、非（!）、等于（=，模糊匹配）、不等于（!=） 比如和阿Q相关的事： who=阿Q 人物或事件包含小尼姑： who=小尼姑 | what=小尼姑 未庄发生的事： where=未庄 春天发生的事： when=春天 人物关系图 输入/who命令","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://naosense.github.io/tags/javascript/"},{"name":"vim","slug":"vim","permalink":"https://naosense.github.io/tags/vim/"},{"name":"python","slug":"python","permalink":"https://naosense.github.io/tags/python/"},{"name":"时间线","slug":"时间线","permalink":"https://naosense.github.io/tags/%E6%97%B6%E9%97%B4%E7%BA%BF/"}]},{"title":"威尔逊版《毛泽东传》读后感","slug":"威尔逊版《毛泽东传》读后感","date":"2021-07-09T19:47:30.000Z","updated":"2025-09-16T02:08:42.968Z","comments":true,"path":"2021/07/09/威尔逊版《毛泽东传》读后感/","link":"","permalink":"https://naosense.github.io/2021/07/09/%E5%A8%81%E5%B0%94%E9%80%8A%E7%89%88%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E4%BC%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"花了两天通读完一遍，总体而言，在大体遵循史实的基础上，作者往往在后面加上一段阴阳怪气的主观评论，作者也谙熟“九真一假”的威力。 即便这样，读完这本外国人写的毛传记，我也能感受到，毛从未脱离群众，尽管他也有过头脑发热，判断失误的时候，但是他自始至终是为群众讲话的，并且时时刻刻在提醒他的同僚不要忘了群众。同时作者引用的对毛的批评和评价也多出自这一点，比如毛穿着不修边幅，行为举止不够优雅，学历不高，不会外语，走路言谈像个农民等等，充满着小资的自以为是和高高在上，哈哈。 中后期毛确实是孤独的，他的同僚们以为进城了，革命胜利了，该论功行赏了，而毛告诫他们广大群众真正过上好日子还有现代化工业化在等着我们，同志们仍需努力。兄弟们不这么想，老子革了半辈子命了，也该歇歇脚了。也许兄弟们对他这些不厌其烦的规劝听腻了，听烦了，渐渐的他被孤立了，所以他只能依靠一些并不可靠盟友奋起一击。文哥中许多事无疑是混乱和错误的，但是初衷是为了打击官僚主义，但是就像那句老话讲的，你可以选择开球的时间，什么时候结束你却决定不了，有些事超出他的掌控了，最后他倒下了，跌的粉身碎骨。跌了个三七开，跌了个功过相抵。 许多年后，群众才将这些魔晶碎片慢慢的拼接起来，完成的那一刻，大家惊奇的发现他还保持着战斗的姿势，只不过他的利剑是刺向自己的，利剑上面刻的是：人民万岁。","categories":[],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://naosense.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"毛泽东","slug":"毛泽东","permalink":"https://naosense.github.io/tags/%E6%AF%9B%E6%B3%BD%E4%B8%9C/"}]},{"title":"毛泽东如何看待鲁迅","slug":"毛泽东如何看待鲁迅","date":"2021-04-17T13:50:27.000Z","updated":"2025-09-16T02:08:42.978Z","comments":true,"path":"2021/04/17/毛泽东如何看待鲁迅/","link":"","permalink":"https://naosense.github.io/2021/04/17/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E9%B2%81%E8%BF%85/","excerpt":"","text":"坊间一直有个传闻，文革期间一次聊天中有人问毛泽东：要是今天鲁迅还活着，他可能会怎样？毛泽东回答：要么是关在牢里还是要写，要么他识大体不做声。我最早听说这件事是大学时期一个舍友说起的，当时听了既不关心也不在意。工作多年后对教员和社会有了更深的了解后又想起此事，想说点自己的想法。但凡对毛泽东有一点了解后就会发现，除了马克思列宁，没有一个人像鲁迅那样被毛泽东一次又一次的提到，赞美的无以复加，这种赞誉不是只在某一个特定时间段，而是一直到毛泽东去世前的几个月。毛泽东曾经用五个“最”称赞鲁迅，他引用鲁迅说过的话，写过的文章，做过的事，用现在的话说简直就是鲁迅的迷弟。关于此事，已经有人进行了考证（链接），是真是假相信每个人看了都有自己的判断。那么作为第一手的证据，毛泽东的作品中是如何评价鲁迅的呢，下面列举毛选中所有和鲁迅相关的片段，最早为1940年的《新民主主义论》，最晚为1976年去世前几个月的《走资派还在走，“永不翻案”靠不住》。 《新民主主义论&gt;： ……而鲁迅，就是这个文化新军的最伟大和最英勇的旗手。鲁迅是中国文化革命的主将，他不但是伟大的文学家，而且是伟大的思想家和伟大的革命家。鲁迅的骨头是最硬的，他没有丝毫的奴颜和媚骨，这是殖民地半殖民地人民最可宝贵的性格。鲁迅是在文化战线上，代表全民族的大多数，向着敌人冲锋陷阵的最正确、最勇敢、最坚决、最忠实、最热忱的空前的民族英雄。鲁迅的方向，就是中华民族新文化的方向…… ……作为军事“围剿”的结果的东西，是红军的北上抗日；作为文化“围剿”的结果的东西，是一九三五年“一二九”青年革命运动的爆发。而作为这两种“围剿”之共同结果的东西，则是全国人民的觉悟。这三者都是积极的结果。其中最奇怪的，是共产党在国民党统治区域内的一切文化机关中处于毫无抵抗力的地位，为什么文化“围剿”也一败涂地了？这还不可以深长思之吗？而共产主义者的鲁迅，却正在这一“围剿”中成了中国文化革命的伟人…… 《反对党八股》： ……党八股也就是一种洋八股。这洋八股，鲁迅早就反对过的⑷。我们为什么又叫它做党八股呢？这是因为它除了洋气之外，还有一点土气。也算一个创作吧！谁说我们的人一点创作也没有呢？这就是一个！（大笑）…… ……党八股的第二条罪状是：装腔作势，借以吓人。有些党八股，不只是空话连篇，而且装样子故意吓人，这里面包含着很坏的毒素。空话连篇，言之无物，还可以说是幼稚；装腔作势，借以吓人，则不但是幼稚，简直是无赖了。鲁迅曾经批评过这种人，他说：“辱骂和恐吓决不是战斗。”…… ……第三篇，是从《鲁迅全集》里选出的，是鲁迅复北斗杂志⑿社讨论怎样写文章的一封信。他说些什么呢？他一共列举了八条写文章的规则，我现在抽出几条来说一说。 第一条：“留心各样的事情，多看看，不看到一点就写。” 讲的是“留心各样的事情”，不是一样半样的事情。讲的是“多看看”，不是只看一眼半眼。我们怎么样？不是恰恰和他相反，只看到一点就写吗？ 第二条：“写不出的时候不硬写。” 我们怎么样？不是明明脑子里没有什么东西硬要大写特写吗？不调查，不研究，提起笔来“硬写”，这就是不负责任的态度。 第四条：“写完后至少看两遍，竭力将可有可无的字、句、段删去，毫不可惜。宁可将可作小说的材料缩成速写，决不将速写材料拉成小说。” 孔夫子提倡“再思”⒀，韩愈也说“行成于思”⒁，那是古代的事情。现在的事情，问题很复杂，有些事情甚至想三四回还不够。鲁迅说“至少看两遍”，至多呢？他没有说，我看重要的文章不妨看它十多遍，认真地加以删改，然后发表。文章是客观事物的反映，而事物是曲折复杂的，必须反复研究，才能反映恰当；在这里粗心大意，就是不懂得做文章的起码知识。 第六条：“不生造除自己之外，谁也不懂的形容词之类。” 我们“生造”的东西太多了，总之是“谁也不懂”。句法有长到四五十个字一句的，其中堆满了“谁也不懂的形容词之类”。许多口口声声拥护鲁迅的人们，却正是违背鲁迅的啊！…… 《在延安文艺座谈会上的讲话》： ……诚然，为着剥削者压迫者的文艺是有的。文艺是为地主阶级的，这是封建主义的文艺。中国封建时代统治阶级的文学艺术，就是这种东西。直到今天，这种文艺在中国还有颇大的势力。文艺是为资产阶级的，这是资产阶级的文艺。像鲁迅所批评的梁实秋⑶一类人，他们虽然在口头上提出什么文艺是超阶级的，但是他们在实际上是主张资产阶级的文艺，反对无产阶级的文艺的…… ……鲁迅曾说：“联合战线是以有共同目的为必要条件的。……我们战线不能统一，就证明我们的目的不能一致，或者只为了小团体，或者还其实只为了个人。如果目的都在工农大众，那当然战线也就统一了…… ……中国的革命的文学家艺术家，有出息的文学家艺术家，必须到群众中去，必须长期地无条件地全心全意地到工农兵群众中去，到火热的斗争中去，到唯一的最广大最丰富的源泉中去，观察、体验、研究、分析一切人，一切阶级，一切群众，一切生动的生活形式和斗争形式，一切文学和艺术的原始材料，然后才有可能进入创作过程。否则你的劳动就没有对象，你就只能做鲁迅在他的遗嘱里所谆谆嘱咐他的儿子万不可做的那种空头文学家，或空头艺术家…… ……“还是杂文时代，还要鲁迅笔法。”鲁迅处在黑暗势力统治下面，没有言论自由，所以用冷嘲热讽的杂文形式作战，鲁迅是完全正确的。我们也需要尖锐地嘲笑法西斯主义、中国的反动派和一切危害人民的事物，但在给革命文艺家以充分民主自由、仅仅不给反革命分子以民主自由的陕甘宁边区和敌后的各抗日根据地，杂文形式就不应该简单地和鲁迅的一样。我们可以大声疾呼，而不要隐晦曲折，使人民大众不易看懂。如果不是对于人民的敌人，而是对于人民自己，那末，“杂文时代”的鲁迅，也不曾嘲笑和攻击革命人民和革命政党，杂文的写法也和对于敌人的完全两样。对于人民的缺点是需要批评的，我们在前面已经说过了，但必须是真正站在人民的立场上，用保护人民、教育人民的满腔热情来说话…… ……既然必须和新的群众的时代相结合，就必须彻底解决个人和群众的关系问题。鲁迅的两句诗，“横眉冷对千夫指，俯首甘为孺子牛”⒁，应该成为我们的座右铭。“千夫”在这里就是说敌人，对于无论什么凶恶的敌人我们决不屈服。“孺子”在这里就是说无产阶级和人民大众。一切共产党员，一切革命家，一切革命的文艺工作者，都应该学鲁迅的榜样，做无产阶级和人民大众的“牛”，鞠躬尽瘁，死而后已。知识分子要和群众结合，要为群众服务，需要一个互相认识的过程。这个过程可能而且一定会发生许多痛苦，许多磨擦，但是只要大家有决心，这些要求是能够达到的…… 《论十大关系》： ……《阿Q正传》是一篇好小说，我劝看过的同志再看一遍，没看过的同志好好地看看。 鲁迅在这篇小说里面， 主要是写一个落后的不觉悟的农民。他专门写了“不准革命”一章，说假洋鬼子不准阿Q革命。其实，阿Q当时的所谓革命，不过是想跟别人一样拿点东西而已。可是，这样的革命假洋鬼子也还是不准。我看在这点上，有些人很有点像假洋鬼子。他们不准犯错误的人革命，不分犯错误和反革命的界限，甚至把一些犯错误的人杀掉了。我们要记住这个教训。无论在社会上不准人家革命，还是在党内不准犯错误的同志改正错误，都是不好的…… 《在中国共产党全国宣传工作会议上的讲话》: ……有人说，几百字、一二千字一篇的杂文，怎么能作分析呢？我说，怎么不能呢？鲁迅不就是这样的吗？分析的方法就是辩证的方法…… 《工作方法六十条（草案）》: ……〔二十六〕以真正平等的态度对待干部和群众。必须使人感到人们互相间的关系确实是平等的，使人感到你的心是交给他的。学习鲁迅。鲁迅的思想是和他的读者交流的，是和他的读者共鸣的…… 《在七千人大会上的讲话-关于党的民主集中制》: ……世界革命总是要胜利的。不准革命，像鲁迅所写的赵太爷、钱太爷、假洋鬼子不准阿Ｑ革命那样，总是要失败的…… 《部队文艺工作座谈会纪要》: ……三十年代也有好的，那就是以鲁迅为首的战斗的左翼文艺运动。到了三十年代的中期，那时左翼的某些领导人在王明的右倾投降主义路线的影响下，背离马克思列宁主义的阶级观点，提出了“国防文学”〔6〕的口号。这个口号，就是资产阶级的口号，而“民族革命战争的大众文学”这个无产阶级的口号，却是鲁迅提出的。有些左翼文艺工作者，特别是鲁迅，也提出了文艺要为工农服务和工农自己创作文艺的口号，但是并没有系统地解决文艺同工农兵相结合这个根本问题…… ……〔6〕“国防文学”和“民族革命战争的大众文学”的口号之争，指一九三六年上海左翼文学界关于国防文学和民族革命战争的大众文学这两个口号的论争。这两个口号都是因日寇扩大对华侵略和国内阶级关系的新变化，为适应党中央关于建立抗日民族统一战线的策略要求而提出的。国防文学口号先由上海文学界地下党领导周扬提出，并由此开展了国防文学运动和国防戏剧、国防诗歌活动。民族革命战争的大众文学口号由党中央特派员冯雪峰到上海和鲁迅、胡风等商量后由胡风撰文提出的。受到主张国防文学的一些作家的指责而发生论争。鲁迅撰文提出两个口号可以&quot;并存&quot;，批评了主张国防文学的一些左翼领导人的关门主义、宗派派主义错误。这是左翼文学界在新形势下围绕建立文艺界统一战线由于某些思想分歧而发生的论争。 鲁迅认为，“民族革命战争的大众文学”这个口号，在本身上，比“国防文学”的提法，意义更明确，更深刻，更有内容。在《论现在我们的文学运动》中，鲁迅进一步强调说：“民族革命战争的大众文学，正如无产革命文学的口号一样，大概是一个总的口号罢。在总口号之下，再提些随时应变的具体的口号，例如“国防文学”“救亡文学”“抗日文艺”……等等，我以为是无碍的。不但没有碍，并且是有益的，需要的。自然，太多了也使人头昏，浑乱。”并苦口婆心地跟徐懋庸那帮人作了解释：“中国的唯一的出路，是全国一致对日的民族革命战争。懂得这一点，则作家观察生活，处理材料，就如理丝有绪；作者可以自由地去写工人，农民，学生，强盗，娼妓，穷人，阔佬，什么材料都可以，写出来都可以成为民族革命战争的大众文学。也无需在作品的后面有意地插一条民族革命战争的尾巴，翘起来当作旗子……。” 在这里，鲁迅正确地说明了“民族革命战争的大众文学”与无产阶级革命文学的关系，而且针对左翼文学队伍中有的人忽视、放弃无产阶级领导权的错误，特别强调了统一战线中无产阶级领导权的重要意义。鲁迅同时认为，“国防文学”是“目前文学运动的具体口号之一”，这个口号“颇通俗，已经有很多人听惯，它能扩大我们政治的和文学的影响，加之它可以解释为作家在国防旗帜下联合，为广义的爱国主义的文学的缘故”，因此，“它即使曾被不正确的解释，它本身含义上的缺陷，它仍应当存在，因为存在对于抗日运动有利益。”…… 《给江青的信》： ……在重大问题上，违心地同意别人，在我一生还是第一次。叫做不以人的意志为转移吧。晋朝人阮籍反对刘帮，他从洛阳走到成皋，叹到：世无英雄，遂使竖子成名。鲁迅也曾对于他的杂文说过同样的话，我跟鲁迅的心是相通的。我喜欢他那样坦率。他说，解剖自己，往往严于解剖别人。在跌了几跤之后，我亦往往如此。可是同志们往往不信，我是自信而又有些不自信…… 《关于《水浒》的评论》： ……鲁迅评《水浒》评得好，他说：“一部《水浒》，说得很分明：因为不反对天子，所以大军一到，便受招安，替国家打别的强盗——不‘替天行道’的强盗去了。终于是奴才。”〔《三闲集·流氓的变迁》〕 金圣叹把《水浒》砍掉了二十多回。砍掉了，不真实。 鲁迅非常不满意金圣叹，专写了一篇评论金圣叹的文章《谈金圣叹》〔见《南腔北调集》〕。 《水浒》百回本、百二十回本和七十一回本，三种都要出。把鲁迅的那段评语印在前面…… 《走资派还在走，“永不翻案”靠不住》： ……我建议一二年内读点哲学，读点鲁迅。读哲学，可以看杨荣国〔15〕的《中国古代思想史》和《简明中国哲学史》…… 传言中识大体不作声必定不是鲁迅，不让别人讲话的也必定不是毛泽东。事实上，如果鲁迅能活到建国后，与其说鲁迅因反对文革入狱，不如说他更有可能成为毛泽东为数不多的盟友和导师，因为毛和鲁都是真正的革命者，而真正的革命者必定是一支枪指着敌人，一支枪时刻对准自己，诚如毛在《给江青的信》中所说“我跟鲁迅的心是相通的”。","categories":[],"tags":[{"name":"毛泽东","slug":"毛泽东","permalink":"https://naosense.github.io/tags/%E6%AF%9B%E6%B3%BD%E4%B8%9C/"},{"name":"鲁迅","slug":"鲁迅","permalink":"https://naosense.github.io/tags/%E9%B2%81%E8%BF%85/"}]},{"title":"Loom项目的进展：第二部分（State of Loom）","slug":"Loom项目的进展：第二部分（State-of-Loom）","date":"2020-10-31T12:11:39.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2020/10/31/Loom项目的进展：第二部分（State-of-Loom）/","link":"","permalink":"https://naosense.github.io/2020/10/31/Loom%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9B%E5%B1%95%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%C2%86%EF%BC%88State-of-Loom%EF%BC%89/","excerpt":"","text":"第一部分介绍了虚拟线程并解释了JDK如何适配的去使用它们。随着线程的数量越来越多，生命周期越来越短，管理它们和在它们之间分配工作的新方法属于 Project Loom 的范畴: 在线程之间传递数据的新的灵活机制(比如通道)可能是可取的; 聚集大量线程可以受益于一种被称为**结构化并发(structured concurrency)的组织和监督方法; 最后，我们正在探索一种比线程局部变量更方便、更有效的构造，用于我们暂时称为作用域变量(scope variables)**的上下文数据。 和往常一样，如果您能向Loom开发人员邮件列表反馈使用Loom的体验，我们将非常感激。 通道 当涉及到线程计算的单个结果的交流时，java.util.concurrent.Future就足够了，同时CompletableFuture类架起了同步世界和异步世界的桥梁：使用thenXXX进行异步操作，使用get进行同步操作。当涉及到多个结果的交流时，Flow类为异步代码提供了一个很好的解决方案。在设计出更多的同步解决方案之前，BlockingQueue可用于在线程之间通信多个值(特别是 LinkedTransferQueue)。 在一个原型中，通道类型被称为 Carrier，以区别于 NIO 通道。尽管可能会发生变化，但目前看起来是这样的: Carrier&lt;String&gt; carrier = new Carrier&lt;&gt;(); Thread producer = Thread.startVirtualThread(() -&gt; &#123; Carrier.Sink&lt;String&gt; sink = carrier.sink(); sink.send(&quot;message1&quot;); sink.send(&quot;message2&quot;); sink.closeExceptionally(new InternalError()); &#125;); Thread consumer = Thread.startVirtualThread(() -&gt; &#123; try (Carrier.Source&lt;String&gt; source = carrier.source()) &#123; while (true) &#123; String message = source.receive(); System.out.println(message); &#125; &#125; catch (IllegalStateException e) &#123; System.out.println(&quot;consumer: &quot; + e + &quot; cause: &quot; + e.getCause()); &#125; &#125;); producer.join(); consumer.join(); 结构化并发 由于线程代价低廉且数量众多，它们可以从聚集线程的标准实践中获益。我们发现了一个特别吸引人的方法: 结构化并发。 结构化并发将线程生命周期分解为代码块。类似于结构化编程控制将顺序执行的控制流限制在一个定义良好的代码块中，结构化的并发性对并发控制流也是如此。它的基本原则是: 在某个代码单元中创建的线程必须在我们退出该代码单元时全部终止; 如果执行分裂为某个范围内的多个线程，它必须在退出该范围之前合并。特别是，方法在生成可以无限期存活的线程后不应返回。 为了让这个想法更清楚，让我们看一些代码。在我们当前的原型中，我们使用限制子线程生命周期的代码块代表一个结构化并发范围，通过将java.util.concurrent.ExecutorService成为一个AutoCloseable，close方法用来关闭服务等待终止。这保证了在我们退出try with resources（TWR）块时，提交给executor的所有任务都将终止，并将它们的生命周期限制在代码结构中： ThreadFactory vtf = Thread.builder().virtual().factory(); try (ExecutorService e = Executors.newUnboundedExecutor(vtf)) &#123; e.submit(task1); e.submit(task2); &#125; // blocks and waits 在我们退出TWR块之前，当前线程将阻塞，等待所有任务及其线程完成。一旦离开它，我们就可以保证任务已经结束。 因此，我们直接将代码表示成某些过程计算的非常有组织的形式。如果;是顺序组合，|是并行组合，那么我们的代码可以这样描述：a;(b|((c|d);e));f，其中连接点（我们等待子线程完成）是并行操作之后和下一个顺序操作之前的右括号，如**(x|y|z);w**。 除了清晰之外，该结构还具有强大的不变性：每个线程（在结构化并发上下文中）都有一些“父”线程，该线程被阻塞以等待其终止，因此应当关心何时（或者如何）执行。它在错误传播和消除方面具有一些强大的优势。 结构化中断 非结构化线程脱离了任何上下文或明确的责任。由于结构化线程显然为其父级执行某些工作，因此当取消父级时，也应取消子级。 因此，如果父线程被中断，我们将中断传播给它的子线程。我们还可以给所有任务一个截止期限，在任务到期时中断那些尚未终止的子任务（以及当前线程）： try (var e = Executors.newUnboundedExecutor(myThreadFactory) .withDeadline(Instant.now().plusSeconds(30))) &#123; e.submit(task1); e.submit(task2); &#125; 结构化错误 非结构化线程可能会遇到异常，并且会在没有任何注意的情况下单独死亡。结构化线程的故障将由其监视的父级观察到，然后可以将故障置于上下文中，例如，通过将子异常的堆栈跟踪与其父级的堆栈跟踪缝合在一起。 但是错误传播带来了一些挑战。假设一个子线程抛出的异常会自动传播到其父节点，结果，该异常将随后取消（中断）父线程的所有其他子线程。在某些情况下，这可能是理想的选择，但是是否应该是默认行为尚不清楚。因此，目前，我们正在尝试更明确的错误和结果处理。 我们可以使用新的ExecutorService.submitTasks和CompletableFuture.stream，它将每个任务完成时的结果流化，不管成功与否(也充当到CompletableFuture的异步世界的桥梁)，以等待第一个任务成功完成，然后取消所有其他任务： try (var e = Executors.newUnboundedVirtualThreadExecutor()) &#123; List&lt;CompletableFuture&lt;String&gt;&gt; tasks = e.submitTasks(List.of( () -&gt; &quot;a&quot;, () -&gt; &#123; throw new IOException(&quot;too lazy for work&quot;); &#125;, () -&gt; &quot;b&quot;, )); try &#123; String first = CompletableFuture.stream(tasks) .filter(Predicate.not(CompletableFuture::isCompletedExceptionally)) .map(CompletableFuture::join) .findFirst() .orElse(null); System.out.println(&quot;one result: &quot; + first); &#125; catch (ExecutionException ee) &#123; System.out.println(&quot;¯\\\\_(ツ)_/¯&quot;); &#125; finally &#123; tasks.forEach(cf -&gt; cf.cancel(true)); &#125; &#125; 一些常见模式可以由helper方法提供服务，比如ExecutorService的invokeAll或invokeAny。此示例与上面更详细的示例执行相同的操作： try (var e = Executors.newUnboundedVirtualThreadExecutor()) &#123; String first = e.invokeAny(List.of( () -&gt; &quot;a&quot;, () -&gt; &#123; throw new IOException(&quot;too lazy for work&quot;); &#125;, () -&gt; &quot;b&quot; )); System.out.println(&quot;one result: &quot; + first); &#125; catch (ExecutionException ee) &#123; System.out.println(&quot;¯\\\\_(ツ)_/¯&quot;); &#125; 这些API位于EA中，但是随着我们试图使线程管理更加友好，该领域可能会有很多变化。 结构化服务性和可观测性 结构化并发不仅有助于组织代码，还有助于在进行概要分析和调试时提供有意义的上下文。一百万个线程的线程dump可能没有用，但是如果可以将这些线程显示在根据结构化并发作用域层次结构排列的树中，则可以更好地理解它们。同样，JFR可以按SC作用域对线程及其执行的操作进行分组，从而可以放大或缩小配置文件。这项工作不太可能进入第一个预览版。 作用域变量 有时我们需要以对中间框架透明的方式将某些上下文从调用者传递到被调用者。例如，一个调用链foo→bar→baz，foo和baz是应用代码，bar是程序库代码，或者反过来，foo希望在没有bar参与的情况下与baz共享数据。目前，这通常是通过线程局部变量ThreadLocal来完成的，但是TLs(我们将简称为TLs)有严重的缺点。 一方面，它们的结构与我们上面使用的含义类似：一旦设置了TL值，该值在线程的整个生命周期内有效，或者直到将其设置为其他值为止。实际上，我们通常会看到一种使用模式，试图借用TL结构（不幸的是，没有任何性能优势）： var oldValue = myTL.get(); myTL.set(newValue); try &#123; ... &#125; finally &#123; myTL.set(oldValue); &#125; 如果没有这种强制性的结构，当在多个任务之间共享线程时，一个任务的TL值可能会泄漏到另一个任务中。虚拟线程通过足够轻量级而无需共享来解决该问题。但是，这种非结构化的特性还意味着TL实现必须依靠弱引用来允许GC清理不再使用的TL，这会使它们的实现速度大大降低。 另一个问题是继承。例如，那些使用像OpenTracing这样的分布式跟踪工具的人，可能想要从父线程继承跟踪“ span”。这可以通过InheritableThreadLocal(iTL)实现。创建线程时必须复制线程中的iTL映射，因为iTL是可变的，因此无法共享。这既造成了占用空间又造成了速度上的损失。另外，由于当今的线程是非结构化的，因此当子线程访问其继承的span时，其父级可能已将其关闭。虚拟线程只会加剧iTL继承的问题，因为它们鼓励创建许多小线程，其中一些代表其父线程执行一些小任务，例如单个HTTP请求，从而增加了对iTL继承的需求以及复杂的占用空间和速度成本。 如果一次设置后TL不可变，则继承可以提高效率，但可以考虑设置TL的方法。现在，它将根据其调用方是否设置了相同的TL引发非法状态异常，从而严重损害代码的可组合性。 为了解决这些问题，我们正在探索一种在性能、占用空间、结构和正确性方面更好的替代方法，我们尝试性地调用范围变量。与TLs一样，SVs引入了一些隐式上下文，但与TLs不同，它们是针对代码块的span而构造的，而不是针对线程的整个生命周期。SV也是不可变的，尽管它们的值可以被嵌套的作用域遮蔽。 这是使用当前EA原型中的java.lang.Scoped API的示例： static final Scoped&lt;String&gt; sv = Scoped.forType(String.class); void foo() &#123; try (var __ = sv.bind(&quot;A&quot;)) &#123; bar(); baz(); bar(); &#125; &#125; void bar() &#123; System.out.println(sv.get()); &#125; void baz() &#123; try (var __ = sv.bind(&quot;B&quot;)) &#123; bar(); &#125; &#125; baz不会更改sv的绑定，而是在嵌套作用域中引入了新的绑定，从而隐藏了其封闭的绑定。因此foo将输出： A B A 因为SV绑定的生命周期是明确定义的，所以我们不需要依赖GC进行清理，因此我们不需要弱引用来减慢我们的速度。 那继承呢？由于SV是不可变的，并且结构化并发还为我们提供了语法限制的线程生命周期，因此SV继承就像手套一样适合结构化并发： try (var context = Foo.openContext()) &#123; // some temporary context that can be closed try (var __ = contextSV.bind(context); var executor = Executors.newUnboundedExecutor(myThreadFactory)) &#123; executor.submit(() -&gt; &#123; ... &#125;); executor.submit(() -&gt; &#123; ... &#125;); &#125; &#125; 提交的任务会自动继承contextSV的上下文值，并且由于UnboundedExecutor范围被上下文的生命周期范围所包围，因此可以确定任务从contextSV获得的上下文尚未关闭。 其他类型的结构化构造（即其计算仅限于语法元素的构造）也可以提供自动SV继承。例如： try (var __ = sv.bind(value)) &#123; Set.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).stream().parallel() .forEach(s -&gt; System.out.println(s + &quot;: &quot; + sv.get())); &#125; 由于流的forEach操作也完全受限于SV的绑定范围，即使forEach可能在不同线程中的不同流元素上执行其主体，值也可以继承。 范围变量仍处于设计阶段的早期，并且与我们可能会引入try-with-resources的更一般的更改相关联（请参阅此处以了解一些想法）。即使我们决定使用SV，它们也可能会错过第一个Preview和GA。 处理器本地变量 线程本地变量的另一种用法不是将数据与线程上下文关联，而是“标记”一些写量大、易变的数据结构，以避免争用(例如LongAdder，它不使用ThreadLocal类，但依赖于类似的思想)。当线程数不比内核数大很多时，这是有道理的，但是可能有数百万个线程，这纯粹是开销。我们正在探索一种具有类似CAS语义的“处理器本地”结构，如果具有适当的OS支持（例如Linux的可重启序列），它比无竞争的CAS还要快。 有关中断和取消的更多信息 线程支持一种协作中断机制，该机制由方法interrupt，interrupted，isInterrupted和InterruptedException组成。这是一种相当复杂的机制：某些线程在另一个线程上调用中断，从而设置目标线程的中断状态。目标线程轮询其中断状态，可能会从阻塞方法中抛出InterruptedException，但也会清除该状态，这有两个原因。首先，线程可能是池中的共享资源。当前任务可以被中断，但是调度程序可能想要重用线程来运行其他任务，因此必须重置中断状态。对于虚拟线程，这是不必要的，因为它们足够轻巧，不会被重复用于其他任务。但是还有另一个原因：线程可能会观察到它已被中断，并且在清理过程中可能希望调用阻塞方法。如果状态未清除，则阻塞方法将立即引发InterruptedException。尽管此机制确实可以满足实际需求，但它容易出错，因此我们希望对其进行重新讨论。我们已经试验了一些原型，但是目前还没有任何具体方案。 强制抢占 尽管已经有了关于调度的说法，但在某些特殊情况下，强行抢占占用CPU的线程可能会很有用。例如，代表多个客户端应用程序执行复杂数据查询的批处理服务可以接收客户端任务，并在各自的虚拟线程中运行它们。如果此类任务占用过多的CPU，则该服务可能要强行抢占它，并在该服务负载较轻时再次安排它。为此，我们计划让VM支持尝试在任何安全点强制抢占执行的操作。该功能如何向调度程序公开是待定的，并且可能不会出现在第一个预览版中。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"loom","slug":"loom","permalink":"https://naosense.github.io/tags/loom/"}]},{"title":"Loom项目的进展：第一部分（State of Loom）","slug":"Loom项目的进展：第一部分（State of Loom）","date":"2020-10-11T13:27:24.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2020/10/11/Loom项目的进展：第一部分（State of Loom）/","link":"","permalink":"https://naosense.github.io/2020/10/11/Loom%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9B%E5%B1%95%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%88State%20of%20Loom%EF%BC%89/","excerpt":"","text":"本文是State of Loom的翻译。 Loom 项目旨在大大减少编写、维护和观察高吞吐量并发应用程序的工作量，从而最大限度地利用可用硬件。 Loom项目的工作于2017年开始。本文档解释了项目的动机和所采取的方法，并总结了我们迄今为止的工作。像所有OpenJDK项目一样，它将分阶段交付，不同的组件在不同的时间到达GA(通用可用性) ，可能首先利用预览（ Preview）机制。 您可以在它的wiki上找到更多关于Loom项目的资料，并在Loom EA binaries 文件(Early Access)中尝试下面描述的大部分内容。非常感激如果你能够将使用Loom的意见反馈到loom-dev邮件列表。 Thread.startVirtualThread(() -&gt; &#123; System.out.println(&quot;Hello, Loom!&quot;); &#125;); 要点 虚拟线程是一个Thread——在代码层面、运行时、调试阶段以及分析阶段都如此。 虚拟线程并不是OS线程的包装，而是一个Java对象。 创建一个虚拟线程的代价非常低廉——你可以创建数百万的虚拟线程，不用池化它们。 阻塞一个虚拟线程的代价非常低廉。 不需要改变语言。 可插拔式调度器提供了异步编程的灵活性。 内容 为什么 线程就是一切 支撑线程失去了它们的重点 大小合适的线程 从线程到虚拟线程 如何使用虚拟线程编程（你已经知道） 调度 性能和足迹 自旋 所有阻塞由我们来负责 调试和分析 为什么“虚拟” 第二部分：进一步的工作 为什么 线程就是一切 Java 用于编写一些世界上最大、最具可伸缩性的应用程序。可伸缩性是程序优雅地处理不断增长的工作负载的能力。实现可伸缩性的一种方式是并行（parallelism）：我们想要处理一大块可能相当大的数据，我们将它转换为lambda流水线，通过将它设置为并行，我们要求多个处理核心一起处理流水线上的任务，就像一群食人鱼吞食一条大鱼一样; 一条食人鱼也可以完成任务---- 只是前面的方式更快。这种机制是在 java8中实现的。但是有一种不同的、更难的、更普遍的扩展方式，即在同一时间处理应用程序中相对独立的任务。它们必须同时得到服务，这不是一种实现选择，而是一种要求。我们称之为并发性（concurrency），它是当代软件的基础，这就是Loom的意义所在。 考虑一下web服务器。它所服务的每个请求在很大程度上都是独立于其他请求的。对于每个服务，我们进行一些解析、查询数据库或向服务发出请求，然后等待结果，再进行一些处理并发送响应。这个过程不仅在完成某项工作时不与其他同时发生的HTTP请求合作，而且大多数时候它根本不关心其他请求在做什么，但它仍然在处理数据和I/O资源方面与它们竞争。不是食人鱼，而是出租车，每一条都有自己的路线和目的地。在同一条道路上行驶的其他出租车并不会让任何一辆出租车更早到达目的地ーー如果非要说有什么影响的话，也许会减慢速度ーー但是如果在城市道路上的任何时间只有一辆出租车，那就不仅仅是一个缓慢的交通系统，而是一个功能失调的系统。越多的出租车可以共用道路同时又不会造成市中心的交通拥堵，这个系统就越好。从早期开始，Java 就支持这种工作。Servlet 允许我们编写在屏幕上看起来简单直观的代码。一个简单的过程为ーー解析、数据库查询、处理、响应ーー不管服务器现在只处理这一个请求还是处理其他一千个请求。 每个并发应用程序都有一些天然属于其领域的并发单元，这些工作是可以独立于其他工作同时完成的。对于web服务器，这可能是HTTP请求或用户会话; 对于数据库服务器，这可能是事务。并发性有着比Java早得多的悠久而丰富的历史，但就Java的设计思想而言，其实很简单: 用一个按顺序运行的并发软件单元来表示这个领域并发单元，就像一辆出租车沿着其简单的路线前进，而不考虑其他任何出租车一样。这种软件构造就是线程。它对从处理器到I/O设备的资源进行虚拟化，并对其使用进行调度ーー利用每个线程可能在不同时间使用不同硬件单元的事实ーー对外暴露出来就好象一个顺序的过程。线程的拥有属性在于，它们不仅对处理操作进行排序，而且还对阻塞进行排序---- 等待某些外部事件的发生，不管是I/O还是某些事件，或者由另一个线程触发，只有在这些事件发生之后才继续执行。线程应该如何最好地相互通信的问题ーー共享数据结构和消息传递的合适的组合应该是什么ーー对于线程的概念来说并不是必不可少的，而且不管Java应用程序当前的组合是什么，它都有可能随着新特性的出现而改变。 无论您是直接使用它们，还是在JAX-RS框架内使用它们，并发在Java中意味着线程。事实上，整个Java平台——从虚拟机，到语言和库，到调试器和分析器——都是围绕线程构建的，作为运行程序的核心组成部分: I/O API是同步的，I/O操作初始化并通过阻塞线程等待一系列语句的顺序结果； 内存副作用(如果为无竞争的)按照线程的操作顺序排序，就好像没有其他线程竞争使用该内存; 异常通过将失败操作放在当前线程的调用堆栈的上下文中提供有用的信息; 调试器中的单步执行按照顺序执行，无论是需要进行某种处理还是 I/O，因为单步执行与线程相关联; 分析器使用线程来展示操作、I/O等待或同步所耗费的时间； 问题在于，作为并发性的软件单元，线程的规模无法与应用领域的并发性单元(会话、 HTTP 请求或单个数据库操作)相匹配，也无法与现代硬件所能支持的并发性规模相匹配。一台服务器可以处理超过100万个并发打开的套接字，但是操作系统不能有效地处理超过几千个活动(非空闲)线程。随着servlet容器的工作负载增加，越来越多的请求处于运行状态，它的伸缩能力受到操作系统能够支持的线程数量相对较少的限制，因为Little定律告诉我们，服务请求的平均持续时间与我们能够并发执行的请求数量成正比。因此，如果我们用一个线程来表示一个并发领域单元，那么线程的稀缺性早在硬件实现之前就成为了我们的可伸缩性瓶颈。servlet 读起来好伸缩性不好。 这不是线程概念的基本限制，而是它们在JDK中作为操作系统线程的简单包装器实现的一个偶然特性。操作系统线程的占用空间很大，创建它们需要分配操作系统资源，而调度它们(即为它们分配硬件资源)是次优的。他们与其说是出租车，不如说是火车。 这就造成了线程本来要做的事情与它们能够有效地做的事情之间的巨大不匹配。几个数量级的不匹配可能会产生很大的影响。 支撑线程失去了它们的重点 上述实现产生了巨大的影响。具有讽刺意味的是，线程发明出来是为了透明地共享虚拟化的稀缺计算资源，而线程本身已经成为稀缺资源，以至于我们不得不建立复杂的脚手架来共享它们。 因为线程的创建成本很高，所以我们将它们集中起来。创建一个新线程的成本是如此之高，以至于为了重用它们，我们很乐意为泄漏的线程局部变量和复杂的取消协议买单。 但是线程池本身提供的线程共享机制过于粗粒度。即使在一个时间点上运行的所有并发任务线程池中都没有足够的线程来表示。在任务的整个持续时间都会占用从线程池中借用到的线程，即使在等待某个外部事件(如来自数据库或服务的响应，或任何其他可能阻止它的活动)时。当任务正在等待时，操作系统线程挂起的代价实在是太高了。为了更好和更有效地共享线程，我们可以在每次任务必须等待某个结果时将线程返回池。这意味着任务在整个执行过程中不再绑定到单个线程。这也意味着我们必须避免阻塞线程，因为阻塞的线程不能用于其他任何工作。 其结果是异步api的大行其道，从JDK中的异步NIO，到异步servlet，再到许多所谓的“反应”库，这些库正是这样做的——在任务等待时将线程返回到池中，并尽最大努力不阻塞线程。将任务分解并异步构造最后再将它们组合在一起，结果形成了侵入式的、全局的和约束性的框架。即使是基本的控制流，比如循环和try/catch，也需要在“反应式”dsl中重新构造一遍，有些sporting类拥有数百个方法。 因为，如上所述，大多数Java平台都假设执行上下文包含在一个线程中，一旦我们将任务与线程分离，所有上下文都将丢失: 异常堆栈跟踪不再提供有用的上下文，当单步调试时，我们发现自己处于调度程序代码中，从一个任务跳转到另一个任务，分析器在I/O负载下可能会向我们显示空闲线程池，因为等待I/O的任务不会通过阻塞占有线程，而是返回到池中。 这种风格现在被一些人使用，并不是因为它更容易理解——许多程序员报告说，对他们来说，这种风格更难理解; 不是因为它更容易调试或分析——而是更难; 不是因为它与语言的其他部分很好地契合，或者与现有代码很好地集成，或者可以隐藏在“专家专用代码”中——恰恰相反，它具有病毒侵入性，使得与普通同步代码的干净集成几乎成为不可能，而只是因为Java中线程在占用空间和性能上的实现都不足。异步编程风格时刻与Java平台的设计作斗争，并且在可维护性和可观察性方面付出了高昂的代价。但它这样做有一个很好的理由: 满足可伸缩性和吞吐量要求，并充分利用昂贵的硬件资源。 一些编程语言试图通过在线程之上构建一个新概念来解决棘手的异步代码问题: async/await。它的工作方式类似于线程，但是协作调度点显式地标记为await。这使得编写可伸缩的同步代码成为可能，并通过引入一种新的上下文来解决上下文问题，这种线程是一种除了名称以外与线程都不兼容的“新线程”。如果同步代码和异步代码不能混在一起——一个阻塞和另一个却返回某种类型的 Future或Flow —— async/await则创建了两个不同的“彩色”世界，即使它们都是同步的，也不能混合在一起。为了使问题更加复杂，异步的调用同步代码，尽管它们是同步的，但没有线程被阻塞。因此，在C#中暂停当前正在执行的代码的一段时间需要两个不同的api，Kotlin也是这样做的，一个用来暂停线程，另一个用来暂停类似于线程但不是线程的新线程。同样的道理也适用于所有新创建的同步api，从同步API到I/O。不仅仅是同一个概念的两个实现没有一个统一的抽象，而且这两个世界在语法上是分离的，要求程序员标记他的代码单元适合以一种模式或另一种模式运行，而不是两种模式都适合。 此外，显式的协作调度点在Java平台上几乎没有提供什么好处。VM是针对峰值性能进行优化的，而不是像实时操作系统那样具有确定性的最坏情况延迟，因此它可能会在程序的任意点引入各种暂停，更不用说操作系统的任意、不确定和不加限制的抢占。阻塞操作的持续时间可能比那些不确定的暂停时间长几个数量级，也可能短几个数量级，因此明确标记它们帮助不大。在更适当的粒度上控制延迟的一种更好的方法是deadlines。 将线程作为稀缺资源进行管理的机制是一个很不幸的案例，因为实现的运行时性能特征而放弃了一个很好的抽象，取而代之的是另一个在大多数情况下更糟糕的方案。这种状态对Java生态系统产生了巨大的不利影响。 程序员被迫在直接将域并发单元建模为线程和浪费其硬件可以支持的相当大的吞吐量之间做出选择，或者使用其他方法在非常细粒度的级别上实现并发，但放弃Java平台的优势。无论是在硬件方面，还是在开发和维护工作方面，这两种选择都有相当大的财务成本。 我们可以做得更好。 Loom项目旨在消除高效运行并发程序与高效编写、维护和观察程序之间令人沮丧的权衡。它利用了平台的优势，而不是与之斗争，同时也利用了异步编程的高效组件的优势。它可以让你以熟悉的风格编写程序，使用熟悉的api，并与平台及其工具——以及硬件——保持一致，以便在写入时间和运行时成本之间达到平衡，我们希望这将具有广泛的吸引力。它在不改变语言的情况下做到了这一点，并且只对核心库api做了很小的改动。一个简单的同步web服务器将能够处理更多的请求，而不需要更多的硬件。 大小合适的线程 如果我们可以让线程更轻，我们可以有更多的线程。如果我们有更多这样的资源，它们就可以按预期的那样使用: 通过虚拟化稀缺的计算资源和隐藏管理这些资源的复杂性，直接表示并发的领域单元。这并不是一个新的想法，或许最为人所熟悉的就是Erlang和Go所采用的方法。 我们的基础是虚拟线程。虚拟线程是线程，但创建和阻塞它们的代价很低。它们由Java运行时管理，与现有的平台线程不同，它们不是OS线程的一对一包装，而是在JDK的用户空间中实现的。 OS线程是重量级的，因为它们必须支持所有语言和所有工作负载。线程要求具有暂停和恢复执行的能力。这需要保持它的状态，包括指令指针或程序计数器，它包含当前指令的索引，以及存储在堆栈上的所有本地计算数据。因为操作系统不知道一种语言如何管理它的堆栈，所以它必须分配一个足够大的堆栈。然后，我们必须通过将执行分配给某个空闲的CPU核心来安排它们何时可以运行(启动或未停放)。由于操作系统内核必须调度各种各样的线程，这些线程在处理和阻塞的混合过程中表现得非常不同ーー有些是处理HTTP请求，有些是播放视频ーー它的调度程序必须是一个充分的全方位妥协。 Loom增加了控制执行，挂起和恢复它的能力，通过具体化它的状态不是作为一个操作系统资源，而是作为一个虚拟机了解的Java对象，并由 Java Runtime直接控制。Java 对象安全有效地为各种状态机和数据结构建模，因此也非常适合于建模执行。Java Runtime知道Java代码如何使用堆栈，因此它可以更紧凑地表示执行状态。对执行的直接控制还可以让我们选择更适合我们工作负载的调度程序(普通的Java调度程序) ; 实际上，我们可以使用可插拔的自定义调度程序。因此，Java Runtime对Java代码的卓越洞察力使我们能够减少线程的成本。 尽管操作系统可以支持多达几千个活动线程，但 Java Runtime可以支持数百万个虚拟线程。应用程序域中的每个并发单元都可以由其自己的线程来表示，从而使并发应用程序的编程更加容易。忘记线程池吧，只需要生成一个新线程，每个任务一个线程。您已经产生了一个新的虚拟线程来处理传入的HTTP请求，但是现在，在处理请求的过程中，您希望同时查询数据库并向其他三个服务发出传出请求？没问题---- 创建更多的线程。你需要等待一些事情发生而不浪费宝贵的资源？忘记回调或反应式流ーー直接阻塞就好了。编写简单、无聊的代码。线程给我们带来的所有好处——控制流、异常上下文、调试流、分析组织——都被虚拟线程保留下来; 只有运行时占用空间和性能的成本没有了。与异步编程相比，灵活性没有损失，因为正如我们将看到的，我们还没有放弃对调度的细粒度控制。 迁移：从线程到虚拟线程 有了新的功能，我们知道如何实现虚拟线程; 如何向程序员展示这些线程就不那么清楚了。 每一个新的Java特性都在保守和创新之间创造了一种张力。前向兼容性使现有代码可以享受新特性(一个很好的例子是使用单一抽象方法类型的旧代码如何与lambdas一起工作)。但我们也希望纠正过去的设计错误，重新开始。 java.lang.Thread可以追溯到Java 1.0，多年来积累了方法和内部字段。它包含的方法有suspend、resume、 stop和countStackFrames，这些方法已经被废弃了20多年; 还有getAllStackTraces 这样的方法，它假定线程数量很小，是一些过时的概念，比如上下文类加载器(context-classloader) ，添加这些概念是为了支持某些应用程序容器的使用; 甚至还有一些更老的方法，比如ThreadGroup，它的原始用途似乎已经被历史遗忘，但仍然充斥着许多处理线程的内部代码和工具，包括一些过时的方法，比如Thread.enumerate。 实际上，Loom的早期原型是在一个新的Fiber类中表示我们的用户模式线程，它帮助我们检查现有代码对线程API的依赖性。实验中的几个观察结果帮助我们确定了我们的立场: 线程API的某些部分被广泛使用，特别是Thread.currentThread()和ThreadLocal。没有它们，几乎没有现有代码可以运行。我们尝试使ThreadLocal 的意思是thread-or-fiber-local，并且让 Thread.currentThread()返回一些fiber的线程视图，但是这些都增加了复杂性。 Thread API 的其他部分不仅很少使用，而且很少向程序员公开。从 Java 5开始，程序员就被鼓励通过 ExecutorServices 间接地创建和启动线程，这样Thread类中的混乱就不会带来极大的危害; 新的Java开发人员不需要接触到它的大部分，也不需要接触到它过时的残余。因此，保持 Thread API 的教学成本很小。 我们可以通过将Thread类中的元数据移动到一个“sidecar”对象来减少元数据的占用空间，只根据需要分配元数据。 新的弃用和删除策略将逐渐允许我们清理 Thread API。 我们想不出比Thread更好的东西来证明一个全新的API的合理性。 尽管仍然存在一些不便之处，比如不恰当的返回类型和中断机制，但是我们在实验中学到的——我们可以保留Thread API的一部分，而忽略另一部分——为了保留现有的API，我们移动了指针，并用现有Thread类来表示我们的用户模式线程。现在我们来看看: 虚拟线程就是线程，任何知道线程的库都已经知道虚拟线程。调试器和分析器使用它们的方式与当前的线程一样。与async/await不同，它们没有引入“语义鸿沟” : 程序员在屏幕上看到的代码行为在运行时被保留，并且对所有工具来说都是一样的。 如何使用虚拟线程编程（你已经知道） 创建和启动一个虚拟线程可以这样做: Thread t = Thread.startVirtualThread(() -&gt; &#123; ... &#125;); 为了获得更大的灵活性，有一个新的 Thread. Builder，它可以做上面提到的同样的事情: Thread t = Thread.builder().virtual().task(() -&gt; &#123; ... &#125;).start(); 或创建一个未启动的虚拟线程: Thread t = Thread.builder().virtual().task(() -&gt; ...).build(); 没有公共或受保护的Thread构造函数来创建虚拟线程，这意味着Thread的子类不能是虚拟的。因为子类化平台类限制了我们发展它们的能力，这是我们想要阻止的。 构造器还可以创建一个 ThreadFactory, ThreadFactory tf = Thread.builder().virtual().factory(); 可以传递给java.util.concurrent。执行器来创建使用虚拟线程并照常使用的ExecutorServices。但是，由于我们不需要也不想集中虚拟线程，所以我们向执行器添加了一个新方法newUnboundedExecutor。它构造了一个ExecutorService，为每个提交的任务创建并启动一个新线程，而不需要进行池操作ーー当任务终止时，它的线程终止: ThreadFactory tf = Thread.builder().virtual().factory(); ExecutorService e = Executors.newUnboundedExecutor(tf); Future&lt;Result&gt; f = e.submit(() -&gt; &#123; ... return result; &#125;); // spawns a new virtual thread ... Result y = f.get(); // joins the virtual thread thread API 的包袱并不困扰我们，因为我们不直接使用它。 除了构造Thread对象之外，一切和之前一样，只是所有虚拟线程的残留ThreadGroup是固定的，不能枚举它的成员。ThreadLocals对虚拟线程的处理方式与对平台线程的处理方式一样，但是由于它们可能仅仅因为存在大量的虚拟线程而大大增加内存占用，Thread.Builder允许线程的创建者禁止在该线程中使用它们。我们正在探索ThreadLocal 的一个替代方案，在 Scope Variables 部分中有所描述。 引入虚拟线程并不移除操作系统支持的现有线程实现。虚拟线程只是线程的一种新的实现，它的占用空间和调度是不同的。两种类型都可以锁定相同的锁，通过相同的阻塞队列交换数据等等。可以使用一个新的方法Thread.isVirtual来区分两种实现，但只有低级别的同步或I/O代码可能会关心这种区分。 然而，与我们习惯使用的线程相比，线程的存在是如此轻量级，这确实需要一些心理调整。首先，我们不再需要避免阻塞，因为阻塞一个(虚拟)线程并不昂贵。我们可以使用所有熟悉的同步api，而不用为吞吐量付出高昂的代价。其次，创建这些线程是廉价的。在合理的范围内，每个任务都可以有完全属于自己的线程;永远不需要将它们组合在一起。如果我们不将它们集中起来，我们如何限制对某些服务的并发访问？我们没有将任务分解并在一个单独的、受限的池子中运行服务调用子任务，而是让整个任务在自己的线程中从头到尾运行，并在服务调用代码中使用信号量来限制并发性ーー应该这样做。 很好地使用虚拟线程并不需要学习新的概念，而是要求我们抛弃多年来形成的旧习惯，之前我们自动的将高成本与线程联系起来，仅仅因为我们只有一个实现。 在本文的其余部分，我们将讨论虚拟线程如何超越传统线程的行为，指出一些新的API点和有趣的用例，并观察一些实现挑战。但是，成功使用虚拟线程所需的所有内容都已经解释过了。 调度 与必须非常通用的内核调度器不同，虚拟线程调度器可以为手头的任务定制化。虚拟线程也可以使用类似异步编程的灵活调度，不过由于线程和调度的细节被很好的隐藏起来了，你不需要了解它的工作原理，就像你不需要研究内核调度程序一样，除非你打算自己使用或编写一个定制的调度程序。这一部分完全是可选的。 在内核之外，我们不能直接访问CPU内核，所以我们使用内核线程作为接近它的一种方式:我们的调度器将虚拟线程调度到“物理”平台工作线程上。我们称调度器的工作线程为载体线程，因为它们上面承载着虚拟线程。像异步框架一样，我们最终会调度内核线程，只是我们将结果抽象为一个线程，而不是让调度的细节泄露到应用程序代码中。 当一个虚拟线程变得可运行时，调度程序将(最终)把它挂载到一个工作平台线程上，这个线程将在一段时间内成为虚拟线程的载体，并将一直运行它，直到它被取消调度——通常是在它阻塞时。然后，调度程序将从其载体中卸载该虚拟线程，并选择另一个线程进行挂载(如果有可运行的线程的话)。在虚拟线程上运行的代码无法观察其载体;Thread.currentThread 将始终返回当前(虚拟)线程。 默认情况下，虚拟线程由一个全局调度程序进行调度，其工作线程的数量与CPU内核的数量相同(或者显式地使用-djdk.defaultscheduler = n 进行设置)。大量的虚拟线程被安排在少量的平台线程上。这被称为 m: n 调度(m 用户模式线程被调度到n个内核线程上，其中 m &gt;&gt; n)。JDK 的早期版本也是在用户空间使用绿色线程实现的Thread; 然而，它们使用 m: 1调度，只使用一个内核线程。 工作窃取调度程序可以很好地工作于事务处理和消息传递中涉及的线程，这些线程通常以短时间爆发并经常阻塞为特点，就像我们在Java服务器应用程序中可能发现的那样。所以最初，默认的全局调度程序是具有工作窃取功能的ForkJoinPool。 虚拟线程是抢占式的，而不是协作式的ー它们在调度(任务切换)点上没有明确的等待操作。相反，当它们阻塞I/O或线程同步时，它们会被抢占。如果平台线程占用CPU的时间超过了某个分配的时间片，那么它们会被内核抢占。当活动线程的数量不超过内核数量，并且只有极少数线程处理量很大时，分时作为一种调度策略很有效。如果一个线程占用CPU太长时间，它会被抢占以使其他线程做出响应，然后它会被再次调度到另一个时间片。当我们有数百万个线程时，这种策略就不那么有效了：如果其中许多线程对CPU的需求如此之大，以至于它们需要时间共享，那么我们的资源就有几个数量级的短缺，没有任何调度策略可以拯救我们。在所有其他情况下，要么工作窃取调度器会自动消除零星的CPU占用，要么我们可以将有问题的线程作为平台线程运行，并依赖内核调度器。出于这个原因，JDK的调度器目前都没有采用基于时间片的虚拟线程抢占，但这并不是说将来不会采用——参见强制抢占。 与今天的线程相比，您不能对调度点的位置做任何假设。即使没有强制抢占，您调用的任何JDK或库方法都可能引入阻塞，从而引入任务切换点。 虚拟线程可以使用任意的、可插拔的调度程序。一个自定义的调度程序可以在每个线程的基础上设置，例如: Thread t = Thread.builder().virtual(scheduler).build(); 或者每个工厂，就像这样: ThreadFactory tf = Thread.builder().virtual(scheduler).factory(); 线程从出生到消亡都被分配给调度程序。 自定义调度程序可以使用各种调度算法，甚至可以选择将其虚拟线程调度到特定的单个载体线程或一组载体线程上(尽管如果调度程序只使用一个工作线程，则更容易被锁定)。 定制调度器不需要知道它是用来调度虚拟线程的。它可以是实现java.util.concurrent.Executor的任何类型，只需要实现一个方法:execute。这个方法将在线程可运行时被调用，也就是说，在线程启动(started)或未停泊(unparked)时请求调度。但是传递给execute的可运行实例是什么呢？它是Thread.VirtualThreadTask。VirtualThreadTask允许调度程序查询虚拟线程的身份，并将虚拟线程执行的内部保留状态包装起来。当调度器将这个Runnable分配给某个工作线程，然后该工作线程调用run方法时，该方法将装载虚拟线程并成为它的载体，虚拟线程的挂起(suspended)将被神奇地恢复，它会在载体上继续恢复执行。对于调度程序来说，run方法的行为看起来和其他方法一样——它看起来在同一个线程中执行(事实上，它确实在同一个内核线程中运行)，表面上是在任务终止时返回，但“内部”运行的代码会观察到它在虚拟线程中运行，当虚拟线程阻塞时，run会返回调度程序，使VirtualThreadTask处于挂起状态。你可以把VirtualThreadTask当成一种可恢复的可运行的线程包装。这就是神奇的地方。这一过程将在关于这一新的虚拟机功能的单独文档中详细解释。 调度程序绝不能在多个载体线程上并发执行 VirtualThreadTask。实际上，在调用同一个 VirtualThreadTask之前，必须先从run返回。 不管是哪种调度器，虚拟线程都具有与平台线程相同的内存一致性(由Java内存模型指定) ，但是定制调度器可以选择提供更强的保证。例如，使用单个工作平台线程的调度程序将使所有内存操作完全有序，不需要使用锁，并且允许使用HashMap代替 ConcurrentHashMap。然而，根据 JMM ，无竞争的线程在任何调度程序上都是无竞争的，但是依赖特定调度程序的保证可能导致该调度程序中的线程是无竞争的，而在其他调度程序中则不是。 性能和占用空间 虚拟线程的任务切换开销以及它们的内存占用都将随着时间的推移、在第一次发布之前和之后而改善。 性能由VM挂载和卸载虚拟线程的算法以及调度程序的行为决定。对于那些希望尝试性能的用户，可以使用VM选项 -XX:[-/+ ] UseContinuationChunks 在两个基础算法之间进行选择。此外，缺省调度程序(ForkJoinPool)在线程未充分利用的情况不是最优的(提交的任务比工作线程少，即可运行的虚拟线程少) ，因此您可能需要测试缺省工作者线程池的大小(-djdk.defaultscheduler = n)。 内存占用主要取决于虚拟线程状态的内部VM表示(尽管比平台线程好得多，但仍不是最优的)以及线程局部变量的使用。 关于虚拟线程运行时特性的讨论最好在loom的开发邮件列表中进行。 线程锁定（Pinning） 我们说，如果一个虚拟线程被挂载，但是处于无法卸载的状态，那么它就会被锁定到到其载体线程上。如果一个虚拟线程在锁定时阻塞，它就会阻塞它的载体线程。此行为仍然正确，但是在虚拟线程被阻塞期间，它将占用一个工作线程，使其他虚拟线程无法使用。 如果调度程序有多个工作线程，并且可以很好地利用其他工作线程，其中一些工作线程被虚拟线程锁定，偶尔的锁定是无害的。然而，过于频繁的锁定会影响吞吐量。 在当前的Loom实现中，可以在两种情况下固定一个虚拟线程: 当堆栈上有一个本地框架（native frame）时ーー当Java代码调用本地方法接口(JNI) ，然后再调用回 Java ーー以及当在一个同步块或方法中时。在这些情况下，阻塞虚拟线程将阻塞携带虚拟线程的物理线程。一旦本地方法调用完成或监视器释放(同步块/方法退出) ，线程将被取消锁定。 如果有一个普通的I/O操作由一个synchronized保护，那么将监视器替换为 ReentrantLock，即使在我们修复因监视器导致的线程锁定之前也可以让您的应用程序充分受益于Loom的可扩展性提升，(或者，如果可以的话，使用性能更高的 StampedLock)。 JDK 中两个常用的方法引入了一个锁定虚拟线程的本地框架: AccessController.doPrivileged 和 Method.invoke (+ 其构造函数的副本Constructor.newInstance)。用纯Java语言重写了doPrivileged。Method.invoke在某些迭代中使用本地调用，在预热后生成Java字节码;在Loom原型中，我们使用MethodHandles在Java中重新实现了它。静态类初始化器也被本机方法代码调用，但是它们运行得很少，所以我们不用担心它们。 此外，在进入synchronized或调用Object.wait时阻塞本地方法代码或试图获取不可用的监视器也会阻塞本地载体线程。 synchronized 的局限性最终会消失，但本地框架锁定仍然存在。我们认为它不会产生任何重大的负面影响，因为这种情况在Java中很少出现，但是Loom将添加一些诊断来检测锁定线程。 所有阻塞由我们来负责 将线程表示为“纯” Java 对象是第一步。第二是让所有的代码和库都使用新的机制; 否则它们将阻塞OS线程而不是虚拟线程。幸运的是，我们不需要改变所有的库和应用程序。无论何时在Spring或Hibernate中运行阻塞操作，它最终都会使用JDK中的核心库 API ーjava.* 包裹。JDK 控制了应用程序与操作系统或外部世界之间的所有交互点，因此我们所需要做的就是使它们适配虚拟线程。构建在JDK之上的所有内容现在都可以使用虚拟线程。具体地说，我们需要调整JDK中阻塞发生的所有点; 这些点有两种类型: 同步(想象一下锁或阻塞队列)和 I/O。特别是，当在虚拟线程上调用同步I/O操作时，我们希望阻塞虚拟线程，在底层执行异步文件文件操作，并设置它，当操作完成时，它将解除对虚拟线程的阻塞。 同步 synchronized/Object.wait的局限见线程锁定。 所有其他形式的同步，通常在java.util.concurrent以及调用它的程序库中，使用LockSupport.park/unpark方法阻止和取消阻止线程。我们已经做了适配，所以java.util.concurrent是虚拟线程友好的。 仍然需要进一步调优java.util.concurrent中的策略，以获得最佳的虚拟线程性能。 I/O java.nio.channels 类—— SocketChannel、 ServerSocketChannel和 DatagramChannel ——被改造为虚拟线程友好型。当它们的同步操作，比如read和write，在一个虚拟线程上执行时，在底层只会使用异步I/O。 “老式” I/O 网络接口ー java.net.Socket、 ServerSocket 和DatagramSocket已经在NIO之上的Java中重新实现，因此它立即可以从NIO 的虚拟线程友好特性中受益。 用户DNS查找的java.net.InetAddress的方法：getHostName, getCanonicalHostName, getByName仍然会委托给操作系统。因为它只提供一个操作系统线程阻塞的API。替代方案正在探索中。 进程管道也将类似地实现虚拟线程友好，除了在Windows上，这需要更大的努力。 控制台I/O也已经改装。 对Http(s)URLConnection以及TLS/SSL的实现进行了更改，以使其依赖于j.u.c锁而避免锁定。 文件I/O有问题。在内部，JDK 对文件使用缓冲 I/O，即使读取将被阻塞，它也总是报告可用。在Linux上，我们计划对异步文件I/O使用 io _ uring，同时我们正在使用 ForkJoinPool.ManagedBlocker机制，通过在工作线程被阻塞时向工作线程池添加更多的操作系统线程来缓和阻塞文件I/O操作。 因此，使用JDK的网络原语的库(无论是在JDK核心库中还是在其外部)也会自动变成非(OS-thread -)阻塞; 这包括JDBC驱动程序，以及HTTP客户机和服务器。 调试和分析 可服务性和可观察性一直是Java平台的高优先级关注点，也是其显著特性之一。对我们来说，在第一天就拥有良好的虚拟线程调试和分析经验是很重要的，尤其是在这些方面，虚拟线程可以比异步编程提供更多的好处，而异步编程的调试和分析体验尤其糟糕，这正是它自己的显著特征。 为Java调试器使用的Java调试器连线协议(JDWP)和Java调试器接口(JDI)提供动力的调试器代理程序，支持断点、单步执行、变量检查等普通调试操作。单步执行阻塞操作的行为与预期的一样，而且单步执行不会像调试异步代码那样从一个任务跳到另一个任务，或跳到调度程序代码。在JVM TI 级别支持虚拟线程的更改为此提供了便利。我们还与IntelliJ IDEA 和NetBeans调试器团队进行合作测试在这些ide中调试虚拟线程。 在当前的EA中，并非所有的调试器操作都支持虚拟线程。一些操作带来了特殊的挑战。例如，调试器通常列出所有活动线程。如果您有一百万个线程，那么这既缓慢又无用。实际上，我们没有提供任何机制来枚举所有虚拟线程。正在探讨一些想法，比如仅列出在调试会话期间遇到某些调试器事件(如命中断点)的虚拟线程。 异步代码最大的问题之一是几乎不可能很好地分析。对于分析器来说，没有一种好的通用方法可以根据上下文对异步操作进行分组，即整理同步管道中处理传入请求的所有子任务。因此，当您尝试分析异步代码时，您经常会看到空闲线程池，即使应用程序处于负载状态，因为没有办法跟踪等待异步I/O的操作。 虚拟线程解决了这个问题，因为同步操作与它们阻塞的线程相关联(即使在底层使用异步I/O)。我们已经修改了JDK Flight Recorder (JFR)—— JDK 中分析和结构化日志的基础——以支持虚拟线程。阻塞的虚拟线程可以显示在分析器中，并且可以度量和计算在I/O上花费的时间。 另一方面，虚线程给可观测性带来了一些挑战。例如，如何理解一个100万线程的线程转储（thread dump）？我们相信结构化的并发可以帮助解决这个问题。 为什么是“虚拟” ？ 在该项目的前几次迭代中，我们将我们的轻量级用户模式线程称为“纤程” ，但发现自己反复解释说，它们不是一个新概念，而是一个熟悉的线程的不同实现。此外，这个术语已经被用于那些相似但又足够不同以至于引起混淆的结构。“绿线程”也同样受到其他实现的污染。我们考虑了非特定的“轻量级线程” ，但“轻量级”是相对的，我们设想未来的jdk拥有“微线程” ，因此我们决定采用 Brian Goetz 的建议，称它们为“虚拟线程” ，这在会议上也得到了很好的测试。这个名字是为了唤起与虚拟内存的联系: 通过将虚拟结构映射到具体结构(物理内存、 OS 线程)上，我们得到了更多的东西(地址空间、线程)。 第二部分：进一步的工作","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"loom","slug":"loom","permalink":"https://naosense.github.io/tags/loom/"}]},{"title":"简明Java反射教程1：类（Classes）","slug":"简明Java反射教程1：类（Classes","date":"2020-03-07T11:44:19.000Z","updated":"2025-09-16T02:08:43.018Z","comments":true,"path":"2020/03/07/简明Java反射教程1：类（Classes/","link":"","permalink":"https://naosense.github.io/2020/03/07/%E7%AE%80%E6%98%8EJava%E5%8F%8D%E5%B0%84%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%B1%BB%EF%BC%88Classes/","excerpt":"","text":"Java反射历来是迈入高级Java开发者的必备科目，网上教程是五花八门，有的失于不够全面，有的失于谬误百出。看过之后不懂的更不懂了，懂得也有点蒙了，偶然看到Oracle的官方教程页面，仿佛打开了新的世界，里面的教程不仅简明易懂而且非常权威，毕竟是官方出品，里面有篇反射教程，非常不错，翻译一下，推荐给大家。由于篇幅相对于一篇博客来说还是有点长了，我将其分为三个部分：类､成员以及数组和枚举类型。本篇是第一篇，类的反射。 反射用途 反射通常用来修改Java虚拟机应用程序的运行时行为。这是一个相对高级的功能，只应由对语言基础有很深了解的开发人员使用。考虑到这一点，反射是一种强大的技术，可以使应用程序执行原本不可能的操作。 扩展功能 应用程序可以通过使用其完全限定名创建外部用户定义类的实例。 类浏览器和可视化开发环境 类浏览器需要枚举类的成员。可视化开发环境可以利用反射中可用的类型信息来帮助开发人员编写正确的代码。 调试和测试工具 调试工具需要检查类的私有成员。测试工具可以利用反射来系统地调用在类上定义的可发现的API集合，以确保代码的高覆盖率。 反射弊端 反射功能强大，但不应任意使用。如果可以在不使用反射的情况下实现需要的操作，那么最好避免使用它。通过反射访问代码时应牢记以下问题。 性能开销 由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能要比非反射操作慢，因此，在性能敏感的应用程序中经常调用的代码段中，应避免使用反射。 安全限制 反射需要运行时许可，而在安全管理器下运行时可能不存在这种许可。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。 内部暴露 由于反射允许执行在非反射代码中非法的操作，例如访问私有字段和方法，因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。 教程章节 本教程涵盖了反射在访问和操作类、字段、方法和构造函数方面的常见用法。每节课均包含代码示例，技巧和故障排除信息。 主要章节为： 类 成员 数组和枚举类型 类 本课说明了获取Class对象并使用它检查类的属性的各种方法，包括其声明和内容。 类型要么是引用类型，要么是原始类型。类，枚举和数组（都继承自java.lang.Object）以及接口都是引用类型。引用类型包括java.lang.String，原始类型的所有包装器类，例如java.lang.Double，接口 java.io.Serializable和枚举javax.swing.SortOrder。原始类型有：布尔值(boolean)，字节(byte)，短型(short)，整数(int)，长型(long)，字符(char)，浮点型(float)和双精度型(double)。 对于每种类型的对象，Java虚拟机都会实例化一个不可变的java.lang.Class实例，该实例提供检查对象的运行时属性（包括其成员和类型信息）的方法。Class还提供了创建类和对象的能力。最重要的是，它是所有反射API的入口点。本课涵盖了涉及类的最常见的反射操作： 获取类对象描述了获取类的方式。 检查类修饰符和类型显示如何访问类声明信息。 发现类成员说明了如何在类中列出构造函数，字段，方法和嵌套类。 故障排除描述了使用类时遇到的常见错误。 获取类对象 所有反射操作的入口点是java.lang.Class。除了java.lang.reflect.ReflectPermission之外，java.lang.reflect包下的所有类都没有公共构造函数。要获得这些类，必须在Class上调用相应的方法。根据代码是否可以访问对象，类的名称，类型或现有的类，有几种获取类的方法。 Object.getClass() 如果对象的实例可用，则获取其类的最简单方法是调用Object.getClass()。当然，这仅适用于全部继承自Object的引用类型。以下是一些示例。 Class c = &quot;foo&quot;.getClass(); 返回字符串(String)的类(Class) Class c = System.console().getClass(); 与虚拟机关联的唯一控制台由静态方法System.console()返回。getClass()返回的值是与getClass()对应的Class。 enum E &#123; A, B &#125; Class c = A.getClass(); A是枚举E的实例；因此，getClass()返回与枚举类型E相对应的Class。 byte[] bytes = new byte[1024]; Class c = bytes.getClass(); 由于数组是对象(Object)，因此也可以在数组的实例上调用getClass()。返回的Class对应于组件类型为byte的数组。 import java.util.HashSet; import java.util.Set; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); Class c = s.getClass(); 在这种情况下，java.util.Set是类型为java.util.HashSet的对象的接口。getClass()返回的值是对应于java.util.HashSet的类。 .class 如果类的实例不可用，那么可以使用.class的方式获取Class。这也是基本类型获取Class最简单的方式。 boolean b; Class c = b.getClass(); // compile-time error Class c = boolean.class; // correct 请注意，语句boolean.getClass()会产生编译时错误，因为布尔值是基本类型且无法取消引用。.class语法返回与布尔类型相对应的Class。 Class c = java.io.PrintStream.class; 变量c是与类型java.io.PrintStream对应的Class。 Class c = int[][][].class; .class语法可用于获取多维数组相对应的Class。 Class.forName() 如果一个类的完全限定名可用，可以使用静态方法Class.forName()获取相应的Class。数组的完全限定名不能用于基本类型。数组的限定名可以使用Class.getName()获取。Class.getName()适用于引用和基本类型。 Class c = Class.forName(&quot;com.duke.MyLocaleServiceProvider&quot;); 该语句将从给定的完全限定名称创建一个类。 Class cDoubleArray = Class.forName(&quot;[D&quot;); Class cStringArray = Class.forName(&quot;[[Ljava.lang.String;&quot;); 变量cDoubleArray对应于基本类型为double的数组的Class（即与double[].class相同）。变量cStringArray对应String二维数组的Class（和String[][].class一样）。 基本类型包装类的类型 对于基本类型，.class是最容易的一种方式，不过还有一种方式可以获取Class。每个基本类型和void在java.lang中都有一个包装器类，用于将原始类型装箱到引用类型。每个包装器类都包含一个名为TYPE的字段，该字段对应于包装的基本类型的Class。 Class c = Double.TYPE; 有一个类java.lang.Double，用于在需要Object时包装基本类型double。 Double.TYPE的值与double.class的值相同。 Class c = Void.TYPE; Void.TYPE与void.class相同。 返回Class的方法 Class.getSuperclass() 返回给定类的超类。 Class c = javax.swing.JButton.class.getSuperclass(); javax.swing.JButton的超类是javax.swing.AbstractButton。 Class.getClasses() 返回属于该类成员的所有公共类，接口和枚举，包括继承的成员。 Class&lt;?&gt;[] c = Character.class.getClasses(); Character 包含两个成员类 Character.Subset 和Character.UnicodeBlock。 Class.getDeclaredClasses() 返回所有类接口，以及在该类中显式声明的枚举。 Class&lt;?&gt;[] c = Character.class.getDeclaredClasses(); Character包含两个公共成员类： Character.Subset和Character.UnicodeBlock，一个私有类：Character.CharacterCache。 Class.getDeclaringClass() java.lang.reflect.Field.getDeclaringClass() java.lang.reflect.Method.getDeclaringClass() java.lang.reflect.Constructor.getDeclaringClass() 返回这些成员的声明类。 匿名类没有声明类但但有封闭类。 import java.lang.reflect.Field; Field f = System.class.getField(&quot;out&quot;); Class c = f.getDeclaringClass(); // System 字段 out是在System中声明的。 public class MyClass &#123; static Object o = new Object() &#123; public void m() &#123;&#125; &#125;; static Class&lt;c&gt; = o.getClass().getEnclosingClass(); &#125; o代表的匿名类的声明类为null。 Class.getEnclosingClass() 返回该类的直接封闭类。 Class c = Thread.State.class().getEnclosingClass(); 枚举Thread.State的封闭类是Thread。 public class MyClass &#123; static Object o = new Object() &#123; public void m() &#123;&#125; &#125;; static Class&lt;c&gt; = o.getClass().getEnclosingClass(); &#125; o定义的匿名类包含在MyClass中。 检查类的修饰符和类型 一个类在声明时可能会有一个或多个修饰符影响它的运行时行为： 访问修饰符：public,protected,private 需要覆盖的修饰符：abstract 仅限一个实例的修饰符：static 禁止修改值的修饰符：final 执行严格浮点行为的修饰符：strictfp 注解 并非所有类都允许使用所有修饰符，例如，接口不能为final，而枚举不能为abstract。java.lang.reflect.Modifier包含所有可能的修饰符的声明。它还包含用于解码Class.getModifiers()返回的修饰符集的方法。 ClassDeclarationSpy示例演示如何获取类的声明组件，包括修饰符，泛型类型参数，已实现的接口和继承路径。由于Class 实现了java.lang.reflect.AnnotatedElement接口，因此也可以查询运行时注解。 import java.lang.annotation.Annotation; import java.lang.reflect.Modifier; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import static java.lang.System.out; public class ClassDeclarationSpy &#123; public static void main(String... args) &#123; try &#123; Class&lt;?&gt; c = Class.forName(args[0]); out.format(&quot;Class:%n %s%n%n&quot;, c.getCanonicalName()); out.format(&quot;Modifiers:%n %s%n%n&quot;, Modifier.toString(c.getModifiers())); out.format(&quot;Type Parameters:%n&quot;); TypeVariable[] tv = c.getTypeParameters(); if (tv.length != 0) &#123; out.format(&quot; &quot;); for (TypeVariable t : tv) out.format(&quot;%s &quot;, t.getName()); out.format(&quot;%n%n&quot;); &#125; else &#123; out.format(&quot; -- No Type Parameters --%n%n&quot;); &#125; out.format(&quot;Implemented Interfaces:%n&quot;); Type[] intfs = c.getGenericInterfaces(); if (intfs.length != 0) &#123; for (Type intf : intfs) out.format(&quot; %s%n&quot;, intf.toString()); out.format(&quot;%n&quot;); &#125; else &#123; out.format(&quot; -- No Implemented Interfaces --%n%n&quot;); &#125; out.format(&quot;Inheritance Path:%n&quot;); List&lt;Class&gt; l = new ArrayList&lt;Class&gt;(); printAncestor(c, l); if (l.size() != 0) &#123; for (Class&lt;?&gt; cl : l) out.format(&quot; %s%n&quot;, cl.getCanonicalName()); out.format(&quot;%n&quot;); &#125; else &#123; out.format(&quot; -- No Super Classes --%n%n&quot;); &#125; out.format(&quot;Annotations:%n&quot;); Annotation[] ann = c.getAnnotations(); if (ann.length != 0) &#123; for (Annotation a : ann) out.format(&quot; %s%n&quot;, a.toString()); out.format(&quot;%n&quot;); &#125; else &#123; out.format(&quot; -- No Annotations --%n%n&quot;); &#125; // production code should handle this exception more gracefully &#125; catch (ClassNotFoundException x) &#123; x.printStackTrace(); &#125; &#125; private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) &#123; Class&lt;?&gt; ancestor = c.getSuperclass(); if (ancestor != null) &#123; l.add(ancestor); printAncestor(ancestor, l); &#125; &#125; &#125; 下面是输出的一些样本。用户输入以斜体显示。 $ java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap Class: java.util.concurrent.ConcurrentNavigableMap Modifiers: public abstract interface Type Parameters: K V Implemented Interfaces: java.util.concurrent.ConcurrentMap&lt;K, V&gt; java.util.NavigableMap&lt;K, V&gt; Inheritance Path: -- No Super Classes -- Annotations: -- No Annotations -- 这是实际的源代码 java.util.concurrent.ConcurrentNavigableMap中的实际声明： public interface ConcurrentNavigableMap&lt;K,V&gt; extends ConcurrentMap&lt;K,V&gt;, NavigableMap&lt;K,V&gt; 注意，由于这是一个接口，因此它是隐式abstract的。编译器为每个接口添加此修饰符。另外，此声明包含两个泛型参数K和V。示例代码仅打印这些参数的名称，但是可以使用java.lang.reflect.TypeVariable中的方法获取有关它们的其他信息。接口也可以实现其他接口，如上所示。 $ java ClassDeclarationSpy &quot;[Ljava.lang.String;&quot; Class: java.lang.String[] Modifiers: public abstract final Type Parameters: -- No Type Parameters -- Implemented Interfaces: interface java.lang.Cloneable interface java.io.Serializable Inheritance Path: java.lang.Object Annotations: -- No Annotations -- 由于数组是运行时对象，因此所有类型信息均由Java虚拟机定义。特别是，数组实现 Cloneable和 java.io.Serializable ，其直接超类始终是Object。 $ java ClassDeclarationSpy java.io.InterruptedIOException Class: java.io.InterruptedIOException Modifiers: public Type Parameters: -- No Type Parameters -- Implemented Interfaces: -- No Implemented Interfaces -- Inheritance Path: java.io.IOException java.lang.Exception java.lang.Throwable java.lang.Object Annotations: -- No Annotations -- 从继承路径可以推断出java.io.InterruptedIOException是一个检查的异常，因为RuntimeException 没有出现。 $ java ClassDeclarationSpy java.security.Identity Class: java.security.Identity Modifiers: public abstract Type Parameters: -- No Type Parameters -- Implemented Interfaces: interface java.security.Principal interface java.io.Serializable Inheritance Path: java.lang.Object Annotations: @java.lang.Deprecated() 输出表明java.security.Identity拥有注释java.lang.Deprecated是一个不推荐使用的API。反射代码可以使用它来检测已弃用的API。 注意：并非所有注释都可以通过反射获得。只有具有RUNTIME的java.lang.annotation.RetentionPolicy的那些注解才可访问。在 @Deprecated，@Override和@SuppressWarnings语言中预定义的三个注释中，只有@Deprecated在运行时可用。 发现类成员 类提供了用于访问字段，方法和构造函数的两类方法：枚举这些成员的方法和搜索特定成员的方法。与在超接口和超类中搜索继承的成员的方法相比，直接在类上访问成员方法不太一样。下表总结了所有成员定位方法及其特点。 定位字段的类方法 Class API 是否成员列表？ 是否包含继承成员？ 是否包含私有成员？ getDeclaredField() 否 否 是 getField() 否 是 否 getDeclaredFields() 是 否 是 getFields() 是 是 否 定位方法的类方法 Class API 是否成员列表？ 是否包含继承成员？ 是否包含私有成员？ getDeclaredMethod() 否 否 是 getMethod() 否 是 否 getDeclaredMethods() 是 否 是 getMethods() 是 是 否 定位构造方法的类方法 Class API 是否成员列表？ 是否包含继承成员？ 是否包含私有成员？ getDeclaredConstructor() 否 N/A 是 getConstructor() 否 N/A 否 getDeclaredConstructors() 是 N/A 是 getConstructors() 是 N/A 否 N/A：构造函数不能继承。 给定一个类名并指出感兴趣的成员，ClassSpy示例使用get*s()方法确定所有公共成员的列表，包括任何继承的成员。 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Member; import static java.lang.System.out; enum ClassMember &#123; CONSTRUCTOR, FIELD, METHOD, CLASS, ALL &#125; public class ClassSpy &#123; public static void main(String... args) &#123; try &#123; Class&lt;?&gt; c = Class.forName(args[0]); out.format(&quot;Class:%n %s%n%n&quot;, c.getCanonicalName()); Package p = c.getPackage(); out.format(&quot;Package:%n %s%n%n&quot;, (p != null ? p.getName() : &quot;-- No Package --&quot;)); for (int i = 1; i &lt; args.length; i++) &#123; switch (ClassMember.valueOf(args[i])) &#123; case CONSTRUCTOR: printMembers(c.getConstructors(), &quot;Constructor&quot;); break; case FIELD: printMembers(c.getFields(), &quot;Fields&quot;); break; case METHOD: printMembers(c.getMethods(), &quot;Methods&quot;); break; case CLASS: printClasses(c); break; case ALL: printMembers(c.getConstructors(), &quot;Constuctors&quot;); printMembers(c.getFields(), &quot;Fields&quot;); printMembers(c.getMethods(), &quot;Methods&quot;); printClasses(c); break; default: assert false; &#125; &#125; // production code should handle these exceptions more gracefully &#125; catch (ClassNotFoundException x) &#123; x.printStackTrace(); &#125; &#125; private static void printMembers(Member[] mbrs, String s) &#123; out.format(&quot;%s:%n&quot;, s); for (Member mbr : mbrs) &#123; if (mbr instanceof Field) out.format(&quot; %s%n&quot;, ((Field)mbr).toGenericString()); else if (mbr instanceof Constructor) out.format(&quot; %s%n&quot;, ((Constructor)mbr).toGenericString()); else if (mbr instanceof Method) out.format(&quot; %s%n&quot;, ((Method)mbr).toGenericString()); &#125; if (mbrs.length == 0) out.format(&quot; -- No %s --%n&quot;, s); out.format(&quot;%n&quot;); &#125; private static void printClasses(Class&lt;?&gt; c) &#123; out.format(&quot;Classes:%n&quot;); Class&lt;?&gt;[] clss = c.getClasses(); for (Class&lt;?&gt; cls : clss) out.format(&quot; %s%n&quot;, cls.getCanonicalName()); if (clss.length == 0) out.format(&quot; -- No member interfaces, classes, or enums --%n&quot;); out.format(&quot;%n&quot;); &#125; &#125; 这个例子比较紧凑。但是printMembers()方法有点尴尬，因为反射最早的实现中就存在java.lang.reflect.Member接口了，所以后来引入泛型时无法对其进行修改以包含更有用的getGenericString()方法。唯一的选择就是如上面那样进行测试和转换，使用独立的方法如printConstructors()、printFields()、printMethods()进行打印。 输出样本及其解释如下。用户输入以斜体显示。 $ java ClassSpy java.lang.ClassCastException CONSTRUCTOR Class: java.lang.ClassCastException Package: java.lang Constructor: public java.lang.ClassCastException() public java.lang.ClassCastException(java.lang.String) 由于构造函数不能继承，因此找不到在直接超类RuntimeException和其他超类中定义的异常链接机制构造函数（具有 Throwable参数的那些）。 $ java ClassSpy java.nio.channels.ReadableByteChannel METHOD Class: java.nio.channels.ReadableByteChannel Package: java.nio.channels Methods: public abstract int java.nio.channels.ReadableByteChannel.read (java.nio.ByteBuffer) throws java.io.IOException public abstract void java.nio.channels.Channel.close() throws java.io.IOException public abstract boolean java.nio.channels.Channel.isOpen() java.nio.channels.ReadableByteChannel定义了read()方法。其余方法是从超接口继承的。通过将get * s()替换为getDeclared * s()，这个代码稍作修改，就可以只列出那些在类中实际声明的方法。 $ java ClassSpy ClassMember FIELD METHOD Class: ClassMember Package: -- No Package -- Fields: public static final ClassMember ClassMember.CONSTRUCTOR public static final ClassMember ClassMember.FIELD public static final ClassMember ClassMember.METHOD public static final ClassMember ClassMember.CLASS public static final ClassMember ClassMember.ALL Methods: public static ClassMember ClassMember.valueOf(java.lang.String) public static ClassMember[] ClassMember.values() public final int java.lang.Enum.hashCode() public final int java.lang.Enum.compareTo(E) public int java.lang.Enum.compareTo(java.lang.Object) public final java.lang.String java.lang.Enum.name() public final boolean java.lang.Enum.equals(java.lang.Object) public java.lang.String java.lang.Enum.toString() public static &lt;T&gt; T java.lang.Enum.valueOf (java.lang.Class&lt;T&gt;,java.lang.String) public final java.lang.Class&lt;E&gt; java.lang.Enum.getDeclaringClass() public final int java.lang.Enum.ordinal() public final native java.lang.Class&lt;?&gt; java.lang.Object.getClass() public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final void java.lang.Object.wait() hrows java.lang.InterruptedException public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() 在上面结果的field部分中，枚举的常量值都列了出来。While these are technically fields, it might be useful to distinguish them from other fields.可以使用java.lang.reflect.Field.isEnumConstant()达到这个木得。本教程的后续部分Examining Enums中示例EnumSpy给出了一个可能的实现。 在结果的method部分，包含声明类的方法名。因此方法toString()是在Enum中实现的，而不是继承自Object。通过使用Field.getDeclaringClass()，可以对代码进行修改以使其更加明显。以下片段说明了潜在解决方案的一部分。 if (mbr instanceof Field) &#123; Field f = (Field)mbr; out.format(&quot; %s%n&quot;, f.toGenericString()); out.format(&quot; -- declared in: %s%n&quot;, f.getDeclaringClass()); &#125; 故障排除 以下示例显示了在类上使用反射时可能会遇到的典型错误。 编译器警告：“Note: … uses unchecked or unsafe operations” 调用方法时，将检查并可能转换参数值的类型。 ClassWarning 调用getMethod()会造成一个未受检异常。 import java.lang.reflect.Method; public class ClassWarning &#123; void m() &#123; try &#123; Class c = ClassWarning.class; Method m = c.getMethod(&quot;m&quot;); // warning // production code should handle this exception more gracefully &#125; catch (NoSuchMethodException x) &#123; x.printStackTrace(); &#125; &#125; &#125; $ javac ClassWarning.java Note: ClassWarning.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. $ javac -Xlint:unchecked ClassWarning.java ClassWarning.java:6: warning: [unchecked] unchecked call to getMethod (String,Class&lt;?&gt;...) as a member of the raw type Class Method m = c.getMethod(&quot;m&quot;); // warning ^ 1 warning 很多库的方法已经使用泛型声明进行了改进。由于c被声明为原始类型（没有类型参数），而getMethod()的相应参数是参数化类型，因此发生了未经检查的转换。需要编译器生成警告（参见The Java Language Specification, Java SE 7 Edition的Unchecked Conversion 和 Method Invocation Conversion部分） 有两种可能的解决方案。最好修改c的声明以包含适当的泛型类型。在这种情况下，声明应为： Class&lt;?&gt; c = warn.getClass(); 或者，可以使用预定义的注解@SuppressWarnings放置在问题语句的前面来明确禁止警告。 Class c = ClassWarning.class; @SuppressWarnings(&quot;unchecked&quot;) Method m = c.getMethod(&quot;m&quot;); // warning gone Tip：作为一般原则，不应忽略警告，因为警告可能表明存在错误。应适当使用参数化的声明。如果这是不可能的（也许是因为应用程序必须与库供应商的代码进行交互），请使用 @SuppressWarnings注释违规行。 构造函数不可访问时的InstantiationException 如果尝试创建该类的新实例并且零参数构造函数不可见，则Class.newInstance()将引发InstantiationException。 ClassTrouble示例说明了生成的堆栈记录。 class Cls &#123; private Cls() &#123;&#125; &#125; public class ClassTrouble &#123; public static void main(String... args) &#123; try &#123; Class&lt;?&gt; c = Class.forName(&quot;Cls&quot;); c.newInstance(); // InstantiationException // production code should handle these exceptions more gracefully &#125; catch (InstantiationException x) &#123; x.printStackTrace(); &#125; catch (IllegalAccessException x) &#123; x.printStackTrace(); &#125; catch (ClassNotFoundException x) &#123; x.printStackTrace(); &#125; &#125; &#125; $ java ClassTrouble java.lang.IllegalAccessException: Class ClassTrouble can not access a member of class Cls with modifiers &quot;private&quot; at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:65) at java.lang.Class.newInstance0(Class.java:349) at java.lang.Class.newInstance(Class.java:308) at ClassTrouble.main(ClassTrouble.java:9) Class.newInstance()行为非常类似于new关键字，new失败方法也会失败。反射中的典型解决方案是利用java.lang.reflect.AccessibleObject类，该类提供了抑制访问控制检查的功能。但是这种方法不适用于本例，因为java.lang.Class没有继承AccessibleObject。唯一的解决方式就是修改代码使用继承AccessibleObject的Constructor.newInstance()方法。 Tip：由于本教程成员章节创建新的类实例 部分所说的原因，一般情况下，使用Constructor.newInstance()会好一些。 更多的栗子参见本教程成员章节创建新的类实例 部分。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"反射","slug":"反射","permalink":"https://naosense.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"中国真的越来越老了吗","slug":"中国真的越来越老了吗","date":"2020-02-21T21:24:36.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2020/02/21/中国真的越来越老了吗/","link":"","permalink":"https://naosense.github.io/2020/02/21/%E4%B8%AD%E5%9B%BD%E7%9C%9F%E7%9A%84%E8%B6%8A%E6%9D%A5%E8%B6%8A%E8%80%81%E4%BA%86%E5%90%97/","excerpt":"","text":"中国真的老了吗？ 老龄化是今年提得比较多的一个词，中国人真的老龄化了吗？从下图可以直观的看到，从1982年到2010年五次人口普查中，中国人口的年龄分布确实有增大的趋势。 下面的表格给出了精确的数字，可以看到1982年30岁以下人口占到了62.8%，而这一数字到了2010年只有41.2%，而60岁以上的人口却从7.5%增加到了13.3%，由此看来中国的老龄化确实不是耸人听闻，确实是当前的发展趋势。 时间 比例：0-30岁 比例：30-60岁 比例：60-100岁 1982 62.79321 29.69685 7.509944 1987 60.05553 31.80970 8.134770 1990 58.66278 32.75971 8.577509 2000 48.26399 41.27596 10.460051 2010 41.23902 45.43618 13.324804 男女比例真的失调了吗？ 现在娶媳妇越来越难了，特别是农村，长期以来大家都将原因归结为男女比例失调，农村为了争夺宅基地和从事大量体力劳动，重男轻女更为严重，事实是这样吗？ 从上图可以看出，随着时间的推移，男女比例确实有增加的趋势，前三次普查男女比例在1.12左右，后两次普查这个比例上涨到1.2左右，而且农村男女比例与城市男女比例相差不大。另外还可以看到一个有意思的现象是男的寿命确实不如女的。1982年62岁以上的人口中女大于男，2010年这一拐点提高到了75岁，也就是到了到了2010年75岁以上的老人中女比男多。图中的数字表示男女比例为1/2的年龄，这一数字随着年代的发展也在提高，可见对于男人来说，社会发展该有多么重要，知道为啥男的喜欢看新闻了吧。 城里人越来越多了吗？ 城里人真的越来越多了，从1982年的2亿到了2010年的接近7亿，农村人口略有减少，从8亿降到了7亿。值得一提的是1987年有一波农村人口增加，城市人口减少的特异值，发生了什么？","categories":[],"tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://naosense.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"r","slug":"r","permalink":"https://naosense.github.io/tags/r/"}]},{"title":"Windows用户Ocaml入坑指南","slug":"Windows用户Ocaml入坑指南","date":"2019-11-02T10:33:32.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2019/11/02/Windows用户Ocaml入坑指南/","link":"","permalink":"https://naosense.github.io/2019/11/02/Windows%E7%94%A8%E6%88%B7Ocaml%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/","excerpt":"","text":"第一次听说Ocaml是看到Ocaml写的quicksort算法： let rec quicksort = function | [] -&gt; [] | x::xs -&gt; let smaller, larger = List.partition (fun y -&gt; y &lt; x) xs in quicksort smaller @ (x::quicksort larger);; List.iter (fun x -&gt; Printf.printf &quot;%d &quot; x) (quicksort [2; 3; 1; 1; 7; 10]) Java语言的实现相信大家都看过，这里我把Algorithms 4th中的源码贴一下： public class Quick &#123; public static void sort(Comparable[] a) &#123; StdRandom.shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125; private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) &#123; if (i == hi) break; &#125; while (less(v, a[--j])) &#123; if (j == lo) break; &#125; if (i &gt;= j) break; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125; private static boolean less(Comparable v, Comparable w) &#123; if (v == w) return false; return v.compareTo(w) &lt; 0; &#125; private static void exch(Object[] a, int i, int j) &#123; Object swap = a[i]; a[i] = a[j]; a[j] = swap; &#125; &#125; 两下一对比，被震撼到了。这么说吧，看Ocaml写的快排算法很容易看到算法的本质，而Java的实现则是“一团糟”，算法的本质隐藏到琐碎的细节中了，通篇都是if分支和数组索引。Ocaml强大的模式匹配和immunable数据结构可以让你写出清晰简洁的代码。难能可贵的是，和曲高和寡的Lisp不同，Ocaml虽然崇尚函数式编程，但并不排斥命令式编程。另外，Ocaml是一门非常实用的语言，尤其适合编译方面的工作，所以如果你对DSL感兴趣，相信Ocaml会是你的菜，要知道大名鼎鼎的Rust语言在自举前编译器就是用Ocaml写的。 怀着激动的心情一通谷歌，发现只支持Linux和OSX，这就蛋疼了。尝试了官网安装说明中几种Windows安装方式，效果都不理想，顶多就一个黑框框，毕竟自己不是大神，还是需要代码提示和代码格式化这样的功能的，所以尝试了几次，只好忍痛割爱。一个偶然的机会，接触了Windows上的Wsl系统，感觉不错，又想起心心念念的Ocaml了，自然就想到了结合Wsl是否可以搭建一个理想的Ocaml环境？摸索了一段时间，终于找到一种比较理想的方法。 首先安装Wsl，在Windows开始中搜索：“程序与功能”，勾选“适用于Linux的Windows子系统”。下载Archlinux镜像，解压到文件夹，打开Arch.exe，等待安装完成。 Archlinux刚开始只有一个root，我习惯先新建一个用户，你也可以直接使用root。新建用户命令如下： useradd -m -G wheel -s /bin/bash [用户名] passwd [用户名] visudo 找到这么一行#%wheel ALL=(ALL) ALL，将全面的#去掉，用户就创建好了，然后使用下面的命令切换到此用户的主目录： su [用户名] cd ~ 下面配置pacman， sudo pacman-key --init sudo pacman-key --populate sudo vim /etc/pacman.d/mirrorlist 找到mirrorlist里China那一组，找几个离你比较近的源，把前面的#去掉，然后用下面的命令更新软件包缓存： sudo pacman -Syy 下面安装Ocaml必须的软件， sudo pacman -S ocaml # opam是ocaml的包管理工具，类似python的pip，java的maven sudo pacman -S opam sudo pacman -S patch sudo pacman -S m4 sudo pacman -S make sudo pacman -S gcc 接着，初始化opam， # wsl系统需要加上--disable-sandboxing选项 opam init --disable-sandboxing # 可以将下面的命令加到.bashrc文件中，不用每次手动执行了 eval $(opam env) # 下面是ocaml格式化和代码提示所需的工具 opam install merlin opam user-setup install opam install ocp-indent opam user-setup install opam install utop 这些都成功后下载vscode，在Windows上安装，完成后回到Linux执行下面的命令： code . 下面推荐一下几个插件： OCaml and Reason IDE，注意还有一个插件叫OCaml and Reason IDE For Wsl，选那个不带For Wsl Code Runner插件可以方便的运行单文件程序，推荐大家装一下。 ocaml-reason-format，用来格式化代码，OCaml and Reason IDE本身的格式化不太好。 最终的settings.json如下： &quot;editor.fontSize&quot;: 18, &quot;reason.path.ocamlmerlin&quot;: &quot;/home/user/.opam/default/bin/ocamlmerlin&quot;, &quot;reason.path.ocpindent&quot;: &quot;/home/user/.opam/default/bin/ocp-indent&quot;, &quot;editor.formatOnType&quot;: true, &quot;reason.codelens.enabled&quot;: false, // 不显示类型提示 &quot;ocaml-reason-format.ocamlformat&quot;: &quot;/home/user/.opam/default/bin/ocamlformat&quot;, &quot;[ocaml]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;rustykey.vscode-ocaml-reason-format&quot; &#125;, 最后一步了，大家加油！新建一个文件test.ml，将开头的那段Ocaml代码拷进去，新建另一个文件dune，输入下面的内容： (executables (names test)) 在vscode的terminal中执行dune exec ./test.bc，如果看到1 1 2 3 7 10，就说明配置成功了，接下来尽情享受Ocaml带给你不一样的感觉吧！","categories":[],"tags":[{"name":"ocaml","slug":"ocaml","permalink":"https://naosense.github.io/tags/ocaml/"},{"name":"函数式","slug":"函数式","permalink":"https://naosense.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"Java多线程交替打印字符","slug":"Java多线程交替打印字符","date":"2019-06-05T10:13:15.000Z","updated":"2025-09-16T02:08:42.959Z","comments":true,"path":"2019/06/05/Java多线程交替打印字符/","link":"","permalink":"https://naosense.github.io/2019/06/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6/","excerpt":"","text":"有这样一个面试题：多线程打印AB字符 这玩意但凡有点Java基础的人，都会想到这是考察线程wait和notify，那么具体怎么做呢？如果长时间不写多线程程序，冷不丁的来一下，还真写不出。 先来复习下wait、notify的概念： wait: Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed. The current thread must own this object’s monitor. notify: Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the wait methods.This method should only be called by a thread that is the owner of this object’s monitor. notifyAll: Wakes up all threads that are waiting on this object’s monitor. 根据Javadoc的注释，可以看出wait将会让出锁，进入WAITING状态，直到其他线程调用notify(All)，进入AWAKENED状态，在wait最终返回之前，需要获取锁。这意味着，AWAKENED的线程将和BLOCKING状态的线程一起竞争锁，如果竞争不过，继续待在WAITING状态。有几点需要注意： 无论是wait，还是notify(All)，都必须在持有锁的状态下调用 notify(All)调用后不会释放锁，而是在离开syntronized区域后 AWAKENED线程在竞争锁时没有任何优势，和BLOCKING线程优先级一样 wait的使用范式如下： synchronized (obj) &#123; while (&lt;condition does not hold&gt;) obj.wait(); ... // Perform action appropriate to condition &#125; 之所以使用循环条件判断，是为了防止线程过早唤醒，也就是发出notify(All)时条件谓词为真，到wait返回时，谓词不为真了。另外Javadoc指出，WAITING线程会有一定的几率自己醒来，而不是收到notify(All)的通知，虽然这极少发生。 回到最初的问题，可以启动两个线程，为他们分配一个名字name，分别为A和B，设置一个变量ticket保存着下一个可运行的线程名，只有name == ticket的线程才有权运行，这样只要改变ticket的值就可以控制线程的运行了，具体代码如下： public class Main &#123; public static void main(String[] args) &#123; new PrintChar('A').start(); new PrintChar('B').start(); &#125; private static class PrintChar extends Thread &#123; private static final Object lock = new Object(); private static char running = 'A'; private char name; public PrintChar(char name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i&lt;10;i++) &#123; synchronized (lock) &#123; while (name != running) &#123; try &#123; // System.out.print(&quot; &lt;&quot; + name + &quot; waiting&gt; &quot;); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(name); loop(); lock.notify(); &#125; &#125; &#125; private void loop() &#123; if (running == 'B') &#123; running = 'A'; &#125; else &#123; running += 1; &#125; &#125; &#125; &#125; 为了观察线程的运行等待状态，我们将注释放开，得到下面的结果， A &lt;A waiting&gt; B &lt;B waiting&gt; A &lt;A waiting&gt; B &lt;B waiting&gt; A &lt;A waiting&gt; B ... 作为一个问题的延伸，考虑下面的问题： 多线程打印ABCDE 小伙伴们，你想到了吗？","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://naosense.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java HotSpot虚拟机垃圾收集优化指南","slug":"Java HotSpot虚拟机垃圾收集优化指南","date":"2019-05-03T18:39:07.000Z","updated":"2025-09-16T02:08:42.959Z","comments":true,"path":"2019/05/03/Java HotSpot虚拟机垃圾收集优化指南/","link":"","permalink":"https://naosense.github.io/2019/05/03/Java%20HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/","excerpt":"","text":"现在不懂点虚拟机都不好意思说是Java程序员了，这方面的文章不少，但质量参差不齐。在百度谷歌上看了一圈大部分是你抄我我抄你，要不就是泛泛而谈，看完之后还是一头雾水，看到Oracle官网上有一篇将虚拟机调优的文章Garbage Collection Tuning不错，有理论有实操，试着翻译下。 1 垃圾收集优化介绍 从桌面上的小应用程序到大型服务器上的网络服务，各种各样的应用都在使用Java SE平台。为了支持多样化的部署，Java HotSpot虚拟机提供了多种垃圾收集器，每个都是为了满足不同的需要而设计的。Java SE根据运行应用程序的计算机的类别选择最合适的垃圾收集器。然而，这种选择并不是对每个应用都是最佳的。具有严格性能或其他要求的用户、开发人员和管理员可能需要显式选择合适的垃圾收集器，并调整某些参数以达到所需的性能水平。本文档提供了帮助完成这些任务的信息。 首先，垃圾收集器的一般特性和基本的调优选项将在串行stop-the-world收集器一节描述。然后介绍其他收集器的具体特征以及选择收集器时要考虑的因素。 本节主题： 什么是垃圾收集器？ 垃圾收集器的选择为什么重要？ 文档中支持的操作系统 什么是垃圾收集器？ 垃圾收集器用来自动管理应用程序的动态内存分配请求。 垃圾收集器通过以下操作执行自动动态内存管理: 从操作系统分配内存和将内存返还给操作系统。 根据应用程序的请求，将内存分配给它。 确定哪些内存还在使用。 回收未使用的内存供应用程序重用。 Java HotSpot垃圾收集器采用各种技术来提高这些操作的效率: 将年代清理与老化结合使用，将精力集中在堆中最有可能包含大量可回收内存的区域。 使用多线程并行操作，或者在应用程序的后台并行执行一些长期运行的操作。 通过压缩存活对象，尝试恢复更大的连续可用内存。 垃圾收集器的选择为什么重要？ 垃圾收集器的目的是将应用程序开发人员从手动动态内存管理中解放出来。开发人员无需关心内存的分配与回收，也不用关注分配的动态内存的生存期。这完全消除了一些与内存管理相关的错误，代价是增加了一些运行时开销。Java HotSpot虚拟机提供了一系列垃圾收集算法可供选择。 垃圾收集器的选择什么时候重要？对于某些应用，答案是永远不会。也就是说，一些应用程序的垃圾收集运行良好，暂停的频率和持续时间适中。然而，对于一大类应用程序，尤其是那些具有大量数据(几十亿字节)、许多线程和高事务率的应用程序，情况并非如此。 Amdahl定律(给定问题中的并行加速受问题串行部分的限制)意味着大多数工作负载不能完全并行化；有些部分总是串行的，并没有从并行中获益。在Java平台中，目前有四种支持的垃圾收集替换方案，除了其中一种串行垃圾收集器serial GC，其他的都能并行化以提高性能。尽可能降低垃圾收集的开销是非常重要的。这可以在下面的例子中看到。 图1-1中的图表模拟了一个理想的系统，除了垃圾收集之外，它是完全可伸缩的。红线表示在单处理器系统上只花费1%时间进行垃圾收集的应用程序。这意味着在拥有32个处理器的系统上，吞吐量损失超过20%。洋红色线显示，对于垃圾收集时间为10%的应用程序(在单处理器应用程序中，垃圾收集时间不算太长)，当扩展到32个处理器时，会损失75%以上的吞吐量。 该图显示，在小型系统上开发时，可以忽略的吞吐量问题可能会成为扩展到大型系统时的主要瓶颈。然而，在减少这种瓶颈方面的微小改进可以带来巨大的性能提升。对于一个足够大的系统，选择合适的垃圾收集器并在必要时对其进行调整变得很有价值。 串行垃圾收集器对于大多数小型应用已经足够了，尤其是那些堆空间约100兆字节的应用。其他收集器有额外的开销或复杂性，这是高级特性的代价。如果应用程序不需要其他收集器的高级特性，使用串行垃圾收集器就可以了。串行垃圾收集器不是最佳选择的一种情况是运行在具有大量内存和两个或更多处理器的机器上的大型多线程应用程序。当应用程序在这样的服务器级计算机上运行时，默认情况下会选择垃圾优先(G1)收集器；参见工效学。 文档中支持的操作系统 本文档及其建议适用于JDK 12支持的所有系统配置，受某些垃圾收集器特定配置实际可用性的限制。请参阅甲骨文JDK认证系统配置。 2 工效学 工效学是指Java虚拟机(JVM)使用启发式垃圾收集方法以(如基于行为的试探法)提高应用程序性能的过程。 JVM为垃圾收集器、堆大小和运行时编译器提供了依赖于平台的默认选择。这些选择兼顾不同类型应用程序的需求，同时只需要较少的命令行调整。此外，基于行为的动态堆大小优化，以满足应用程序的特定行为。 本节描述这些默认选择和基于行为的调整。在使用后续章节中描述的更详细控制之前，使用这些默认值。 本节主题： 垃圾收集器、堆和运行时编译器默认选择 基于行为的优化 最大暂停时间 吞吐量 占用量 调优策略 垃圾收集器、堆和运行时编译器默认选择 下面是重要的垃圾收集器、堆大小和运行时编译器默认选择: 垃圾优先(G1)收集器 垃圾收集线程的最大数量受堆大小和可用CPU资源的限制 堆的初始容量为1/64物理内存 堆的最大容量为1/4物理内存 分层编译器，使用C1和C2 基于行为的优化 Java HotSpot虚拟机垃圾收集器可以配置为优先满足两个目标之一:最大暂停时间和吞吐量。如果达到了首选目标，收集者将尝试最大化另一个目标。当然，这些目标并不总是能够实现的:应用程序需要至少能保存所有存活数据的最小堆，而其他配置可能会阻止实现一些或所有的期望目标。 最大暂停时间 暂停时间是指垃圾收集器停止应用程序并回收非使用空间的持续时间。最大暂停时间目的是限制这些暂停的最长时间。 垃圾收集器维护着暂停时间的平均值和方差。平均值是从应用开始执行时取的，但是它是加权的，所以最近的暂停权重更大。如果暂停时间的平均值加上方差大于最大暂停时间，则垃圾收集器认为目标没有实现。 最大暂停时间是用命令行选项-XX:MaxGCPauseMillis=&lt;nnn&gt;指定的。这被解释为向垃圾收集器提示需要&lt; nnn &gt;毫秒或更少的暂停时间。垃圾收集器会调整Java堆大小和其他与垃圾收集相关的参数，以使垃圾收集暂停时间短于&lt; nnn &gt;毫秒。最大暂停时间的默认值因垃圾收集器而异。这些调整可能会导致垃圾收集的更加频繁，从而降低应用程序的整体吞吐量。然而，在某些情况下，期望的暂停时间目标可能无法实现。 吞吐量 吞吐量目标是以收集垃圾花费的时间来衡量的，垃圾收集之外的时间就是应用程序时间。 吞吐量通过命令选项-XX:GCTimeRatio=nnn指定。垃圾收集时间与应用时间之比为1/ (1+nnn)。例如，-XX:GCTimeRatio=19设置了垃圾收集时间占总时间的1/20或5%。 垃圾收集花费的时间是所有垃圾收集暂停的总时间。如果没有达到吞吐量目标，那么垃圾收集器的一个可能的操作是增加堆的大小，以便在垃圾收集之间的应用程序时间可以更长。 占用量 如果吞吐量和最大暂停时间目标已经达到，那么垃圾收集器会减小堆的大小，直到其中一个目标(总是吞吐量目标)无法达到为止。垃圾收集器可以分别使用-Xms=&lt;nnn &gt;和-Xmx=&lt;mmm &gt;设置为最小和最大堆大小。 调优策略 堆增长或收缩到以支持所选吞吐量。了解堆优化策略，如选择最大堆大小和选择最大暂停时间目标。 除非您确定需要大于堆大小默认值的堆，否则不要为堆选择最大值。为您的应用选择一个足够的吞吐量即可。 应用程序行为的改变会导致堆增长或收缩。例如，如果应用程序开始以更高的速率分配内存，那么堆就会增长以保持相同的吞吐量。 如果堆增长到其最大大小，并且没有达到吞吐量目标，则最大堆大小对于吞吐量目标来说太小。将最大堆大小设置为接近平台上总物理内存但不会导致应用程序交换的值。再次执行应用程序。如果仍然没有达到吞吐量目标，那么应用程序时间的目标对于平台上的可用内存来说太高了。 如果可以达到吞吐量目标，但暂停时间过长，则选择更小的最大暂停时间。选择更小的最大暂停时间可能意味着您的吞吐量无法实现，因此请选择对应用程序来说可以接受的折衷值。 垃圾收集器试图满足竞争目标时，堆的大小通常会发生波动。即使应用程序已经达到稳定状态，也是如此。实现吞吐量目标(可能需要更大的堆)的压力与最大暂停时间和最小占用空间(两者都可能需要更小的堆)的目标相竞争。 3 垃圾收集器实现 Java SE平台的一个优势是它保护开发人员免受内存分配和垃圾收集复杂性的困扰。 然而，当垃圾收集成为主要瓶颈时，理解实现的某些方面是有用的。垃圾收集器对应用程序使用对象的方式进行假设，这些假设反映在可调参数中，这些参数可以在不牺牲抽象能力的情况下进行调整以提高性能。 本节主题： 分代垃圾收集 分代 性能考虑 吞吐量和占用量考量 分代垃圾收集 当运行程序中的任何其他存活对象的任何引用不能再访问一个对象时，它就是一个垃圾，虚拟机可以重用它的内存。 理论上，最简单的垃圾收集算法每次运行时都会遍历每个可到达的对象。其余的对象都被认为是垃圾。这种方法花费的时间与活动对象的数量成正比，这对维护大量存活数据的大型应用程序来说是禁止的。 Java HotSpot虚拟机包含许多不同的垃圾收集算法，这些算法都使用一种称为分代收集的技术。虽然简单的垃圾收集每次都会检查堆中的每个存活对象，但是分代收集利用了在大多数应用程序中观察到的几个经验特性来最小化回收未使用(垃圾)对象所需的工作。这些观察到的特性中最重要的是弱分代假说(weak generational hypothesis)，它指出大多数对象只能存活很短的一段时间。 图3-1中的蓝色区域是对象寿命的典型分布。x轴显示的是对象生命周期。y轴显示的是存活对象的字节数。左边的尖峰代表分配后不久可以回收的对象(换句话说，已经“死亡”)。例如，迭代器对象通常只在单个循环期间有效。 有些对象确实寿命更长，所以分布向右侧延伸。例如，通常有一些在初始化时分配的对象会一直存在，直到虚拟机退出。在这两个极端之间是在运算期间的中间值，在这里被视为初始峰值右侧的块。一些应用程序具有非常不同的分布，但令人惊讶的是，大量应用程序具有这种一般性的形状。通过关注大多数对象“朝生夕死”的事实，有效的收集成为可能。 分代 为了针对这种情况进行优化，内存分几代进行管理(内存池保存不同年龄的对象)。垃圾收集发生在每一代填满时。 绝大多数对象被分配到一个专门用于年轻对象(新生代，young generation)的池中，大多数对象死在那里。当新生代填满时，它会导致一个小规模垃圾收集(minor collection)，它只收集新生代；其他分代的垃圾不会被回收。这种收集的成本首先与被收集的存活对象的数量成比例；充满死亡对象的新生代收集的很快。 通常，在每一次小规模的收集过程中，新生代幸存下来的一些对象会被转移到老年代(old generation)。最后，老年代也会填满并且必须被收集，从而产生一个大规模垃圾收集(major collection)，它将收集整个堆。大规模垃圾收集的持续时间通常比小规模垃圾收集长得多，因为涉及的对象数量要大得多。图3-2显示了串行垃圾收集器(serial garbage collector)中的默认分代排列: 启动时，Java HotSpot虚拟机将整个Java堆保留在地址空间中，除非需要，否则不会为其分配任何物理内存。Java堆的整个地址空间在逻辑上分为新生代和老年代。为对象内存保留的完整地址空间也分为新生代和老年代。 新生代由eden和两个survivor空间组成。大多数对象最初分配在eden中。在任何时候都有一个survivor空间是空的，并且在垃圾收集期间充当eden和另一个survivor空间中存活对象的目标空间；垃圾收集后，eden和源survivor空间是空的。在下一次垃圾收集中，两个survivor空间的角色交换。最近填充的survivor空间将会把存活对象复制到另一个survivor空间。对象以这种方式在两个survivor空间之间来回复制，直到它们被复制了一定次数或者没有足够的空间了。这些对象被复制到老年代。这个过程也被称为老化(aging)。 性能考虑 垃圾收集的主要指标是吞吐量和时延。 吞吐量是指未花费在垃圾收集上的总时间的百分比(即应用程序所占用的时间，译者注)。吞吐量包括分配内存所花费的时间(但通常不需要调整分配速度)。 时延是应用程序的响应能力。垃圾收集会暂停应用程序进而会影响应用程序的响应能力。 用户对垃圾收集有不同的要求。例如，有些人认为网络服务器的正确度量是吞吐量，因为垃圾收集期间的暂停可能是可以容忍的，或者会因为网络延迟而变得模糊不清。然而，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。 一些用户对其他考虑很敏感。占用空间是一个进程的工作集，以页面和缓存行来衡量。在物理内存有限或进程众多的系统上，占用空间可能决定可伸缩性。*及时性(Promptness)*是指对象死亡和内存可用之间的时间，对于包括远程方法调用(Remote Method Invocation, RMI)在内的分布式系统来说，这是一个重要的考虑因素。 一般来说，为特定一代选择大小就是在这些因素之间作权衡。例如，非常大的新生代可能最大化吞吐量，但这样做是以空间占用、及时性和暂停时间为代价的。相反，可以通过减小新生代的空间来换取小的垃圾收集暂停时间，但这会牺牲吞吐量。一代的空间不会影响另一代的收集频率和暂停时间。 没有一种通用的方法可以选择一代的最优空间大小。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并不总是最佳的，可以通过命令行选项修改；请参见影响垃圾收集性能的因素。 吞吐量和占用量考量 吞吐量和占用量最好使用特定于应用的指标来衡量。 例如，可以使用客户端负载生成器测试网络服务器的吞吐量，可以使用pmap命令在Solaris操作系统上测量服务器的占用空间。通过检查虚拟机本身的诊断输出，可以轻松估计垃圾收集导致的暂停时间。 命令行选项-verbose:gc在每次垃圾收集中打印关于堆和垃圾收集的信息。下面是一个例子: [15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M-&gt;57M(307M) (15,646s, 15,651s) 5,048ms [16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M-&gt;57M(307M) (16,146s, 16,162s) 16,565ms [16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M-&gt;31M(104M) (16,202s, 16,367s) 164,581ms 输出显示了两次新生代的垃圾收集，之后是应用程序调用System.gc()启动的完整垃圾收集(Full GC)。这些行以时间戳开始，该时间戳表示应用程序启动的时间。接下来是关于该行的日志级别(信息)和标签(gc)的信息。随后是垃圾收集识别号。在这种情况下，有三个编号为36、37和38的垃圾收集。然后记录的是垃圾收集类型和原因。之后，会记录一些关于内存消耗的信息。该日志使用“在垃圾收集之前使用堆大小”-&gt;“在垃圾收集之后使用堆大小”的格式。 在示例的第一行中，是239兆-&gt;57M(307兆)，这意味着在垃圾收集清除大部分内存之前使用了239兆字节，但是收集之后保留了57兆字节。堆大小为307兆字节。请注意，在此示例中，完整的垃圾收集将堆从307兆字节缩减到104兆字节。在内存使用信息之后，将记录垃圾收集的开始和结束时间以及持续时间(结束-开始)。 -verbose:gc命令是-Xlog:gc的别名。-Xlog是用于HotSpot JVM的通用日志配置选项。这是一个基于标签的系统，其中gc是标签之一。要获得更多关于垃圾收集正在做什么的信息，您可以配置日志来打印任何带有垃圾收集标签和任何其他标签的消息。该命令的命令行选项是-Xlog:gc*。 下面是一个用-Xlog:gc*配置的G1收集器新生代垃圾收集的例子: [10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause) [10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation [10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms [10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms [10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms [10.191s][info][gc,phases ] GC(36) Other: 0.2ms [10.191s][info][gc,heap ] GC(36) Eden regions: 286-&gt;0(276) [10.191s][info][gc,heap ] GC(36) Survivor regions: 15-&gt;26(38) [10.191s][info][gc,heap ] GC(36) Old regions: 88-&gt;88 [10.191s][info][gc,heap ] GC(36) Humongous regions: 3-&gt;1 [10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K-&gt;8152K(1056768K) [10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M-&gt;114M(508M) 13.075ms [10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s 注意：由-Xlog:gc*生成的输出格式可能会在未来版本中发生变化。 4 影响垃圾收集性能的因素 影响垃圾收集性能的两个最重要的因素是总的可用内存和新生代的比例。 本节内容： 总的可用内存 影响分代大小的选项 堆的默认大小 通过最小化Java堆大小来节省动态占用空间 新生代 新生代大小选项 survivor空间大小 总的可用内存 影响垃圾收集性能的最重要因素是总可用内存。因为收集发生在分代空间占满时，吞吐量与可用内存量成反比。 注意：以下关于堆的增长和收缩、堆布局和默认值的讨论以串行垃圾收集器为例。虽然其他收集器使用类似的机制，但这里提供的细节可能不适用于其他收集器。有关其他收集器的类似信息，请参考各自的主题。 影响分代大小的选项 许多选项会影响分代大小。图4-1展示了堆中提交空间和虚拟空间之间的区别。虚拟机初始化时，堆的整个空间都会被保留。保留空间的大小可以用-Xmx选项指定。如果-Xms参数的值小于-Xmx参数的值，则不是所有保留的空间都会立即提交给虚拟机。在此图中，未提交的空间标记为“虚拟”。堆的不同部分，即新生代和老年代，可以根据需要增加到虚拟空间的极限。 一些参数可以设置堆的一部分与另一部分的比率。例如，参数–XX:NewRatio表示老年代与新生代的相对大小。 堆的默认大小 默认情况下，虚拟机会在每次垃圾收集时增大或缩小堆，以尝试将每次收集中存活对象的可用空间比例维持在特定范围内。 该范围为选项-XX:MinHeapFreeRatio= &lt;最小值&gt;和-XX:MaxHeapFreeRatio= &lt;最大值&gt;设置的百分比，堆的总大小以–Xms &lt;最小值&gt;为界，以–Xmx &lt;最大值&gt;为界。64位Solaris操作系统(SPARC平台版)的默认选项如表4-1所示。 选项 默认值 -XX:MinHeapFreeRatio 40 -XX:MaxHeapFreeRatio 70 -Xms 6656 KB -Xmx 计算得到 有了这些选项，如果某一代的可用空间低于40%，则会扩展堆空间以保持40%的可用空间，一直到这一代的最大允许大小。类似地，如果空闲空间超过70%，那么这一代空间将收缩，使得只有70%的空间是空闲的，这取决于这一代空间的最小尺寸。 如表4-1所示，默认的最大堆大小是由JVM计算的值。Java SE中用于并行收集器(Parallel collector)的计算现在被用于所有垃圾收集器。计算的一部分是64位平台的最大堆大小上限。请参见大小并行垃圾收集器默认堆。客户端模式的JVM也有类似的计算，只不过最大堆大小小于服务器模式的JVM。 以下是关于服务器应用程序堆大小的一般准则: 除非暂停有问题，否则请尝试向虚拟机授予尽可能多的内存。默认大小通常太小。 将-Xms和-Xmx设置为相同的值可以通过从虚拟机中删除最重要的规模调整策略来提高可预测性。但是，如果您做出错误的选择，虚拟机将无法进行补偿。 通常，增加处理器数量同时也要增加内存，因为内存分配可以并行进行。 通过最小化Java堆大小来节省动态占用空间 如果您需要最小化应用程序的动态内存占用(执行期间消耗的最大内存)，那么您可以通过最小化Java堆大小来实现这一点。Java SE嵌入式应用程序可能需要这一点。 通过降低命令行选项-XX:MinHeapFreeRatio(默认值为40%)和-XX:MaxHeapFreeRatio(默认值为70%)的值，从而最小化Java堆大小。将-XX:MaxHeapFreeRatio降低到低至10%，-XX:MinHeapFreeRatio已证明能够成功地减小堆大小，而且不会造成太大的性能降低；但是，最终的结果可能取决于你的应用。 此外，您可以指定-XX:-ShrinkHeapInSteps，它会立即将Java堆减小到目标大小(由参数-XX:MaxHeapFreeRatio指定)。此设置可能会导致性能下降。默认情况下，Java运行时会逐渐将Java堆减小到目标大小；这个过程需要多个垃圾收集周期。 新生代 在总可用内存之后，影响垃圾收集性能的第二个最大影响因素是专用于新生代的比例。 新生代越大，小规模收集就越少。然而，对于给定的堆大小，较大的新生代意味着较小的老年代，这将增加大规模收集的频率。最佳选择取决于应用程序对象的生命周期分布。 新生代大小选项 默认情况下，新生代的大小由选项-XX:NewRatio控制。 例如，设置-XX:NewRatio=3意味着新生代和老年代之间的比率是1:3。换句话说，eden和survivor空间总的大小将是总堆大小的四分之一。 选项-XX:NewSize和-XX:MaxNewSize指定了新生代的大小下界和上界。将它们设置为相同的值新生代就是固定值，正如将-Xms和-Xmx设置为相同的值可以固定总的堆大小一样。这有助于以比-XX:NewRatio更精细的粒度调整新生代。 survivor空间大小 您可以使用选项-XX:SurvivorRatio来调整survivor空间的大小，但这通常对性能并不重要。 例如，-XX:SurvivorRatio=6将eden和survivor空间之间的比率设置为1:6。换句话说，每个survivor空间将是eden大小的六分之一，也就是新生代大小的八分之一(不是七分之一，因为有两个survivor空间)。 如果survivor空间太小，那么将会直接复制到老年代。如果幸存者空间太大，那么将会有很多空间永远不会使用。在每次垃圾收集时，虚拟机都会选择一个阈值，即一个对象在其转移到老年代之前可以复制的次数。选择这个阈值是为了让survivor保持半饱和状态。您可以使用日志配置-Xlog:gc，age可以用来显示这个阈值和新生代对象的年龄。它对于观察应用程序的生命周期分布也很有用。 表4-2提供了64位Solaris的默认值。 选项 默认值 -XX:NewRatio 2 -XX:NewSize 1310 MB -XX:MaxNewSize not limited -XX:SurvivorRatio 8 新生代的最大大小是根据总堆的最大大小和-XX:NewRatio参数的值计算的。-XX:MaxNewSize参数的“无限制”意味着计算不限制，除非命令行上指定了-XX:MaxNewSize的值。 以下是服务器应用程序的一般指南: 首先决定您可以为虚拟机提供的最大堆大小。然后，根据新生代的规模制定您的性能指标，以找到最佳设置。 请注意，最大堆大小应始终小于机器上安装的内存量，以避免过多的页面错误和抖动。 如果总堆大小是固定的，那么增加新生代的大小需要减少老年代的大小。保持老一代足够大，以容纳应用程序在任何给定时间使用的所有存活数据，加上一定量的富余空间(10%到20%或更多)。 根据前面提到的对老年代的限制: 给予新生代足够的内存。 增加处理器数量的同时增加新生代的规模，因为分配可以并行化。 5 可用收集器 本节主题： 串行收集器(Serial Collector) 并行收集器(Parallel Collector) 主要并发收集器(The Mostly Concurrent Collectors) 选择收集器 串行收集器(Serial Collector) 串行收集器使用单个线程来执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。 它最适合单处理器机器，尽管它对于具有小数据集(大约100兆字节)的应用程序在多处理器上很有用，但它不能利用多处理器硬件的优势。默认情况下，串行收集器是在某些硬件和操作系统配置上的默认选择，或者通过选项-XX:+UseSerialGC显式启用。 并行收集器(Parallel Collector) 并行收集器也称为吞吐量收集器，它是与串行收集器相似的一代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个线程用于加快垃圾收集。 并行收集器适用于运行在多处理器或多线程硬件上具有大中型数据集的应用程序。您可以通过使用-XX:+UseParallelGC选项来启用它。 并行压缩是一项使并行收集器能够并行执行大规模垃圾收集的功能。如果没有并行压缩，大规模垃圾收集是使用单个线程来执行的，这可能会极大地限制可伸缩性。如果指定了选项-XX:+UseParallelGC，则默认情况下启用并行压缩。您可以通过使用-XX:-UseParallelOldGC选项来禁用它。 主要并发收集器(The Mostly Concurrent Collectors) 并发标记清除(CMS)收集器和垃圾优先(G1)垃圾收集器是两个主要并发收集器。大多数并发收集器并发执行一些代价较高应用程序工作。 G1垃圾收集器:这种服务器风格的收集器是为具有大内存、多处理器机器设计的。为了满足垃圾收集暂停时间目标的同时实现高吞吐量。 在某些硬件和操作系统配置上默认选择G1，或者可以使用-XX:+UseG1GC显式启用。 CMS收集器:这个收集器是为那些更喜欢较短垃圾收集暂停时间的应用程序设计的，并且能够与垃圾收集共享处理器资源。使用-XX:+UseConcMarkSweepGC启用CMS收集器。 CMS收集器在JDK 9中被标记为弃用。 Z收集器 Z垃圾收集器(ZGC)是一个可扩展的低延迟垃圾收集器。ZGC同时执行所有代价高昂的工作，同时不停止应用程序线程的执行。 ZGC适用于需要低时延(暂停时间不到10 ms)和/或特大堆(几T字节)的应用。您可以通过使用-XX:+UseZGC选项来启用。 从JDK 11开始，ZGC作为一个实验的特性的出现。 选择收集器 除非您的应用程序有相当严格的暂停时间要求，否则首先运行您的应用程序，并允许虚拟机选择收集器。 如有必要，调整堆大小以提高性能。如果性能仍然达不到您的目标，请使用以下准则作为选择收集器的出发点: 如果应用程序有一个小数据集(高达大约100兆字节)，则使用选项-XX:+UseSerialGC选择串行收集器。 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有选项-XX:+UseSerialGC的串行采集器。 如果(a)应用程序性能峰值是第一优先事项，并且(b)没有暂停时间要求，或者一秒钟或更长的暂停时间是可接受的，则让虚拟机选择收集器或使用-XX:+UseParallelGC选择并行收集器。 如果响应时间比总吞吐量更重要，并且垃圾收集暂停时间必须保持在大约一秒钟以内，则选择一个具有-XX:+UseG1GC或-XX:+UseConcMarkSweepGC的主要并发收集器。 如果响应时间是一个高优先级，和/或您正在使用一个非常大的堆，那么选择一个具有-XX:UseZGC的完全并发收集器。 这些准则只是选择收集器的出发点，因为性能取决于堆的大小、应用程序维护的存活数据量以及可用处理器的数量和速度。 如果推荐的收集器没有达到期望的性能，那么首先尝试调整堆和各个分代的大小以满足期望的目标。如果性能仍然不足，请尝试不同的收集器:使用并发收集器减少暂停时间，使用并行收集器增加多处理器硬件上的总吞吐量。 6 并行收集器(The Parallel Collector) 并行收集器(这里也称为吞吐量收集器)是一个类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个线程用于加快垃圾收集。 并行收集器通过命令行选项-XX:+UseParallelGC启用。默认情况下，使用此选项，大规模收集和小规模收集并行运行，以进一步减少垃圾收集开销。 本节主题： 并行收集器垃圾收集器线程的数量 并行收集器中的分代排列 并行收集器工效学 指定并行收集器行为选项 并行收集器指标的优先级 并行收集器各个分代空间调整 并行收集器默认堆大小 并行收集器初始和最大堆大小的规范 过多的并行收集器时间和内存不足错误 并行收集器度量 并行收集器垃圾收集器线程的数量 在硬件线程数N大于8(感觉这里应该说的是CPU的个数，译者加)的机器上，并行收集器使用硬件线程数的固定比例作为垃圾收集器线程数。 对于较大的N值，比例为5/8。当小于8时，线程等于N。在特定的平台上，这一比例降至5/16。垃圾收集器线程的具体数量可以通过命令行选项进行调整(将在后面描述)。在只有一个处理器的主机上，由于并行执行(例如同步)所需的开销，并行收集器的性能可能不如串行收集器。但是，当具有中型到大型堆的应用程序时，运行在具有两个处理器的计算机上，它通常比串行收集器性能略好，并且当有两个以上的处理器可用时，它通常比串行收集器性能好得多。 垃圾收集器线程的数量可以通过命令行选项-XX:ParallelGCThreads=&lt;N&gt;来控制。如果使用命令行选项调整堆，那么并行收集器获得良好性能所需的堆大小与串行收集器所需的大小相同。但是，启用并行收集器应该会缩短收集暂停时间。因为多个垃圾收集线程同时参与一个小规模收集，所以在收集过程中，从新生代到老年代的升级可能会导致一些碎片。大规模收集中涉及的每个垃圾收集线程都会保留老年代的一部分用于升级，将可用空间划分到这些“升级缓冲区”会导致碎片效应。减少垃圾收集器线程的数量和增加老年代的大小将减少这种碎片效应。 并行收集器中的分代排列 在并行收集器中，分代的排列是不同的。 这种布置如图6-1所示: 并行收集器人机工程学 当使用-XX:+UseParallelGC选择并行收集器时，它启用了一种自动优化方法，允许您指定行为，而不是分代大小和其他低级优化细节。 指定并行收集器行为的选项 您可以指定最大垃圾收集暂停时间、吞吐量和占用空间(堆大小)。 最大垃圾收集暂停时间:最大暂停时间是用命令行选项-XX:MaxGCPauseMillis=&lt;N&gt;指定的。这被解释为需要N毫秒或更少的暂停时间；默认情况下，没有最大暂停时间。如果指定了暂停时间，将调整堆大小和其他与垃圾收集相关的参数，以使垃圾收集暂停时间短于指定值；然而，期望的暂停时间目标可能并不总能实现。这些调整可能会导致垃圾收集器降低应用程序的总吞吐量。 吞吐量:吞吐量目标是根据垃圾收集花费的时间与垃圾收集之外花费的时间(称为应用程序时间)来衡量的。目标由命令行选项-XX:GCTimeRatio=&lt;N&gt;指定，该选项将垃圾收集时间与应用程序时间的比率设置为1 / (1 + N)(感觉应该是垃圾收集与总时间的比率，译者注)。例如，-XX:GCTimeRatio=19设置了垃圾收集总时间的1/20或5%的目标。默认值为99，因此垃圾收集的时间目标为1%。 占用空间:最大堆占用空间是使用选项-Xmx指定的。此外，收集器有一个隐含的目标，只要满足其他目标，就要最小化堆的大小。 并行收集器指标的优先级 目标按最大暂停时间指标、吞吐量指标和最小占用空间指标顺序排列：首先要满足最大暂停时间指标，只有当最大暂停时间指标达到后才会去实现吞吐量的指标，同样只有前两个指标满足后才会考虑占用空间的指标。 并行收集器各个分代空间调整 收集器保存的平均暂停时间等统计信息会在每次收集结束时更新。 进行测试以确定目标是否已经实现，并对一代的空间进行任何必要的调整。例外情况是显式垃圾收集，例如，在保存统计信息和调整代的大小方面，将会忽略System.gc()调用的影响。 各代大小的增加和缩小是通过各代大小的固定百分比的增量来完成的，以便各个分代朝着其期望的大小递增或递减。默认情况下，一代以20%的增量增长，以5%的增量收缩。新生代和老年代的增长比例分别可以通过-XX:YoungGenerationSizeIncrement=&lt;Y&gt;和-XX:TenuredGenerationSizeIncrement=&lt;T&gt;指定。收缩比例通过-XX:AdaptiveSizeDecrementScaleFactor=&lt;D&gt;进行调整，如果增长比例是X%，那么收缩比例为X/D%。 如果收集器在启动时增加一代的大小，那么增量中会添加一个额外的百分比。这个百分比将会随着垃圾收集次数的增加而衰减，并不会长期存在。补充的目的是提高启动性能。收缩的百分比没有补充。 如果没有达到最大暂停时间目标，那么一次只能缩小一代的规模。如果两代的暂停时间都超过了目标，那么暂停时间较长的一代的规模将首先缩小。 如果吞吐量目标没有实现，那么两代的规模都会增加。每一个都按其对总垃圾收集时间的贡献比例增加。例如，如果新生代的垃圾收集时间是总收集时间的25%，如果新生代的完整增量是20%，那么新生代将增加5%。 并行收集器默认堆大小 除非命令行中指定了初始堆大小和最大堆大小，否则它们是根据计算机上的内存量计算的。默认的最大堆大小是物理内存的四分之一，而初始堆大小是物理内存的六分之一。分配给新生代的最大空间量是总堆大小的三分之一。 并行收集器初始和最大堆大小的规范 您可以使用选项-Xms(初始堆大小)和-Xmx(最大堆大小)指定初始和最大堆大小。 如果您知道您的应用程序需要多少堆才能正常工作，那么您可以将-Xms和-Xmx设置为相同的值。如果您不知道，那么JVM将从使用初始堆大小开始，然后增加Java堆，直到找到堆使用和性能之间的平衡。 其他参数和选项会影响这些默认值。要验证默认值，请使用-XX:+PrintFlagsFinal选项，并在输出中查找-XX:MaxHeapSize。例如，在Linux或Solaris上，您可以运行以下程序: java -XX:+PrintFlagsFinal &lt;GC options&gt; -version | grep MaxHeapSize 过多的并行收集器时间和内存不足错误 如果在垃圾收集中花费了太多时间，并行收集器将抛出OutOfMemoryError。 如果总时间的98%以上花在垃圾收集上，并且回收的堆少于2%，则抛出OutOfMemoryError。此功能旨在防止应用程序长时间运行，同时由于堆太小而几乎没有进展。如有必要，可以通过向命令行添加选项-XX:-UseGCOverheadLimit来禁用此功能。 并行收集器度量 并行收集器的详细垃圾收集器输出与串行收集器的输出基本相同。 7 主要并发收集器 主要并发收集器对应用程序并发执行收集工作，因此得名。Java HotSpot虚拟机包括两个主要并发的收集器: 并发标记清除(CMS)收集器:该收集器适用于那些更喜欢较短垃圾收集暂停时间并且能够与垃圾收集共享处理器资源的应用程序。 垃圾优先(G1)垃圾收集器:这种服务器风格的收集器适用于具有大量内存的多处理器机器。它旨在满足垃圾收集暂停时间目标，同时实现高吞吐量。 主要并发收集器的开销 主要并发收集器会占用处理器资源(原本应用程序可以使用这些资源)，以缩短主要收集暂停时间。 最明显的开销是在收集的并发部分使用一个或多个处理器。在N处理器系统中，垃圾收集的并发部分可用处理器个数为K/N，其中1 &lt;= K &lt;=&#123;N/4&#125;。除了在并发阶段使用处理器之外，启用并发还会产生额外的开销。因此，虽然并发收集器的垃圾收集暂停时间通常要短得多，但应用程序吞吐量也往往比其他收集器略低。 在具有多个处理核心的机器上，处理器在收集的并发部分也可用于应用程序线程，因此并发垃圾收集器线程不会暂停应用程序。这通常会导致更短的暂停时间，但是应用程序可用的处理器资源也更少，而且会有一些减速，尤其是在应用程序最大限度地使用所有处理核心的情况下。随着N的增加，由于并发垃圾收集导致的处理器资源减少变得更小，并发收集的好处也增加了。请参阅并发模式故障，其中讨论了这种模式的潜在限制。 因为在并发阶段至少有一个处理器用于垃圾收集，所以并发收集器通常在单处理器(单核)机器上不会提供任何好处。 8 并发标记清除收集器 并发标记清除(CMS)收集器是为那些喜欢较短垃圾收集暂停时间的应用程序设计的，并且能够在应用程序运行时与垃圾收集器共享处理器资源。 典型地，具有相对较大的长寿命数据集(大的老年代)并且运行在具有两个或更多处理器的机器上的应用程序倾向于受益于该收集器的使用。CMS收集器使用-XX:+UseConcMarkSweepGC启用。 不推荐使用CMS收集器。强烈考虑改用垃圾优先收集器。 本节主题： 并发标记清除收集器的性能和结构 并发模式故障 过多的垃圾收集时间过长和内存不足错误 并发标记清除收集器和浮动垃圾 并发标记清除收集器暂停 并发标记清除收集器并发阶段 启动并发收集周期 计划暂停 并发标记清除收集器度量 并发标记清除收集器的性能和结构 与其他可用的收集器相似，CMS收集器是分代的；因此，小规模收集和大规模收集都会发生。CMS收集器试图通过使用单独的垃圾收集线程，在执行应用程序线程的同时，跟踪可到达的对象来减少大规模收集的暂停时间。 在每次大规模收集中，CMS收集器会在收集开始时暂停所有应用程序线程一段时间，在收集期间再次暂停。第二次暂停往往比第一次长。多个线程在两次暂停期间执行收集工作。一个或多个垃圾收集线程完成剩余的收集工作(包括大部分对存活对象的跟踪和对不可达对象的清除)。小规模收集可以与正在进行的大规模收集交叉进行，并且以类似于并行收集的方式完成(特别是小规模收集暂停期间)。 并发模式故障 CMS收集器使用一个或多个垃圾收集器线程，这些线程与应用程序线程同时运行，目的是在老年代变满之前完成老年代的收集。 如前所述，在正常操作中，CMS收集器在应用程序线程仍在运行的情况下执行大部分跟踪和扫描工作，因此应用程序线程只能看到短暂的暂停。但是，如果CMS收集器无法在老年代填满之前回收不可访问的对象，或者如果内存分配不能满足老年代中的可用空闲空间，则应用程序会暂停，并且收集会在所有应用程序线程停止的情况下完成。无法并发完成收集被称为并发模式故障(concurrent mode failure)，意味着需要调整CMS收集器参数。如果并发收集被显式垃圾收集(System.gc())或为诊断工具的垃圾收集中断，则报告一个并发模式中断。 过多的垃圾收集时间过长和内存不足错误 如果在垃圾收集中花费了太多时间，如果总时间的98%以上花费在垃圾收集中，并且恢复的堆少于2%，则抛出OutOfMemoryError。 此功能旨在防止应用程序长时间运行，同时由于堆太小而几乎没有进展。如有必要，可以通过向命令行添加选项-XX:-UseGCOverheadLimit来禁用此功能。 该策略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入98%的时间限制。换句话说，只有在应用程序停止时执行的收集才会计入过多的垃圾收集时间。这种收集通常是由于并发模式故障或显式收集请求(例如，对System.gc()的调用)。 并发标记清除收集器和浮动垃圾 同Java HotSpot虚拟机中的所有其他收集器一样，CMS收集器是一个跟踪收集器，它需要标识堆中所有可到达的对象。 理查德·琼斯和拉斐尔·林在他们的出版物《垃圾收集:自动动态内存算法》中说，这是一个增量更新收集器。因为应用程序线程和垃圾收集器线程在主要收集过程中同时运行，垃圾收集器线程跟踪的对象可能随后在收集过程结束时变得不可访问。这种尚未被回收的不可达对象被称为浮动垃圾。浮动垃圾的数量取决于并发收集周期的持续时间和应用程序引用更新的频率，也称为突变(mutations)。此外，因为新生代和老年代是独立收集的，彼此互为可达性分析的根(root)。作为一个粗略的指导方针，试着将老年代的空间增加20%，以解决漂浮垃圾的问题。一个并发收集周期结束时堆中的浮动垃圾将在下一个收集周期中收集。 并发标记清除收集器暂停 CMS收集器在并发收集周期内暂停应用程序两次。第一个暂停是将从根(例如，来自应用程序线程堆栈和寄存器的对象引用、静态对象等)和堆中其他地方(例如，新生代)直接可达对象标记为存活对象。 第一次暂停称为初始标记暂停(initial mark pause)。第二次暂停发生在并发跟踪阶段的末尾，并在CMS收集器完成对对象的跟踪后，查找由于应用程序线程更新对象中的引用而被并发跟踪遗漏的对象。第二次暂停称为备注暂停(remark pause)。 并发标记清除收集器并发阶段 可达对象图的并发跟踪发生在初始标记暂停和备注暂停之间。 在这个并发跟踪阶段，一个或多个并发垃圾收集器线程可能在使用处理器，原本这些资源对于应用程序是可用的。因此，即使应用程序线程没有暂停，在此阶段和其他并发阶段，应用程序的吞吐量也会相应降低。备注暂停后，并发清理阶段收集不可达的对象。收集周期完成后，CMS收集器等待，几乎不消耗计算资源，直到下一个主要收集周期开始。 启动并发收集周期 对于串行收集器，每当老年代变满，所有应用程序线程都停止，开始一次大规模收集。相比之下，CMS收集器中并发收集的开始时间必须确保收集能够在老年代变满之前完成；否则，由于并发模式故障，应用程序会观察到较长的暂停时间。有几种方法可以开始并发收集。 根据最近的历史记录，CMS收集器会对老年代耗尽之前剩余的时间以及并发收集周期所需的时间进行估计。使用这些动态估计，开始并发收集周期，目的是在老年代耗尽之前完成收集周期。为了安全起见，对这些估计留有余量，因为并发模式故障的代价可能非常高。 如果老年代的占用率超过初始占用率(老年代的百分比)，并发收集也会开始。启动并发周期的默认值约为92%，但该值会随版本的不同而变化。该值可以使用命令行选项-XX:CMSInitiatingOccupancyFraction=&lt;N&gt;手动调整，其中N是老年代大小的整数百分比(0到100)。 计划暂停 新生代和老年代的暂停是独立发生的。 它们不会重叠，但可能会快速连续发生，一次收集的暂停，紧接着另一次收集的暂停，看起来可能是一个更长的暂停。为了避免这种情况，CMS收集器试图将备注暂停安排在上一次和下一次新生代代暂停的中间。当前没有为初始标记暂停进行这种调度，初始标记暂停通常比备注暂停短得多。 并发标记清除收集器度量 以下是带有选项-Xlog:gc的CMS收集器的输出: [121,834s][info][gc] GC(657) Pause Initial Mark 191M-&gt;191M(485M) (121,831s, 121,834s) 3,433ms [121,835s][info][gc] GC(657) Concurrent Mark (121,835s) [121,889s][info][gc] GC(657) Concurrent Mark (121,835s, 121,889s) 54,330ms [121,889s][info][gc] GC(657) Concurrent Preclean (121,889s) [121,892s][info][gc] GC(657) Concurrent Preclean (121,889s, 121,892s) 2,781ms [121,892s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s) [121,949s][info][gc] GC(658) Pause Young (Allocation Failure) 324M-&gt;199M(485M) (121,929s, 121,949s) 19,705ms [122,068s][info][gc] GC(659) Pause Young (Allocation Failure) 333M-&gt;200M(485M) (122,043s, 122,068s) 24,892ms [122,075s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s, 122,075s) 182,989ms [122,087s][info][gc] GC(657) Pause Remark 209M-&gt;209M(485M) (122,076s, 122,087s) 11,373ms [122,087s][info][gc] GC(657) Concurrent Sweep (122,087s) [122,193s][info][gc] GC(660) Pause Young (Allocation Failure) 301M-&gt;165M(485M) (122,181s, 122,193s) 12,151ms [122,254s][info][gc] GC(657) Concurrent Sweep (122,087s, 122,254s) 166,758ms [122,254s][info][gc] GC(657) Concurrent Reset (122,254s) [122,255s][info][gc] GC(657) Concurrent Reset (122,254s, 122,255s) 0,952ms [122,297s][info][gc] GC(661) Pause Young (Allocation Failure) 259M-&gt;128M(485M) (122,291s, 122,297s) 5,797ms 注意：CMS收集器的输出(GC标识657)与小规模收集的输出(GC标识658、659和660)穿插在一起；通常，会有多次小规模收集发生在并发收集周期中。初始标记暂停(Pause Initial Mark)表示并发收集周期的开始。以Concurrent为开头的行表示并发阶段的开始和结束。Pause Remark是备注暂停。前面没有讨论预清洗阶段。预清洗是指在准备备注暂停阶段可以同时完成的工作。最后阶段由并发重置指示(Concurrent Reset)，并为下一个并发收集做准备。 初始标记暂停通常相对于小规模收集暂停时间较短。并发阶段(并发标记、并发预清洗和并发清除)通常持续的时间比小规模收集暂停时间长得多，如CMS收集器输出示例所示。但是，请注意，在这些并发阶段，应用程序不会暂停。备注暂停的长度通常相当于一次小规模收集。备注暂停受某些应用程序特征(例如，对象修改率提高会增加暂停)和自上次小规模收集以来的时间(例如，新生代中的更多对象可能会增加暂停)的影响。 9 垃圾优先收集器 本节介绍垃圾优先(G1)收集器。 本节主题： 垃圾优先收集器简介 启用垃圾优先收集器 基本概念 堆布局 垃圾收集周期 深入垃圾优先收集器内部 确定初始堆占用率 标记 堆资源紧张下的行为 大对象 纯新生代收集阶段规模 空间回收阶段收集规模 G1的工程学默认值 与其他收集器的对比 垃圾优先收集器简介 垃圾优先(G1)收集器针对具有大量内存的多处理器机器。它试图高概率地达到垃圾收集暂停时间目标，同时无需配置就能实现高吞吐量。G1旨在利用应用程序和环境在延迟和吞吐量之间实现最佳平衡，这些应用程序和环境的功能包括: 堆大小高达几十GB或更大，超过50%的Java堆被存活数据占据。 随着时间的推移，对象分配和升级的速率可能会有很大变化。 堆中有大量碎片。 可预测的暂停时间，不超过几百毫秒，避免长时间的垃圾收集暂停。 G1取代了并发标记清除(CMS)收集器。它也是默认的收集器。 G1采集器实现了高性能，并试图通过以下几节中描述的几种方式来实现暂停时间目标。 启用垃圾优先收集器 垃圾优先垃圾收集器是默认收集器，因此通常您不必执行任何额外的操作。您可以通过在命令行上提供-XX:+UseG1GC来显式启用它。 基本概念 G1是一个分代的、渐进的、并发的、疏散垃圾收集器，它监控每次stop-the-world暂停中的暂停时间目标。与其他收集器一样，G1将这堆分成(虚拟的)新生代和老年代。空间回收工作集中在最有效的新生代，而老年代偶尔才会进行空间回收。 为了提高吞吐量，有些操作总是在stop-the-world时执行。其他操作(如全局标记等整体堆操作)可能需要更多时间将与应用程序并行执行。为了让空间回收时stop-the-world的时间更短，G1逐步并行地进行空间回收。G1通过跟踪关于先前应用程序行为和垃圾收集暂停的信息来建立相关成本的模型，从而实现可预测性。它使用这些信息来调整暂停中完成的工作。例如，G1首先回收最高效区域的空间(即大部分被垃圾填满的区域，因此得名)。 G1主要通过疏散来回收空间:将选定存储区域中的存活对象复制到新的存储区域中，在这个过程中对它们进行压缩。疏散完成后，先前由存活对象占据的空间将重新分配给应用程序。 垃圾优先收集器不是实时收集器。它试图在更长的时间内高概率地达到设定的暂停时间目标，但对于给定的暂停并不总是能达到的。 堆布局 G1将堆分成一组大小相等的堆区域(region)，每个区域都是一个连续的虚拟内存范围，如图9-1所示。区域是内存分配和内存回收的单位。在任何给定的时间，这些区域中的每一个都可以是空的(浅灰色)，或者分配给特定的一代，新生的或老年的。当内存请求进来时，内存管理器会分配空闲区域。内存管理器将它们分配给一代，然后将它们作为空闲空间返给应用程序，应用程序可以将它们分配给自己。 新生代包含eden区域(红色)和survivor区域(红色带“S”)。这些区域提供了与其他收集器中连续空间相同的功能，不同之处在于，在G1，这些区域通常在内存中以不连续的模式排列。(浅蓝色)组成了老年代。对于跨越多个区域的对象，老年代区域可能非常大(浅蓝色，带“H”)。 一个应用程序总是先分配给新生代，也就是eden区域，除了那些被直接分配给老年代的巨大对象。 垃圾收集周期 在高层次上，G1收集器在两个阶段之间交替。纯年轻阶段(young-only)包含垃圾收集，这些垃圾收集逐渐用老年代中的对象填充当前可用的内存。空间回收阶段(space-reclamation)，G1除了处理新生代的事务外，还逐步回收老年代的空间。然后，循环从一个纯新生代的阶段重新开始。 图9-2给出了这个循环的概述，并举例说明了可能发生的垃圾收集暂停序列: 下面的列表详细描述了G1垃圾收集周期的各个阶段、它们的暂停以及各个阶段之间的过渡: 纯年轻阶段:这个阶段从几个普通的收集开始，这些收集将对象升级到老年代。纯年轻阶段和空间回收阶段之间的过渡开始于老年代占用率达到某个阈值(启动堆占用率阈值)时。此时，G1计划启动并发新生代收集(Concurrent Start young collection)，而不是普通新生代收集(Normal young collection)。 并发开始(Concurrent Start):这种类型的收集除了执行普通的收集之外，还开始标记过程。并发标记决定了老年代中所有当前可达(活动)的对象将被保留到下一个空间回收阶段。普通的新生代收集可能会出现在标记尚未完成时。标记结束时有两个特殊stop-the-world暂停:备注(Remark)和清理(Cleanup)。 备注(Remark)：这种暂停完成标记本身，执行全局引用处理和类卸载，回收完全空的区域并清理内部数据结构。在“备注”和“清理”之间，G1计算能够同时回收的选定老年代区域可用空间，这将在“清理”暂停中完成。 清理(Cleanup)：这一暂停决定了空间回收阶段是否会真正到来。如果随后是空间回收阶段，则纯年轻阶段将以一个有准备的混合新生代收集来完成。 空间回收阶段：该阶段包括多个混合收集，除新生代区域外，还疏散老年代区域集合中的活动对象。当G1确定疏散更多的老年代空间性价比不高时，空间回收阶段就结束了。 空间回收后，收集周期从另一个纯年轻阶段重新开始。作为备份，如果应用程序在收集活动信息时耗尽内存，G1会像其他收集器一样执行一次就地完整堆压缩(完整垃圾收集, Full GC)。 垃圾收集暂停和收集集合 G1在stop-the-world暂停时进行垃圾收集和空间回收。存活对象通常从源区域复制到堆中的一个或多个目标区域，并调整对这些移动对象的现有引用。 对于非大型区域，对象的目标区域由该对象的源区域确定: 新生代的对象(eden和survivor区域)被复制到survivor或老年代，这取决于他们的年龄。 老年代区域的对象被复制到其他老年代区域。 巨大区域中的对象被区别对待。G1只决定他们的活跃度，如果它们死掉，收回它们占据的空间。大区域内的物体不会被G1移动。 收集集合是要从中回收空间的源区域集。根据垃圾收集的类型，收集集合由不同类型的区域组成: 在纯年轻阶段，集合仅由新生代中的区域和具有潜在可回收对象的巨大区域组成。 在空间回收阶段，由新生代的区域、具有潜在可回收对象的巨大区域以及收集组候选区域中的一些老年代区域组成。 G1在并发周期中准备垃圾收集的候选区域。在备注暂停期间，G1选择占用空间占用低的区域，这些区域包含大量可用空间。然后，在“备注”和“清理”暂停之间同时准备这些区域，以便以后收集。清理暂停会根据效率对其进行排序。在随后的混合收集中，优先选择包含更多空闲空间的高效区域，这些区域收集时间更少。 深入垃圾优先收集器内部 本节描述了垃圾优先(G1)垃圾收集器的一些重要细节。 确定初始堆占用率 G1在调整Java堆的大小时遵守标准规则，使用-XX:InitialHeapSize作为最小Java堆大小，-XX:MaxHeapSize作为最大Java堆大小，-XX:MinHeapFreeRatio代表最小可用内存比率，-XX:MaxHeapFreeRatio用于确定调整大小后最大可用内存百分比。G1收集器在备注暂停和完整收集中调整Java堆的大小。此过程可能会向操作系统返还内存或从操作系统分配内存。 纯新生代收集规模 G1总是在下一个突变阶段的普通新生代收集结束时对新生代进行评估。通过对实际暂停时间长时间的观察，G1可以达到-XX:MaxGCPauseTimeMillis和-XX:PauseTimeIntervalMillis设置的暂停时间目标。它会考虑相似大小的新生代疏散需要多长时间。这包括在收集过程中需要复制多少对象，以及这些对象之间的关联程度等信息。 如果没有其他约束，那么G1自适应地将年轻一代的大小调整在-XX:G1NewSizePercent和-XX:G1MaxNewSizePercent设定的暂停时间之间。有关如何修复长暂停的更多信息，请参见垃圾优先垃圾收集器优化。 或者，-XX:NewSize与-XX:MaxNewSize的组合可以分别用于设置最小和最大新生代大小。 空间回收阶段收集规模 在空间回收阶段，G1试图在一次垃圾收集暂停中最大化老年代回收的空间量。新生代的大小被设置为允许的最小值，通常由-XX:G1NewSizePercent决定。 在此阶段的每个混合收集开始时，G1从候选收集集合中选择一组区域。这组额外的老年代区域由三部分组成: 老年代区域的最小集合，以确保疏散进度。这组老年代区域由候选区域的数量除以空间回收阶段的长度决定，空间回收阶段的长度由-XX:G1MixedGCCountTarget决定。 如果G1预测在收集完上述最小集合后还会有时间，则收集集合中的其他老年代区域将成为候选区域。添加老年代区域，直到预计将使用80%的剩余时间。 一组可选的收集集合区域，在上面两个部分被疏散后，G1会逐渐疏散这些集合区域，如果在此暂停中还有时间。 前两组区域在初始收集过程中收集，如有剩余的暂停时间再收集可选区域。由于可选集合的管理，这种方法确保了空间回收的进展，同时提高了达到暂停时间的概率，并且使开销最小。 当候选区域中的剩余可回收空间小于-XX:G1HeapWastePercent设定的值，空间回收阶段结束。 有关G1将使用多少老年代区域以及如何避免长时间混合收集暂停的更多信息，请参见垃圾优先垃圾收集器优化。 定期垃圾收集 如果由于应用程序不活动而长时间没有垃圾收集，虚拟机可能会长时间保留大量未使用的内存，这些内存可能在其他地方使用。为了避免这种情况，G1可能会被迫使用-XX:G1PeriodicGCInterval选项进行常规垃圾收集。此选项确定G1考虑执行垃圾收集的最小时间间隔(毫秒)。如果自上次垃圾收集暂停后经过了这段时间，并且没有正在进行的并发循环，G1会触发额外的垃圾收集，可能会产生以下影响: 在纯年轻阶段:G1使用并发开始暂停(Concurrent Start)来开始并发标记，或者，如果指定了-XX:-G1PeriodicGCInvokesConcurrent，则为完整GC。 在空间回收阶段:G1会触发适合当前进度的垃圾收集暂停类型来继续空间回收阶段。 -XX:G1PeriodicGCSystemLoadThreshold选项可用于优化垃圾收集是否被触发:如果JVM主机系统(例如，容器)上的getloadavg()调用返回的平均一分钟系统负载值高于该值，则不会运行定期垃圾收集。 有关定期垃圾收集的更多信息，请参见JEP 346:立即从G1返回未使用的已提交内存。 确定初始堆占用率 初始堆占用率(IHOP，Initiating Heap Occupancy Percent)是触发初始标记收集(Initial Mark)的阈值，定义为老年代大小的百分比。默认情况下，G1通过观察标记需要多长时间以及在标记周期中老年代通常分配多少内存来自动确定最佳IHOP。这一特性被称为自适应IHOP。如果此功能被激活，在没有足够的观察结果来对启动堆占用率阈值进行良好的预测时，选项-XX:InitiatingHeapOccupancyPercent将作为老年代大小的百分比的初始值。使用选项-XX:-G1UseAdaptiveIHOP关闭G1的此行为。在这种情况下，值-XX:InitiatingHeapOccupancyPercent决定这个阈值。 在内部，自适应IHOP尝试设置初始堆占用，以便当老年代占用处于当前最大老年代大小减去作为额外缓冲区的-XX:G1HeapReservePercent值时，开始空间回收阶段的第一次混合垃圾收集。 标记 G1标记使用了一种叫做*开始快照(Snapshot-At-The-Beginning，SATB)*的算法。它在初始标记暂停时获取堆的虚拟快照，只要标记开始时活动的对象在标记的剩余时间都被认为是存活的。这意味着，为了空间回收的目的(除了一些例外)，在标记过程中变死(不可到达)的物体仍然被认为是活的。与其他收集器相比，这可能会导致一些额外的内存被错误地保留。然而，这可能会让SATB在备注暂停期间提供更好的时延。在该标记过程中过于保守考虑的活动对象将在下一个标记过程中被回收。有关标记问题的更多信息，请参见主题垃圾优先垃圾收集器优化。 堆资源紧张下的行为 当应用程序占据如此多的内存以至于疏散无法找到足够的空间来复制时，就会发生疏散失败。疏散失败意味着G1只复制已经移动的对象到新位置来完成当前的垃圾收集，而不复制任何尚未移动的对象，只调整它们之间的引用。疏散失败可能会产生一些额外的开销，但通常和其他新生代收集一样快。在这次垃圾收集和疏散失败后，G1将恢复正常应用，没有任何其他措施。G1会假设疏散失败发生在垃圾收集接近结束时；也就是说，大多数对象已经被移动，并且还有足够的空间继续运行应用程序，直到标记完成和空间回收开始。 如果这个假设不成立，那么G1最终将安排一个完整垃圾收集。这种类型的收集对整个堆执行就地压缩。这可能很慢。 请参阅垃圾优先垃圾收集器优化，了解有关分配失败或在发出内存不足信号之前发生完全垃圾收集器故障的更多信息。 大对象 大对象是大于或等于半个区域大小的对象。除非使用-XX:G1HeapRegionSize选项进行设置，否则当前区域大小是按照G1工效学默认值部分中所述进行的。 这些大对象有时会被特殊对待: 在老年代中，每个大对象都被分配为一系列连续的区域。对象本身的起点总是位于序列中第一个区域的起点。在整个对象被回收之前，序列最后一个区域中的任何剩余空间都不会被分配。 一般来说，只有在清理暂停(Cleanup)期间标记结束时，或者在完整垃圾收集期间大对象无法访问的情况下，才会回收大对象。然而，对于原始类型数组(例如bool、各种整数和浮点值)的大对象有一个特殊的规定。如果在任何垃圾收集暂停期间，这样的大对象没有被多个对象引用，G1将会回收它。这种行为默认是启用的，你可以使用-XX:G1EagerReclaimHumongousObjects禁用它。 大对象的分配可能会导致垃圾收集过早发生。G1在每个大对象分配中检查初始堆占用率阈值，如果当前占用率超过该阈值，可能会立即强制进行初始的新生代垃圾收集标记。 大对象从不移动，即使在完整的垃圾收集也是如此。这可能会导致过早的慢速完整垃圾收集或大量区域空间碎片而导致的内存不足情况。 G1的工程学默认值 本主题概述了G1特有的最重要的设置及其默认值。他们给出了没有附加选项G1的预期行为和资源使用的粗略概述。 选项和默认值 描述 -XX:MaxGCPauseMillis=200 最大暂停时间 -XX:GCPauseTimeInterval=&lt;ergo&gt; 最大暂停时间间隔。默认情况下，G1没有设定任何值，允许G1在极端情况下连续收集垃圾。 -XX:ParallelGCThreads=&lt;ergo&gt; 垃圾收集期间用于并行工作的最大线程数。规则如下:如果进程可用的CPU线程数少于或等于8，使用相等的线程数。否则，为线程数的5/8。在每次暂停开始时，使用的最大线程数还会受到总的堆大小的限制:每个-XX:HeapSizePerGCThread不会多于一个线程。 -XX:ConcGCThreads=&lt;ergo&gt; 用于并发工作的最大线程数。默认情况下，该值为-XX:ParallelGCThreads除以4。 -XX:+G1UseAdaptiveIHOP -XX:InitiatingHeapOccupancyPercent=45 控制初始堆占用率的默认值，表示自适应IHOP已打开，并且在最初的几个收集周期中，G1将使用45%作为老年代标记开始的阈值。 -XX:G1HeapRegionSize=&lt;ergo&gt; 堆区域大小。堆包含大约2048个堆区域。堆区域的大小可以从1到32 MB不等，必须是2的幂。 -XX:G1NewSizePercent=5-XX:G1MaxNewSizePercent=60 新生代总的大小，在这两个值之间，总的堆空间的百分比。 -XX:G1HeapWastePercent=5 候选收集集合未回收空间的百分比。如果候选集合中的可用空间低于该值，G1将停止空间回收阶段。 -XX:G1MixedGCCountTarget=8 空间回收阶段的预期长度。 -XX:G1MixedGCLiveThresholdPercent=85 在空间回收阶段，不会收集存活对象占用率高于这个百分比的老年代区域。 注意：&lt;ergo&gt;意味着实际值是根据环境确定的。 与其他收集器的对比 这里总结一下G1和其他收集齐之间主要区别: 并行收集器将老年代空间作为一个整体来压缩和回收。G1逐渐将这项工作分解为多个更小的垃圾收集工作。这大大缩短了暂停时间，但这可能会牺牲吞吐量 和CMS收集器类似，G1并发的执行老年代空间的收集。然而除非进行完整垃圾收集，CMS不能整理老年代的碎片。 由于其并发性，G1的开销可能高于上述收集器，进而影响吞吐量。 ZGC的目标是特大型堆，旨在牺牲更高的吞吐量来提供更短的暂停时间。 由于其工作原理，G1有一些独特的机制来提高垃圾收集效率: 在任何收集过程中，G1都可以回收一些空的老年代空间。这可以避免许多其他不必要的垃圾收集，轻易就可以释放大量空间。 G1可以选择性的消除堆上的重复字符串。 从老一代回收空的大对象默认是启用的。您可以使用选项-XX:-G1EagerReclaimHumongousObjects禁用此功能。默认情况下，字符串重复数据消除处于禁用状态。您可以使用选项-XX:+G1EnableStringDeduplication来启用它。 10 垃圾优先垃圾收集器优化 本节描述了如何在垃圾优先垃圾收集器(G1垃圾收集器)不符合您的要求的情况下调整它的行为。 本节主题： 对G1的一般性建议 从其他收集器迁移到G1 改进G1的性能 观察完整垃圾收集 大对象碎片 时延优化 异常系统或实时使用 引用对象处理时间过长 纯年轻阶段纯新生代垃圾收集时间过长 混合收集时间过长 更新记忆集和扫描记忆集时间过高 吞吐量优化 堆的大小优化 默认值优化 对G1的一般性建议 一般建议使用G1的默认设置即可，然后给它一个不同的暂停时间设置，并根据需要使用-Xmx设置最大的Java堆大小。 与其他收集器不同，G1的默认值做了不同的平衡。默认配置中，G1的目标既不是最大吞吐量，也不是最低时延，而是在高吞吐量下提供相对较小、均匀的暂停。然而，G1递增式的空间回收机制和暂停时间控制会在应用程序线程和空间回收效率方面产生一些开销。 如果您想要高吞吐量，那么可以使用-XX:MaxGCPauseMillis来放宽暂停时间目标，或者提供一个更大的堆。如果时延是主要要求，则修改暂停时间设置。避免使用-Xmn，-XX:NewRatio等选项将新生代的规模限制在特定值，因为新生代的规模是G1用来满足暂停时间的主要手段。将新生代的大小设置为固定值会覆盖并实际上禁用暂停时间控制。 从其他收集器迁移到G1 通常，当从其他收集器(尤其是CMS收集器)迁移到G1时，首先要删除所有影响垃圾收集的选项，只需要设置暂停时间以及使用-Xmx和可选的-Xms设置总堆大小。 对于其他收集器，许多选项对其响应很有用，但它们对于G1起来说，要么根本不起作用，要么甚至降低吞吐量和达到暂停时间目标的可能性。一个例子是设定新生代的规模，这完全阻止了G1调整新生代的规模以达到设置的暂停时间目标。 改进G1性能 G1旨在提供良好的整体性能，而无需指定其他选项。然而，有些情况下，默认的启发式方法或默认配置效果可能不是最优的。本节给出了一些诊断和改善这些情况的指南。本指南仅描述了在给定一组应用程序的情况下，G1在给定指标下提高垃圾收集器性能的可能性。在具体案例上，应用程序级优化可能比试图调整虚拟机性能更好更有效，例如，通过使用寿命较短的对象完全避免一些有问题的情况。 出于诊断目的，G1提供全面的日志。一个好的开始是使用-Xlog:gc*=debug选项，然后在必要时从中提炼输出内容。日志提供了关于垃圾收集活动暂停期间和暂停之外的详细概述。这包括收集的类型和在暂停的特定阶段花费的时间的细节。 以下小节探讨了一些常见的性能问题。 观察完整垃圾收集 *完整堆垃圾收集(Full GC)*通常非常耗时。老年代占用率过高导致的完整收集可以在日志中查找单词&quot;Pause Full (Allocation Failure)&quot;得到。完整收集通常紧跟在一个&quot;to-space exhausted&quot;标签标示的垃圾收集之后。 发生完整垃圾回收的原因是应用程序分配了太多无法快速回收的对象。通常并发标记不能及时完成，以开始空间回收阶段。许多大对象的分配可能会增加进入完整收集的可能性。由于这些对象在G1的分配方式，它们可能会占用比预期多得多的内存。 目标应该是确保并发标记按时完成。这可以通过降低老年代的分配率或者给并发标记更多的时间来完成。 G1给了你几个选项来更好地处理这种情况: 您可以使用gc+heap=info日志来确定Java堆上大对象占据的区域数量。&quot;Humongous regions: X-&gt;Y”行中的Y表示大对象占据的区域数量。如果与老年代的数量相比，该数较高，最好的选择是尝试减少区域的数量。您可以通过使用-XX:G1HeapRegionSize选项增加区域大小来实现这一点。当前选择的堆区域大小打印在日志的开头。 增加Java堆的大小。这通常会增加标记完成的时间。 通过显式设置-XX:ConcGCThreads，增加并发标记线程的数量。 迫使G1提前开始标记。G1根据应用程序行为自动确定IHOP阈值。如果应用程序行为改变，这些预测可能是错误的。有两种选择:通过修改-XX:G1ReservePercent来增加自适应IHOP计算中使用的缓冲区，从而降低何时开始空间回收的目标占用率；或者，通过使用-XX:-G1UseAdaptiveIHOP和-XX:InitiatingHeapOccupancyPercent手动设置IHOP的阈值。 除了内存分配失败完整收集通常是由应用程序或某个外部工具导致的。如果原因是System.gc()，并且没有办法修改应用程序源码，则可以通过使用-XX:+ExplicitGCInvokesConcurrent或通过设置-XX:+DisableExplicitGC让虚拟机完全忽略它们来减轻完整收集的影响。外部工具可能仍然会强制完整垃圾收集，不用它们的时候就把它们删除。 大对象碎片 为了寻找连续区域，完整垃圾收集可能会在堆内存耗尽之前就进行。一个潜在的选项是提高-XX:G1HeapRegionSize的值，从而降低大对象占用的区域数，或者增加堆的整体大小。在极端情况下，即使可用内存足够G1却找不到充足的连续区域，这将会导致虚拟机退出。因此，除了前面提到的减少大对象分配或者增加堆之外，没有其他选择。 时延优化 本节讨论了在常见时延问题(即暂停时间过高)的情况下如何改善G1行为。 异常系统或实时使用 对于每一次垃圾收集暂停，gc+cpu=info日志输出都包含一行包含来自操作系统的信息，并附有垃圾收集时间明细。这种输出的一个例子是User=0.19s Sys=0.00s Real=0.01s。 用户时间(User)是在虚拟机代码中花费的时间，系统时间(Sys)是在操作系统中花费的时间，实时(Real)是在暂停期间经过的绝对时间量。如果系统时间相对较长，那么最常见的原因是环境。 系统时间过高的常见原因： 虚拟机从操作系统内存分配或返还内存可能会导致不必要的时延。通过使用选项-Xms和-Xmx将最小和最大堆大小设置为相同的值，并使用-XX:+AlwaysPreTouch预接触所有内存，将此工作移到虚拟机启动阶段，从而避免延迟。 特别是在Linux中，通过透明大页面(THP)功能将小页面合并成大页面往往会拖延随机进程，而不仅仅是在垃圾收集暂停期间。因为虚拟机分配并维护大量内存，所以虚拟机成为长时间停顿的进程的风险比通常情况下要高。请参考操作系统文档，了解如何禁用透明大页面功能。 日志写入输出可能会暂停一段时间，因为一些后台任务会间歇性地占用日志写入的硬盘的输入/输出带宽。考虑为日志或其他存储使用单独的磁盘，例如内存备份文件系统，以避免这种情况。 另一个需要注意的情况是实时比其他情况的总和大得多，这可能表明虚拟机在可能过载的机器上没有获得足够的CPU时间。 引用对象处理时间过长 引用对象处理发生在引用处理阶段。在引用处理阶段，G1根据引用对象的类型更新引用。默认情况下，G1尝试使用以下启发式方法来并发进行引用处理:对于每-XX:ReferencesPerThread个引用对象启动一个线程，最多-XX:ParallelGCThreads个线程。默认情况下，可以通过将-XX:ReferencesPerThread设置为0来禁用此启发式算法，或者通过-XX:-ParallelRefProcEnabled完全禁用并行化。 纯年轻阶段纯新生代垃圾收集时间过长 一般来说，任何新生代收集需要的时间大致与新生代的大小成比例，或者更具体地说，与其中需要复制的存活对象数量成比例。如果疏散收集(Evacuate Collection Set)花费的时间太长，特别是对象复制子阶段(Object Copy)，则减少-XX:G1NewSizePercent。这减少了新生代的最小尺寸，停顿的时间可能更短。 如果应用程序性能，特别是幸存的对象数量突然改变，新生代的规模可能会导致垃圾收集暂停时间激增。通过使用-XX:G1MaxNewSizePercent来减小新生代的规模可能是有用的。这限制了新生代的最大尺寸，因此也限制了垃圾收集需要处理的对象数量。 混合收集时间过长 混合收集用来回收老年代的空间。混合收集区域包含新生代和老年代区域。通过启用gc+ergo+cset=trace打印日志输出，您可以获得新生代或老年代区域的疏散时间对暂停时间的影响。分别查看新生代区域和老年代区域的暂停时间。 如果新生代时间太长，则查看上一节纯年轻阶段纯新生代垃圾收集时间过长。否则，为了减少老年代对暂停时间的贡献，G1提供了三种选择: 增加-XX:G1MixedGCCountTarget将垃圾收集扩散到更多的老年代区域 通过使用-XX:G1MixedGCLiveThresholdPercent，避面将占用率高的区域放入候选收集集合中。在许多情况下，高占用率的区域需要大量时间来收集。 尽早停止老年代的空间回收，这样G1就不会收集那么多高度占用的区域。在这种情况下，增加-XX:G1HeapWastePercent百分比。 请注意，后两个选项减少了当前空间回收阶段可回收空间候选区域的数量。这可能意味着G1可能无法在老年代中回收足够的空间用于持续运营。然而，稍后的空间回收阶段可能收集它们。 更新记忆集和扫描记忆集时间过高 为了使G1能够疏散单个老年代区域，G1跟踪跨区域引用(cross-region references)的位置，即从一个区域指向另一个区域的引用。指向给定区域的跨区域引用集称为该区域的记忆集(remembered set)。移动区域内容时，必须更新记忆集。区域记忆集的维护大多是同时进行的。出于性能考虑，当应用程序的两个对象之间建立新的跨区域引用时，G1不会立即更新。记忆集更新请求会被延迟并批量处理以提高效率。 G1需要完整的记忆集进行垃圾收集，因此垃圾收集的*更新记忆集(Update RS)*阶段会处理任何未完成的更新请求。*扫描记忆集(Scan RS)*阶段会搜索记忆集中引用的对象，移动区域的内容，更新到新的引用位置。根据应用程序的不同，这两个阶段可能会花较长的时间。 使用选项-XX:G1HeapRegionSize调整堆区域的大小会影响跨区域引用的数量以及记忆集的大小。处理区域的记忆集可能是垃圾收集工作的一个重要部分，因此这对最大暂停时间有直接影响。较大的区域往往具有较少的跨区域引用，因此处理这些引用所花费的相对工作量会减少，尽管与此同时，较大的区域可能意味着每个区域要疏散更多的存活对象，从而增加了其他阶段的时间。 G1尝试并发处理记忆集的更新，更新阶段花费时间大概是最大暂停时间的-XX:G1RSetUpdatingPauseTimePercent。通过降低该值，G1通常会以更高的并发进行记忆集更新工作。 批量更新记忆集可能会导致记忆集更新与大对象分配合并在一起，从而造成虚假的更新时间过长。如果批处理正好发生在垃圾收集之前，那么就需要处理记忆集更新的所有工作。使用-XX:-ReduceInitialCardMarks禁用这种行为，潜在的避免这种情况。 记忆集扫描时间还取决于G1保存记忆集的压缩量。记忆集在内存中存储得越紧凑，在垃圾收集过程中检索存储值所需的时间就越长。G1自动执行这种压缩，称为记忆集粗化(coarsening)，同时根据该区域记忆集的当前大小更新记忆集。特别是在最高压缩级别，检索数据可能会非常慢。使用-XX:G1SummarizeRSetStatsPeriod选项和gc+remset=trace日志级别可以显示是否有粗化发生。如果是这样，那么在Before GC Summary之前部分中的Did &lt;X&gt; coarsenings行中X显示一个高值。增加-XX:G1RSetRegionEntries选项可以显著的降低粗化量。避免在生产环境中使用详细的记忆集日志记录，因为收集此数据可能会花费大量时间。 吞吐量优化 G1的默认策略试图在吞吐量和延迟之间保持平衡；然而，有些情况下需要更高的吞吐量。除了如前所述减少总暂停时间之外，暂停的频率也可以减少。主要思想是通过使用-XX:MaxGCPauseMillis来增加最大暂停时间。分代大小启发式算法将自动调整新生代的大小，这直接决定暂停的频率。如果这没有导致预期的行为，特别是在空间回收阶段，使用-XX:G1NewSizePercent增加新生代的规模将迫使G1这样做。 在某些情况下，-XX:G1MaxNewSizePercent：允许的新生代最大规模，可以通过限制新生代规模来限制吞吐量。这可以通过查看gc+heap=info日志来诊断。在这种情况下，eden区域和survivor区域总的百分比接近于-XX:G1MaxNewSizePercent。在这种情况下，考虑增加-XX:G1MaxNewSizePercent的值。 增加吞吐量的另一个选择是尝试减少并发工作量。特别是，并发更新记忆集通常需要大量的CPU资源。增加-XX:G1RSetUpdatingPauseTimePercent将并发操作挪到垃圾收集阶段。在最糟糕的情况下，通过设置-XX:-G1UseAdaptiveConcRefinement -XX:G1ConcRefinementGreenZone=2G -XX:G1ConcRefinementThreads=0可以完全禁用这种机制，将记忆集更新工作挪到下一次垃圾收集。 通过使用-XX:+UseLargePages启用大页面也可以提高吞吐量。请参考操作系统文档，了解如何设置大页面。 将选项-Xms和-Xmx设置为相同的值，您可以通过禁用堆大小调整。此外，您可以使用-XX:+AlwaysPreTouch将操作系统工作放在虚拟机的启动时间，虚拟机使用物理内存支持的虚拟内存。为了使暂停时间更加一致，这两种方法都是特别理想的。 堆的大小优化 和其他收集器一样，G1将调整堆的大小使垃圾收集所花费的时间低于-XX:GCTimeRatio选项所设定的比率。调整此选项，使G1符合您的要求。 默认值优化 本节介绍了默认值和本主题中介绍的命令行选项的一些附加信息。 选项和默认值 描述 -XX:+G1UseAdaptiveConcRefinement-XX:G1ConcRefinementGreenZone=&lt;ergo&gt;-XX:G1ConcRefinementYellowZone=&lt;ergo&gt;-XX:G1ConcRefinementRedZone=&lt;ergo&gt;-XX:G1ConcRefinementThreads=&lt;ergo&gt; 并发记忆集更新使用这些选项来控制并发线程的工作分配。G1为这些选项选择符合工效学的值，使用-XX:G1RSetUpdatingPauseTimePercent设置垃圾收集暂停中剩余工作花费时间，根据需要自适应的调整。更改时务必小心，因为这可能会导致非常长的暂停时间。 -XX:+ReduceInitialCardMarks 初始对象分配中记忆集并发修改 -XX:+ParallelRefProcEnabled-XX:ReferencesPerThread=1000 -XX:ReferencesPerThread决定并发的程度：每N个引用有一个线程进行引用处理，线程数最多-XX:ParallelGCThreads。值为0表示始终使用-XX:ParallelGCThreads值所指示的最大线程数。这决定了java.lang.Ref.*实例的处理是否应该由多个线程并发完成。 -XX:G1RSetUpdatingPauseTimePercent=10 这决定了G1在记忆集更新时间占垃圾收集总时间的百分比。G1使用此设置控制记忆集更新并发的数量。 -XX:G1SummarizeRSetStatsPeriod=0 控制多少次垃圾收集生成记忆集摘要报告。将此设置为零以禁用。生成记忆集摘要报告是一项成本很高的操作，因此只有在必要时才应该使用，并且要把值设的高一些。使用gc+remset=trace打印所有内容。 -XX:GCTimeRatio=12 这是垃圾收集上的时间与应用程序的时间之比。用于确定垃圾收集中可以花费的时间的目标分数的实际公式是1 / (1 + GCTimeRatio)。该默认值将会导致有大约8%的时间用于垃圾收集。 -XX:G1PeriodicGCInterval=0 检查G1是否应该触发定期垃圾收集的时间间隔(毫秒)。设置为零禁用。 -XX:+G1PeriodicGCInvokesConcurrent 如果设置，定期垃圾收集会触发并发标记或继续现有收集周期，否则会触发完整垃圾收集。 -XX:G1PeriodicGCSystemLoadThreshold=0.0 触发定期垃圾收集的系统负载阈值，当前系统负载可以通过调用getloadavg()获得。高于此值的系统负载不会进行定期垃圾收集。零值表示此阈值检查被禁用。 注意：&lt;ergo&gt;意味着实际值是根据环境确定的。 11 Z收集器 Z垃圾收集器(ZGC)是一个可扩展的低延迟垃圾收集器。ZGC并发执行所有代价高昂的工作，停止应用程序线程的时间不会超过10ms，这使得它适用于需要低时延和/或特大堆(几T字节)的应用程序。 Z垃圾收集器是一个实验特性，并通过命令行选项-XX:+UnlockExperimentalVMOptions -XX:+UseZGC启用。 设置堆大小 ZGC最重要的调整选项是设置最大堆大小(-Xmx)。由于ZGC是一个并发收集器，因此必须按如下方法选择最大堆大小，1)堆可以容纳应用程序的存活对象，2)即使在垃圾收集运行时也有足够的堆空间分配给应用程序。需要多少空间在很大程度上取决于应用程序的分配速率和存活对象大小。总的来说，你给ZGC的内存越多越好。但与此同时，浪费内存是不可取的，所以这一切都是为了在内存使用和垃圾收集运行频率之间找到平衡。 设置垃圾收集的并发数 第二个可能需要考虑的调整选项是设置并发GC线程的数量(-XX:ConcGCThreads)。ZGC有启发式算法自动选择这个数。这种启发式方法通常运行良好，但是根据应用程序的特点，这可能需要调整。这个选项本质上决定了应该给垃圾收集多少CPU时间。给它太多，垃圾收集器会从应用程序中窃取太多的CPU时间。给它太少，应用程序产生垃圾的速度可能会比垃圾收集速度快。 12 其他情况 本节涵盖影响垃圾收集的其他情况。 本节主题： 弱引用、软引用和幻像引用的终结 显式垃圾收集 软引用 类元数据 弱引用、软引用和幻像引用的终结 一些应用程序通过使用弱引用、软引用和幻像引用的终结(Finalization)来与垃圾收集交互。 这些特性可能在Java编程语言级别造成性能隐患。这方面的一个例子是依赖于终结来关闭文件描述符，这使得外部资源(描述符)依赖于垃圾收集的及时性。依靠垃圾收集来管理内存以外的资源几乎总是一个坏主意。 请参见如何处理Java终结的内存保留问题，其中深入讨论了终结的一些陷阱以及避免它们的技术。 显式垃圾收集 应用程序与垃圾收集交互的另一种方式是使用System.gc()显式调用完整的垃圾收集。 这可能会在不必要的时候强制进行大规模垃圾收集(例如，当小规模收集就足够了)，因此通常应该避免。显式垃圾收集的性能影响可以通过使用标志-XX:+DisableExplicitGC禁用它们来衡量，这将导致虚拟机忽略对System.gc()的调用。 显式垃圾收集最常见的一种用途是远程方法调用(RMI)的分布式垃圾收集(DGC)。使用RMI的应用程序引用其他虚拟机中的对象。如果不偶尔进行本地堆的垃圾收集，就无法收集这些分布式应用程序中的垃圾，因此RMI会强制定期进行完整垃圾收集。这些收集的频率可以通过属性来控制，如下例所示: java -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000 ... 本示例指定每小时一次显式垃圾收集，而不是默认的每分钟一次。但是，这也可能导致一些对象需要更长时间才能被回收。如果不希望对DGC活动的及时性有上限，可以将这些属性设为Long.MAX_VALUE，这样显式收集时间间隔实际上是无限的。 软引用 软引用在服务器模式的虚拟机中保持活动的时间比在客户端模式的虚拟机长。 清除速率可以通过命令行选项-XX:SoftRefLRUPolicyMSPerMB=&lt;N&gt;来控制，该选项为每兆字节的可用堆空间一个软引用保持活动状态的毫秒数(ms)(一旦它不可达)。默认值为每兆字节1000毫秒，这意味着对于堆中每兆字节的可用空间，软引用将保留1秒钟(在收集到对象的最后一个强引用之后)。这是一个大概的数字，因为软引用仅在垃圾收集期间被清除，垃圾收集可能偶尔发生。 类元数据 Java类在Java Hotspot虚拟机中有一个内部表示，称为类元数据。 在先前版本的Java Hotspot虚拟机中，类元数据是在所谓的永久代(permanent generation)中分配的。从JDK 8开始，永久代被删除，类元数据被分配到本机内存中。默认情况下，可用于类元数据的本机内存量不受限制。使用选项-XX:MaxMetaspaceSize设置类元数据的上限。 Java Hotspot虚拟机显式地管理元数据空间。从操作系统请求空间，然后将其分成块。类加载器从其块中为元数据分配空间(块绑定到特定的类加载器)。当为类加载器卸载类时，它的块会被循环使用或返回到操作系统。元数据使用mmap而不是malloc分配的空间。 如果-XX:UseCompressedOops已打开，并且-XX:UseCompressedClassesPointers已使用，则本机内存的两个逻辑上不同的区域将用于类元数据。-XX:UseCompressedClassPointers使用32位偏移量来表示64位进程中的类指针，就像-XX:UseCompressedOops用于Java对象引用一样。这些压缩的类指针(32位偏移量)将分配一个区域。区域的大小可以用-XX:CompressedClassSpaceSize设置，默认为1gb。压缩类指针的空间在初始化时被保留为-XX:mmap分配的空间，并根据需要提交。-XX:MaxMetaspaceSize用于确定提交的压缩类空间和其他类元数据的空间之和。 当相应的Java类被卸载时，类元数据被回收。垃圾收集可能会导致Java类卸载和元数据被回收。当为类元数据提交的空间达到某个级别(高水位线)时，就会引发垃圾收集。垃圾收集后，高水位线可能会根据从类元数据中释放的空间量而升高或降低。高水位线可能会升高，以免过早引发另一次垃圾收集。高水位线初值为命令行选项-XX:MetaspaceSize的值，并根据选项-XX:MaxMetaspaceFreeRatio和-XX:MinMetaspaceFreeRatio升高或降低。如果类元数据的申请空间中可用空间百分比大于-XX:MaxMetaspaceFreeRatio，则高水位线将会降低。如果它小-XX:MinMetaspaceFreeRatio，那么高水位线将会升高。 为选项-XX:MetaspaceSize指定一个高一些的值，以避免引发过早的垃圾收集。为应用程序分配的类元数据的数量取决于应用程序，并且不存在选择-XX:MetaspaceSize的一般准则。-XX:MetaspaceSize的默认大小取决于平台，范围从12 MB到20 MB不等。 关于元数据所用空间的信息包含在堆的日志输出中。以下是典型输出: [0,296s][info][gc,heap,exit] Heap [0,296s][info][gc,heap,exit] garbage-first heap total 514048K, used 0K [0x00000005ca600000, 0x00000005ca8007d8, 0x00000007c0000000) [0,296s][info][gc,heap,exit] region size 2048K, 1 young (2048K), 0 survivors (0K) [0,296s][info][gc,heap,exit] Metaspace used 2575K, capacity 4480K, committed 4480K, reserved 1056768K [0,296s][info][gc,heap,exit] class space used 238K, capacity 384K, committed 384K, reserved 1048576K 在以Metaspace开头的行中，used是用于加载类的空间量。capacity是当前分配块中元数据的可用空间。committed是块的可用空间量。reserved是为元数据保留(但不一定提交)的空间量。以class space开头的行包含压缩类指针的元数据相应值。 附录：主要中英文名词翻译对照表 英文 中文 Minor Collection 小规模垃圾收集 Major Collection 大规模垃圾收集 Young Generation 新生代 Old Generation 老年代 Ergonomics 工效学 The Mostly Concurrent Collectors 主要并发收集器 Full GC 完整垃圾收集 Young-only Phase 纯年轻阶段 Space-reclamation Phase 空间回收阶段","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"垃圾收集","slug":"垃圾收集","permalink":"https://naosense.github.io/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://naosense.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"MySQL事务隔离小记","slug":"MySQL事务隔离小记","date":"2019-03-31T13:28:34.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2019/03/31/MySQL事务隔离小记/","link":"","permalink":"https://naosense.github.io/2019/03/31/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E5%B0%8F%E8%AE%B0/","excerpt":"大家都知道事务系统有四大特征：原子性、一致性、隔离性、持久性。隔离性是其中重要的一环，什么是隔离呢，顾名思义就是事务之间啥时候可见啥时候不可见，这就是MySQL的四个隔离级别： 未提交读（read uncommited） 提交读（read commited） 可重复读（repeatable read） 串行读（serializable）","text":"大家都知道事务系统有四大特征：原子性、一致性、隔离性、持久性。隔离性是其中重要的一环，什么是隔离呢，顾名思义就是事务之间啥时候可见啥时候不可见，这就是MySQL的四个隔离级别： 未提交读（read uncommited） 提交读（read commited） 可重复读（repeatable read） 串行读（serializable） 其实前两种从名字上就能理解什么意思，未提交读是事务没提交呢，别的事务就读到了，也就是可以读取事务的中间状态，即常说的脏读，这违反了事务的原子性和一致性；提交读呢，只有事务提交了，其他事务才可以读取，提交读解决了脏读问题却存在如下问题，比如A事务和B事务并行执行，假设A事务第一次读取了字段name是“小明”，这个时候B事务修改了name为“小红”，接下来A事务又读取了这个字段，发现“小明”变成了“小红”，“小明”去哪了，说好的隔离呢，这种问题被称为不可重复读，所以有时候提交读也称为不可重复读。 可重复读就是为解决不可重复读问题而出现的另一个隔离级别，也是MySQL的默认事务隔离级别。但是可重复读也不是完美无缺的，比如A事务和B事务同时执行，A先查找name字段为“小红”的记录发现没有，这时候B添加name为“小红”的记录，A又执行一次查询，发现有“小红”这条记录了，即所谓的幻行，A像产生了幻觉一样，这种问题被称为幻读。 串行读就是所有的事务串行化执行，看似完美解决了所有的问题，却付出了加锁同步的代价。 总结四种级别的问题矩阵： 隔离级别 脏读 不可重复读 幻度 加锁读 未提交读 是 是 是 否 提交读 否 是 是 否 可重复读 否 否 是 否 串行读 否 否 否 是 综合来看，第一种隔离级别太低违反了原子性和一致性，最后一种串行读效率太低在实际项目中鲜见使用，第二第三种都有一个幻读的问题，接下来看看MySQL如何解决这个问题。 MySQL使用了一种称之为多版本并发控制（MVCC）的机制，通过在每行记录后面保存两个隐藏列，一个保存了行的创建时间，一个保存了行的删除时间，这里的“时间”实际上是版本号，说到版本号你可能会猜测这应该是一种类似于乐观锁的并发控制机制，没错，MySQL就是通过这两个列实现了一种乐观锁。每当开始一个事务，系统版本号自动递增，事务开始的版本号作为事务的版本号，下面分别看看各种操作下这两个版本号是如何控制并发的。 查询操作（select）时，读取创建时间小于等于事务版本且删除时间未定义或大于事务版本的那些行，翻译成人话就是只读取本次事务添加或之前就存在，并且至少截止到本次事务还没有删除的那些记录。 插入时（insert），行的创建时间设置为当前系统版本号。 删除时（delete），删除时间设为系统版本号。 修改时（update），将当前版本号作为新行的创建时间和旧行的删除时间，可见修改相当于删除和插入两个动作。 回过头看上面A第二次读取时如果按这种方式就不会出现幻行，因为A只会读取A之前就存在和A自身插入的行。但是MVCC如果工作在提交读的情况下，不就没法读取新提交的记录了，这与提交读的语义不是矛盾了？ 带着这个疑问去看MySQL官方说明，原来MySQL有一个consistent read的概念，MySQL通过快照（snapshot）给每个事务返回结果，在可重复读的情况下快照由本事务第一次读取操作决定，也就是快照在第一次读取操作时就定了（本事务如果更新或删除其他事务提交的记录将会更新快照），而提交读事务每次读取都会更新快照。那么问题来了，快照是如何生成的呢？其实MySQL增加的两列不是上面所述的“创建时间”和“删除时间”，而是DB_TRX_ID，即最后一个对本行进行操作的事务版本号，另一个是DB_ROLL_PTR，称为滚动指针，它指向undo log，undo log中包含了恢复到未修改前数据的必要信息，比方说insert了一条记录，undo log里就存上一条delete。MySQL就是利用这两个隐藏列和undo log来构建快照的，下面以一个简单的示例说明一下，假设当前隔离级别为可重复读： 事务1首先insert一条name为小红的记录，undo log里插入一条delete记录：事务：1：delete 小红，DB_TRX_ID为事务版本号：1，DB_ROLL_PTR指向undo log的第1条记录 事务2执行select name=小红操作，由于DB_TRX_ID小于当前事务版本2，所以小红这条记录对事务2可见，最终小红这条记录返回 在事务2执行过程中，事务3将小红更新成了小明，DB_TRX_ID需要更新成最新的事务版本号3，DB_ROLL_PTR指向undo log的第2条记录：事务：3：update 小明-&gt;小红 事务2又执行select name=小红操作，由于DB_TRX_ID大于2，也就是在当前事务之后修改的，所以需要借助undo log回滚构建快照（不是真正的回滚），执行DB_ROLL_PTR指向的记录：update：事务：3：update 小明-&gt;小红，name由小明变为小红，执行select语句还是返回这条记录 当然MySQL真正的实现肯定比这复杂的多，这只是我根据看到的文档抽象的一个简化模型。 参考资料： 高性能MySQL Consistent Nonlocking Reads InnoDB Multi-Versioning","categories":[],"tags":[{"name":"事务","slug":"事务","permalink":"https://naosense.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"mysql","slug":"mysql","permalink":"https://naosense.github.io/tags/mysql/"}]},{"title":"万锁之母AbstractQueuedSynchronizer","slug":"万锁之母AbstractQueuedSynchronizer","date":"2019-03-12T15:55:02.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2019/03/12/万锁之母AbstractQueuedSynchronizer/","link":"","permalink":"https://naosense.github.io/2019/03/12/%E4%B8%87%E9%94%81%E4%B9%8B%E6%AF%8DAbstractQueuedSynchronizer/","excerpt":"翻看Java“锁”记中提到的各种“锁”，其内部同步实现大多数都和一个类AbstractQueuedSynchronizer相关，这个类称得上“万锁之母”，所以今天就来扒一扒这个类。","text":"翻看Java“锁”记中提到的各种“锁”，其内部同步实现大多数都和一个类AbstractQueuedSynchronizer相关，这个类称得上“万锁之母”，所以今天就来扒一扒这个类。 整体脉络 为了避免一头扎进去纠缠于各种细节出不来，可以先从宏观上来看一下这个类。首先大家思考一个问题：什么是同步器？假如把线程比作车辆，同步器的角色和警察叔叔差不多，警察的做的事无非是在合适的时机指挥车辆走和停，同步器呢，也是在选择合适的时间调度线程阻塞和执行。 对于车辆来说，什么时候走什么时候停呢，警察叔叔给你招手的时候啊，来来来小伙子，否则就老老实实排队，等警察叔叔给你招手；对于线程来讲也可以采用这种策略，获得许可可以执行，否则排队阻塞，等同步器给与你许可。如果前方交通比较疏松，警察可能一次会叫好几辆车一起走，如果比较拥堵，则会一辆一辆的来；同步器呢同样如此，它有两种模式：共享和独占，前者允许多个线程一起运行，后者只允许单一线程运行。 如果用伪代码表示上面的逻辑可能是这样子的： // 获得许可 while (不允许获得许可) &#123; 线程排队 停止执行 &#125; 从队伍里出来继续执行 // 释放许可 if (允许释放许可) &#123; 释放许可 叫醒排队的线程 &#125; 经过上面的分析大致可以提炼出同步器要解决这么几点： 许可怎么获取和释放 线程采用什么方法停止和继续执行 对于不能立马获得许可的线程得有排队机制 源码分析 说是源码分析其实是自己在学习AbstractQueuedSynchronizer源码的一些学习笔记，并不是完整的源码分析。相信想了解AbstractQueuedSynchronizer运行机制的人多多少少都看过它的代码了，甚至看了一遍都不止，其实大部分代码一般人都能看懂，就是有那么几处难懂的代码，犹如芒刺在背不拔不快。本文就是为了这个目的而写的，并不是要面面俱到而是重点突破，给有心人一点启发。为了符合上下文的语义，下面描述的时候可能节点和线程交替使用，也会把阻塞停止，唤醒叫醒混用，大家留意就是了。 AbstractQueuedSynchronizer整体是利用模板模式，通过维护一个state变量状态配合tryAcquire，tryRelease以及tryAcquireShared，tryReleaseShared间接的影响许可获取和释放。 同步器使用CLH队列来维护排队的线程，CLH队列说白了就是一个单向链表，特性是后一个节点的状态是由前一个节点的状态决定的，每个节点都有一个pred指针指向前一个节点，AbstractQueuedSynchronizer在原生的CLH队列基础上进行了优化，加入了一个next指针，指向后继节点，用于提高寻找后继节点的性能，这就形成了一个双向链表。由于没有更新两个volatile的变量的CAS方法，所以next变量为null的时候并不表明没有后继节点，因为有可能一个节点入列的时候更新完pred指针，还没来得及更新next指针。具体结构如下： head和tail分别指向队列的头和尾，next我这里画成了虚线，表明其不可靠性。 AbstractQueuedSynchronizer的核心就是如何维护CLH队列的状态，所以我们把重点放在这一块。它提供了两套获取许可和释放许可的方法：acquire，release和acquireShared，releaseShared，分别对应独占和共享模式。下面分别看看这两套方法的签名： // 独占模式模板方法 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; // 共享模式模板方法 public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; 可以看到这两套方法是非常类似的，我们一个一个的看看，首先看看acquire方法： // acquire方法的逻辑粗看起来可能是先尝试获取下许可 // 如果成功，直接跳出，不用排队了； // 如果不成功就添加一个独占节点到队列中排队，如果 // 有中断响应中断，细节一个方法一个方法的进入看看 public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; // 尝试获取许可，成功返回true，这个方法没有实现 // 而是留给子类去实现，因为不同的锁获取和释放 // 许可的语义是不同的无法一概而论，所以交由 // 具体的子类去实现，这是典型的模板模式 // 之所以没有用抽象方法，是因为同步器 // 允许只实现独占和共享的一种，如果是 // 抽象方法，则需要实现两套模式的方法 protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; // 从名字上也可以看出这个方法就是往队伍里添加节点进行排队 private Node addWaiter(Node mode) &#123; // 以当前线程建立一个新的节点，准备插到队伍里 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 这句是原生英文注释，大意是先尝试快速的路径入队，如果失败 // 再用完整的入队方法，为什么这里是快呢？先别急，先往下看 Node pred = tail; // pred != null 说明队伍里已有排队者 if (pred != null) &#123; node.prev = pred; // 使用CAS操作将当前节点插到队伍里，注意这个时候可能 // 会有多个线程在同时往里插队，但是CAS操作能确保同一 // 时间只有一个线程会成功 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node; &#125; // 这就是所谓的完整的入队方法 private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; // 也就是队列还没有初始化呢，将head和 // tail都初始化为一个哑节点 if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 看这段代码是不是很眼熟了呢，对 // 这块和快速入队方法基本一样，对比快速和完整 // 两种入队方法，快速的没有初始化判断， // 少了循环，不会重试，相对来说会“快”点 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; // 这个方法的大意是如果获得了许可，赶紧出队执行，否则告诉你的 // 前继节点轮到你时叫你，然后老老实实排队等待 final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获得node的前继节点 final Node p = node.predecessor(); // 如果前继节点是头而且尝试获取许可成功 // 也就是轮到node出列执行了，即警察叔叔 // 给你招手了 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 这里是判断是否需要阻塞，需要的话就要调用 // park方法将线程歇一会，等unpark叫醒线程 // 的时候会检查中断状态，如果有中断就响应 // 中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; // 如果tryAcquire抛出异常 if (failed) cancelAcquire(node); &#125; &#125; // 这段代码的大意是节点node给前面的节点pred说哥们我先睡会，到站叫我，pred // 说好（设置为SIGNAL状态），到站之后叫你，你放心睡吧 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; // 如果前继节点的状态是SIGNAL，表明node已经告诉pred到站叫他， // 而且pred也已经答应了，所以node可以放心的去睡了 if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; // 这里是删除取消的节点，因为只有CANCEL的节点是大于0 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // node告诉pred到站叫它 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; // 这个方法很简单，没啥好说的，就是去睡觉，醒来 // 之后看看手机有没有人找你（中断） private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125; acquire分析完了，再看看release // 如果释放许可成功，并且后面还有节点，叫醒它 // 返回 public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; // 如果后面还有节点 // waitStatus会被设置成SIGNAL，忘记的话可以再 // 看看前面的shouldParkAfterFailedAcquire方法 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; // 叫醒后面的哥们一次 private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // 如果ws小于0，也就是没有取消，将ws置位0 // 也就是打算叫醒后面的节点，同时把提醒 // 状态复位，免得叫醒多次 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; // 如果后面可能没节点了或者节点是取消的 // 就从后往前找，如果能找到紧随node之后 // 并且没有取消的节点就叫醒它。这里就是 // 利用next的优化了，即如果next不为空 // 且没有取消那么直接叫醒next，如果 // next为空，不能认定后面就没有节点了 // 因为next是不可靠的，要利用可靠的pred从后 // 往前找 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread); &#125; 独占模式的获取和释放代码就分析完了，再来看看共享模式的。 public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; // 返回值小于0表示获取失败 // 等于0表示获取许可成功但是后面节点无法再获取了 // 大于0表示获取许可成功并且后面节点还可以再获取 protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException(); &#125; // 粗看doAcquireShared和acquireQueued非常相似， // 主要是两点不同，一是一个添加的是独占节点， // 一个添加的是共享节点，另一点不同是 // 一个是setHead，一个是setHeadAndPropagate private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; // 可以看到setHeadAndPropagate不光像独占模式那样修改了队列的头， // 还会在某些条件下调用一个doReleaseShared方法 private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); // 后续节点还有获取许可的机会或者节点没有取消 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 不知道s是什么类型或者s是共享节点 if (s == null || s.isShared()) doReleaseShared(); &#125; &#125; // 在并发的条件下叫醒队列头部的线程 private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; // 这部分代码和独占模式的release方法几乎一样 // 也是把队列头的线程叫醒继续执行，但要注意 // 一个重要区别是这里使用的是CAS操作，上面 // 独占不是，这是为什么呢？还记得独占和共享 // 的定义吗？对于共享模式多个线程同时执行 // 同时也有可能多个线程同时释放，所以必须 // 使用CAS操作保证线程安全 int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; // 这个分支啥时候会满足呢？根据上面的分析在入队的时候 // 会调用shouldParkAfterFailedAcquire将前继节点的状态 // 修改为SIGNAL，这里为0应该发生在头节点没有后继节点 // 或者后继节点调用shouldParkAfterFailedAcquire // 还没返回的时候，再加上这个条件： // !compareAndSetWaitStatus(h, 0, Node.PROPAGATE) // 那么就剩下了一种情况：头结点的后继节点调用 // shouldParkAfterFailedAcquire还没把头节点 // 的状态修改成SIGNAL的时候。如果没有这个分支 // 只能等待下一次的doReleaseShared的调用才能 // 将头部的线程叫醒了 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // 这句意思是头没变就跳出，那头啥时候变呢，就是出队的时候 // 也就是有线程已经出队，有责任叫醒新的头节点线程 if (h == head) // loop if head changed break; &#125; &#125; // 可以看到释放许可的主逻辑就是doReleaseShared // 上文已经分析过在此不再赘述 public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; 运行图景 经过上面的源码分析，估计大部分人心里有点数了，可能还形不成清晰的运行图景或者说直觉性的认识，那么接下来说下我自己的一点理解。 整个的图景是这样子的：对于独占模式，因为只有一个线程能获取许可，进而也只有一个线程释放许可，只会叫醒队伍头部的一个线程，这样整个队列是串行出列，并行入列，有点像排队坐公交，虽然队伍后面挤作一团，队伍前面还是有序的，一个一个的上车；对于共享模式而言，由于允许多个线程一起运行，也就是多个线程获得许可，同样也会有多个线程释放许可，这就需要叫醒队伍里多个线程，整个队列的样子是并行出列，并行入列。 忽略不必要的细节，来看看独占和共享模式下主逻辑的函数调用栈： 上图左边是独占模式的调用栈，右边是共享模式的调用栈。可以清晰看到为啥共享模式的可以唤醒多个节点，是因为它的调用栈形成了一个环，这样它就不会不停地叫醒后面的共享节点，就像一个连锁反应，并且获取许可和释放许可都会启动这个连锁反应；而独占模式没有形成环，叫醒一个节点就返回了，并且由于共享模式下获取和释放许可都会调用doReleaseShared，二者会形成竞争，这也是doReleaseShared内部使用CAS操作的一个原因。 总结一下，AQS其实就是一个由状态变量和CLH虚拟队列组成的一个基础并发组件，它维护了一套线程阻塞、排队、唤醒的机制。它可以工作在共享和非共享两种模式下，共享模式下允许多个线程一起运行，非共享模式只允许一个线程运行。 参考资料： JAVA并发编程实战 Doug Lea, The java.util.concurrent Synchronizer Framework","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://naosense.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Java“锁”记","slug":"Java“锁”记","date":"2019-03-07T14:12:29.000Z","updated":"2025-09-16T02:08:42.959Z","comments":true,"path":"2019/03/07/Java“锁”记/","link":"","permalink":"https://naosense.github.io/2019/03/07/Java%E2%80%9C%E9%94%81%E2%80%9D%E8%AE%B0/","excerpt":"内置锁和显示锁 内置锁其实是相对显示锁来说的，说白了内置锁就是synchronized所代表Java原生锁机制，Jdk5.0之后又引入了Lock及其子类ReentrantLock这样一种新的锁机制。从加锁和内存语义上二者一样，只不过后者添加了一些其他功能，可以实现诸如轮询锁、超时锁和中断锁的功能。","text":"内置锁和显示锁 内置锁其实是相对显示锁来说的，说白了内置锁就是synchronized所代表Java原生锁机制，Jdk5.0之后又引入了Lock及其子类ReentrantLock这样一种新的锁机制。从加锁和内存语义上二者一样，只不过后者添加了一些其他功能，可以实现诸如轮询锁、超时锁和中断锁的功能。 public interface Lock &#123; void lock(); void lockInterruptibly() throw InterruptedException; boolean tryLock(); boolean tryLock(long timeout, TimeUnit unit) throw InterruptedException; void unlock(); Condition newCondition(); &#125; 如果内置锁是一个Lock的话，它只有lock()和unlock()方法。从锁的基本属性上说，内置锁和显示锁都是可重入的，内置锁是非公平的，显示锁还可以设置为公平的。 tryLock和lock的区别是前者获得锁返回true，获取不到返回false，都是立马返回，而后者如果获取不到将会阻塞到那里。 另外由于内置锁是自动释放，而显示锁必须手动释放，这就形成了显示锁的调用模式如下面这样： Lock lock = ...; lock.lock(); try &#123; // 逻辑 &#125; finally &#123; lock.unlock(); &#125; 也就是锁的释放必须放在finally中，确保锁可以释放。 从ReentrantLock衍生出来一个ReentrantReadWriteLock，为啥要有读写锁呢？其实是基于这样的原则，读写和写写是会引起线程安全问题的，所以都需要同步，前者是因为可见性，后者是因为一致性，但是读读是不需要同步的，所以讲读写拆分开来以提高性能。这就好比原来大家都排一个队，现在拆成两个队，自然排队等待的时间就短了。 闭锁 闭锁就像一个门，等待一个“事件”开门（结束状态），在开门之前不允许任何人（线程）通过，在此之前大家只能在城门前面等待。只不过城门可以重复的开闭，闭锁只是一次性的。 具体到Java中，闭锁的实现就是CountDownLatch，它可以用来实现等待某种条件满足后才把线程放行的功能，比如资源就绪、服务启动、某个操作执行等等。 信号量 信号量是用来控制同时访问某个资源的特定数量，或者同时执行某个操作的数量，有点像地铁中的限流。 从某种程度上讲，锁有点像一个二值的信号量，也就是初始值为1的信号量，不同之处是锁是可重入的，信号量不可。 栅栏 栅栏和闭锁类似，它也能阻塞一组线程直到某个事件发生。区别在于栅栏要求线程都到达栅栏位置，才能继续执行，即所谓的闭锁等待的是事件，栅栏等待的是线程。如果对比现实中的例子，闭锁犹如大家去登山，商议好早晨8点出发，无论人齐不齐，到8点大家就出发，而栅栏就类似于大家登一段就在一个歇息点等一等人，等人齐再往上登。 原子变量 原子变量实际上是一种乐观锁技术，即利用冲突检测来判断是否有来自其他线程的干扰，当进行修改操作时，先把变量的当前值current取出来，然后用一个原子的比较交换操作（CAS）对变量进行修改。有两种情况：如果变量的当前值还等于current说明这中间没有线程修改变量，修改变量值为新值；如果当前值不等于current了，说明中间有线程修改变量，重试。 以一个典型的count++为例，大家知道++这种操作实际上包括三步： 获取count当前值current 当前值加一newvalue 将newvalue赋值给count 如果两个线程同时修改count的值，假如两个线程的时序如下： =====1===========+1================= =========1===========+1============= 假设count的当前值为1，两个线程分别进行了++的操作，最后的值为2，第一个++操作被“覆盖”了。如果把上面2、3步换成一个CAS操作就不会发生上面的情况了，因为执行第二次操作时会拿count的旧值1和新值2对比，一对比发现不一样，说明其他线程修改了变量，这时候第二个线程会进入下一次的CAS操作，重新获取count值2，比较当前值2等于原来的值，修改为新值3。 原子变量作为一种非阻塞的锁技术，适用在读操作比较多、竞争不那么激烈的场景，这适用于大部分的业务场景。但同时原子变量也有其局限，原子锁只能保证单一变量的线程安全。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://naosense.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"分布式","slug":"分布式","permalink":"https://naosense.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"强烈推荐Andrew Ng的机器学习课程","slug":"强烈推荐Andrew-Ng的机器学习课程","date":"2019-01-21T18:11:07.000Z","updated":"2025-09-16T02:08:42.975Z","comments":true,"path":"2019/01/21/强烈推荐Andrew-Ng的机器学习课程/","link":"","permalink":"https://naosense.github.io/2019/01/21/%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90Andrew-Ng%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B/","excerpt":"从12.30到1.17修完了Coursera上的Andrew Ng的机器学习课程，计划上又可以划掉一件事了。 课程的主要内容大致如下： 监督学习：线性回归、逻辑回归、神经网络、支持向量机 非监督学习：K均值、主成分分析、异常检测 案例：垃圾邮件 特殊领域：推荐系统（协同过滤）、大规模机器学习（map-reduce） 方法论：偏差/方差问题、正则化、学习曲线、误差分析、如何收集样本数据、机器学习流水线、上限分析等等","text":"从12.30到1.17修完了Coursera上的Andrew Ng的机器学习课程，计划上又可以划掉一件事了。 课程的主要内容大致如下： 监督学习：线性回归、逻辑回归、神经网络、支持向量机 非监督学习：K均值、主成分分析、异常检测 案例：垃圾邮件 特殊领域：推荐系统（协同过滤）、大规模机器学习（map-reduce） 方法论：偏差/方差问题、正则化、学习曲线、误差分析、如何收集样本数据、机器学习流水线、上限分析等等 习题主要是两大类：选择题和编程题（matlab），选择题又分为单选和多选，只有答案没有解释，有些题难度还是有的。编程题自认为相对简单，只需了解简单的matlab编程和矩阵知识，上课好好听讲基本上就是满分。我的总成绩为98.4，编程题基本上100，选择题错了两个，想参考的可以戳这里。 课程用我自己的话总结就是：不装逼，说人话，循循善诱，详略得当。 记得Andrew Ng在讲到神经网络的反向传播算法时，花了大量的篇幅来介绍这一算法，尽管如此还是害怕有些学生不会影响自信心，他这样说道：作为多年的从业者，有时候猛然想起这个算法也得想好一会，这个算法不是那么直观。在讲到svm还是哪一课的时候，记不太清了，他又鼓励同学们：原理不懂也没有关系，事实上这些算法的原理直到最近我才搞明白，事实证明不了解算法的原理也能很好的使用它们。这一点比那些一瓶子不满半瓶子晃荡的老师强多了。 抛开老师的谦虚，在初学一样东西时，适当的忽略一些底层细节是一个很重要的学习方法。我发现不少同学包括我自己在学习机器学习的时候遇到一个算法，不由自主的想了解全部的数学细节，不这样心里就不踏实，以至于还没走到机器学习的门槛就已经倒在线性代数、概率论、数值分析的汪洋大海里了，其实这是一个本末倒置的学习方法。这就好比买了一辆汽车，难道你还要去修一门内燃机原理的课程？当然这不是鼓励大家囫囵吞枣，而是让大家抓住重点，不要把面铺的太广，否则收不回来。真正好的方法是学机器学习就把重点放在机器学习上，一些底层细节就当成既有的事实，等到学有余力再重点突破。所以学习的时候一定要控制自己那种无限扣细节的冲动。 另外一个其他课程没有或者很少提到的是这门课程Andrew Ng介绍了很多的机器学习方法论，比如学习曲线、误差分析、流水线、上线分析等等，这才是真正的金玉良言，可遇不可求的。众所周知，象棋的规则很简单，难的是如何开局，如何化解对手的攻势，如何一步一步积累自己的优势达到胜利，这些都是需要在实践中摸索，如果纯靠自己摸索，新手要走不少的弯路，而如果一开始别人把这些告诉你，你就可以事半功倍。 观察课程的主要内容可以看到这门课介绍的算法并不是很全面，比如常见的决策树、随机森林、贝叶斯算法等等都没有，有人可能觉得这是课程的缺点，我倒觉得这反而是优点，有道是一招鲜吃遍天，机器学习的算法是有固定的模式的，比如监督学习，基本上都是提出一个假设函数，然后去拟合现有数据，也就是生成一个代价函数，然后用数学方法找到使代价函数最小的参数，所以学会这些典型的算法再去学其他的算法没什么难度；另一个是影响机器学习性能的关键往往并不是算法本身而是你拥有的数据量、特征的选取、如何进行误差分析、如何进行模型的调优，这一点课程也有论述，我就不班门弄斧了。总之，这是一门我强烈推荐的课程，适合入门者进阶者。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://naosense.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"coursera","slug":"coursera","permalink":"https://naosense.github.io/tags/coursera/"}]},{"title":"2018年终总结","slug":"2018年终总结","date":"2019-01-01T17:59:47.000Z","updated":"2025-09-16T02:08:42.938Z","comments":true,"path":"2019/01/01/2018年终总结/","link":"","permalink":"https://naosense.github.io/2019/01/01/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"18年5月份的时候写了个中期计划，当时主要写了四件事： Coursera上Algorithms课程，现在已进行到上半部分第二周。 啃完计算机程序与构造，做一部分习题。 至少每隔一天跑一次步，身体革命本钱。 每周一篇博客，不限制长度。","text":"18年5月份的时候写了个中期计划，当时主要写了四件事： Coursera上Algorithms课程，现在已进行到上半部分第二周。 啃完计算机程序与构造，做一部分习题。 至少每隔一天跑一次步，身体革命本钱。 每周一篇博客，不限制长度。 这四件事目前看来只有1完成了，其他三件都没有完成。当时还说不要打脸，果然打脸了(/ □ \\)。我知道借口永远是逃避问题的最好方法，所以不打算找借口，计划没完成主因确实是自控力不够，所以只好不要脸的把没完成的计划放在19年了。新的计划为： Andrew Ng的机器学习学完，1月份 计算机程序与构造，2-4月份，三个月时间，习题尽量做 每周三次跑步，周五-周日，每天晚上 博客记得写，但最好有趣，有用 在执行计划的过程中，发现了一些计划太草率，所以进行了微调，比如“每周一篇博客，不限制长度”，在执行的过程中，发现想写一篇好的博客其实挺费心的，无病呻吟的文章又不想写，所以我稍微改了下，不要为了写而写。另外加了一条机器学习计划，因为人工智能确实越来越重要，自己对这方面也比较感兴趣。今年体检报告说肥胖，甘油三酯偏高，所以跑步这一条肯定需要更好的执行下去，但是在上年执行计划的时候，每隔一天的跑法受下班时间和下班状态影响比较大，所以我把时间调整到周末。 最后，祝大家新年快乐，心想事成吧~","categories":[],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://naosense.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"}]},{"title":"终于修完Algorithm了","slug":"终于修完Algorithm了","date":"2018-12-16T20:11:32.000Z","updated":"2025-09-16T02:08:43.025Z","comments":true,"path":"2018/12/16/终于修完Algorithm了/","link":"","permalink":"https://naosense.github.io/2018/12/16/%E7%BB%88%E4%BA%8E%E4%BF%AE%E5%AE%8CAlgorithm%E4%BA%86/","excerpt":"磕磕绊绊，终于把Coursera上的Algorithm课修完了，中间有段时间中断了，因为工作太累，下班或者周末实在不愿意面对电脑了。Algorithm这门课整体难度不大，但是课时较长，所以需要能坚持下来。老师在理论和应用上做了比较好的平衡，不会太枯燥，不少习题也都是为了解决现实中的实际问题设计的，这点我非常喜欢，技术最终是为实际应用服务的，纯理论的东西确实提不起兴趣。","text":"磕磕绊绊，终于把Coursera上的Algorithm课修完了，中间有段时间中断了，因为工作太累，下班或者周末实在不愿意面对电脑了。Algorithm这门课整体难度不大，但是课时较长，所以需要能坚持下来。老师在理论和应用上做了比较好的平衡，不会太枯燥，不少习题也都是为了解决现实中的实际问题设计的，这点我非常喜欢，技术最终是为实际应用服务的，纯理论的东西确实提不起兴趣。 下面是本次课程的10次作业， Percolation Deques and Randomized Queues Collinear Points 8 Puzzle Kd-Trees WordNet Seam Carving Baseball Elimination Boggle Burrows–Wheeler 给我印象最深刻的是第八周的Baseball Elimination，这个作业的大概意思是根据棒球联赛积分表找出哪些球队已经被淘汰，说实话看过体育比赛的对这一点都是有感触的，有时候找出这样的球队不是那么容易，没想到在这里可以使用这么巧妙的一种方法解决，具体方法我就不剧透了。 这门课虽说修完了，但是自我感觉并不是里面的东西都理解了，甚至可以说是大部分都没有理解，或者说理解的不够深刻，那是不是白学了？肯定不是，我觉得最大的收获就是学到了一些问题有更好的解决方法这个事实，而不是解决方法本身，在上课之前可能某些问题我也知道一些方法，但都是一些笨办法，上完这门课相当于给了我一个更低的上界。总之，用大白话说就是增长了眼界。","categories":[],"tags":[{"name":"coursera","slug":"coursera","permalink":"https://naosense.github.io/tags/coursera/"},{"name":"算法","slug":"算法","permalink":"https://naosense.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"DrRacket使用技巧总结","slug":"DrRacket使用技巧总结","date":"2018-12-03T14:27:03.000Z","updated":"2025-09-16T02:08:42.958Z","comments":true,"path":"2018/12/03/DrRacket使用技巧总结/","link":"","permalink":"https://naosense.github.io/2018/12/03/DrRacket%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/","excerpt":"引用其他文件的函数 假设test.scm想引用max-two.scm中的一个函数max-two，可以这样， test.scm #lang sicp (#%require rackunit) (#%require &quot;max-two.scm&quot;) (max-two 2 3 4)","text":"引用其他文件的函数 假设test.scm想引用max-two.scm中的一个函数max-two，可以这样， test.scm #lang sicp (#%require rackunit) (#%require &quot;max-two.scm&quot;) (max-two 2 3 4) max-two.scm #lang sicp ;; 千万别忘了这一句 (#%provide (all-defined)) (define (max-two x y z) (define (min-three x y z) (cond ((&gt;= x y) (if (&gt;= y z) z y)) (else (if (&gt;= x z) z x)))) (- (+ x y z) (min-three x y z))) Window10安装sicp包 7.1版本ui界面安装pkg报错cadr: contract violation，可以使用命令行安装，命令如下： raco pkg install --auto sicp 从Vim中运行scheme程序 可以做如下配置： augroup scheme autocmd! &quot; 加上&lt;esc&gt;可以避免弹出命令行必须按两次enter才能回到代码 autocmd filetype scheme nnoremap &lt;F9&gt; :w&lt;cr&gt;:! racket %&lt;cr&gt;&lt;esc&gt; augroup end 这样直接按下F9就能运行了","categories":[],"tags":[{"name":"racket","slug":"racket","permalink":"https://naosense.github.io/tags/racket/"},{"name":"lisp","slug":"lisp","permalink":"https://naosense.github.io/tags/lisp/"}]},{"title":"Jsonp到底是个什么东西","slug":"JSONP到底是个什么东西","date":"2018-11-22T18:43:44.000Z","updated":"2025-09-16T02:08:42.959Z","comments":true,"path":"2018/11/22/JSONP到底是个什么东西/","link":"","permalink":"https://naosense.github.io/2018/11/22/JSONP%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/","excerpt":"这个世界上有好多事对你来说是模棱两可，可能是这样或者那样的原因你没有动力去了解它，以至于它久久萦绕在你的心头，Jsonp就是这么一件事。今天终于有动力想了解一番，经过一番热火朝天的谷歌百度后，发现Jsonp这东西说起来简单的很啊，我自己用一句话总结就是：使用script标签进行跨域访问。由于跨域请求返回的数据和JSON相关，故而得名Jsonp。","text":"这个世界上有好多事对你来说是模棱两可，可能是这样或者那样的原因你没有动力去了解它，以至于它久久萦绕在你的心头，Jsonp就是这么一件事。今天终于有动力想了解一番，经过一番热火朝天的谷歌百度后，发现Jsonp这东西说起来简单的很啊，我自己用一句话总结就是：使用script标签进行跨域访问。由于跨域请求返回的数据和JSON相关，故而得名Jsonp。 众所周知，javascript有同源策略的限制，是不允许跨域访问的，比如位于a.xxx.com下面的js代码， function print_log(json) &#123; console.log(json.name); &#125; var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://b.xxx.com/test?callback=print_log', true); 假设/test?callback=print_log接口的返回值为： print_log(&#123;&quot;name&quot;: &quot;小明&quot;, &quot;id&quot; : 1823, &quot;rank&quot;: 7&#125;) /test接口返回了一段js代码，这段代码如果正常执行的话将会打印出“小明”，但是由于同源策略，位于a.xxx.com上的js想请求b.xxx.com上的test接口是无法通过的，这就是常说的“js无法跨域”。有没有办法实现跨域呢，大神们想了各种各样的办法，其中之一就是Jsonp，具体来说就是虽说js不能跨域，但是有个例外，那就是script标签可以，利用script标签的跨域特性访问其他域名上的接口，动态生成一段js代码，这样就绕过了同源策略，实现了跨域访问。具体代码如下， var script = document.createElement('script'); script.setAttribute('src', 'http://b.xxx.com/test?callback=print_log'); 这实际上相当于执行下面的代码， function print_log(json) &#123; console.log(json.name); &#125; print_log(&#123;&quot;name&quot;: &quot;小明&quot;, &quot;id&quot; : 1823, &quot;rank&quot;: 7&#125;) 不出意外的话可以看到打印出的“小明”了。","categories":[],"tags":[{"name":"jsonp","slug":"jsonp","permalink":"https://naosense.github.io/tags/jsonp/"},{"name":"javascript","slug":"javascript","permalink":"https://naosense.github.io/tags/javascript/"}]},{"title":"阿汤哥不减当年啊","slug":"阿汤哥不减当年啊","date":"2018-09-16T12:55:23.000Z","updated":"2025-09-16T02:08:43.026Z","comments":true,"path":"2018/09/16/阿汤哥不减当年啊/","link":"","permalink":"https://naosense.github.io/2018/09/16/%E9%98%BF%E6%B1%A4%E5%93%A5%E4%B8%8D%E5%87%8F%E5%BD%93%E5%B9%B4%E5%95%8A/","excerpt":"","text":"阿汤哥老了啊，昔日的小鲜肉也是满脸褶子了，岁月真是杀猪刀啊。两张活动送的电影券，晚上10点的场，里面总共6个人，碟中谍的套路没变，剧情也没怎么变，演员也没怎么变，只是时间变了，为情怀支持一波！","categories":[],"tags":[{"name":"碟中谍","slug":"碟中谍","permalink":"https://naosense.github.io/tags/%E7%A2%9F%E4%B8%AD%E8%B0%8D/"},{"name":"电影","slug":"电影","permalink":"https://naosense.github.io/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"马上TI了，有一起玩的道友吗","slug":"马上TI了，有一起玩的道友吗","date":"2018-08-10T21:35:49.000Z","updated":"2025-09-16T02:08:43.026Z","comments":true,"path":"2018/08/10/马上TI了，有一起玩的道友吗/","link":"","permalink":"https://naosense.github.io/2018/08/10/%E9%A9%AC%E4%B8%8ATI%E4%BA%86%EF%BC%8C%E6%9C%89%E4%B8%80%E8%B5%B7%E7%8E%A9%E7%9A%84%E9%81%93%E5%8F%8B%E5%90%97/","excerpt":"","text":"马上TI了，又到了神奇的偶数年，希望中国军团如愿以偿。老年dota玩家不能亲临现场加油助威，只能在家多玩几场游戏贡献点人气，求一起玩的d友，分数2000左右吧，娱乐局，主要周末玩。","categories":[],"tags":[{"name":"dota","slug":"dota","permalink":"https://naosense.github.io/tags/dota/"}]},{"title":"谁说大象不能跳舞：基于Java的Markdown预览插件","slug":"谁说大象不能跳舞：基于Java的Markdown预览插件","date":"2018-08-04T11:49:59.000Z","updated":"2025-09-16T02:08:43.026Z","comments":true,"path":"2018/08/04/谁说大象不能跳舞：基于Java的Markdown预览插件/","link":"","permalink":"https://naosense.github.io/2018/08/04/%E8%B0%81%E8%AF%B4%E5%A4%A7%E8%B1%A1%E4%B8%8D%E8%83%BD%E8%B7%B3%E8%88%9E%EF%BC%9A%E5%9F%BA%E4%BA%8EJava%E7%9A%84Markdown%E9%A2%84%E8%A7%88%E6%8F%92%E4%BB%B6/","excerpt":"Java一直以来都给人留下了笨重的印象，按说插件这种轻量的任务根本和Java没啥关系，但是这次我要霸王硬上弓，让大象跳次舞。 跳什么舞呢？这是个问题，突然想起写博客一直困扰自己的一个问题：我一直使用Vim编写Markdown，有时候难免想看看效果，欣赏下文字跳动的样子，但是Vim不支持预览，自己一直用Chrome一款插件Markdown Viewer进行预览，遗憾的是这款插件不支持动态刷新也不支持同步滚动，所以如果你没有一下点出十个信号的手速，这个操作是比较尴尬的。既然这样，能不能用Java整个插件呢？","text":"Java一直以来都给人留下了笨重的印象，按说插件这种轻量的任务根本和Java没啥关系，但是这次我要霸王硬上弓，让大象跳次舞。 跳什么舞呢？这是个问题，突然想起写博客一直困扰自己的一个问题：我一直使用Vim编写Markdown，有时候难免想看看效果，欣赏下文字跳动的样子，但是Vim不支持预览，自己一直用Chrome一款插件Markdown Viewer进行预览，遗憾的是这款插件不支持动态刷新也不支持同步滚动，所以如果你没有一下点出十个信号的手速，这个操作是比较尴尬的。既然这样，能不能用Java整个插件呢？ 整体思路 既然现在Markdown Viewer只能显示不能滚动，那么通过程序将Vim的某种位置信息传给浏览器，然后调用js滚动到这个位置不就可以了吗？想让浏览器显示网页而且网页的内容还得不停的变，需要一个Web服务器，这正是Java的强项。从浏览器到Java的路走通了，但是Vim到Java的路怎么走呢？由于Vim不支持Java，二者怎么通信呢，这时看到著名的胶水语言，编程语言界的媒婆Python是被Vim支持的，方案有了：让Python与Java通信。好，这样整个流程就通了。整体框架如下所示： Java服务器 Web这片领域简直就是Java的主场，自然一点问题没有。以前学过Netty，一直没有派上用场，这次终于可以小试牛刀了。 public class HttpRequestHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123; private MarkDownServer server; public HttpRequestHandler(MarkDownServer server) &#123; this.server = server; &#125; @Override public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) &#123; String uri = request.uri(); if (uri.startsWith(&quot;/index&quot;)) &#123; index(ctx, request); &#125; else if (uri.startsWith(&quot;/ws&quot;)) &#123; ctx.fireChannelRead(request.retain()); &#125; else if (uri.startsWith(&quot;/js&quot;) || uri.startsWith(&quot;/css&quot;)) &#123; transferStaticFile(ctx, request); &#125; else if (uri.startsWith(&quot;/image&quot;)) &#123; image(ctx, request); &#125; else &#123; commonResponse(ctx, request, FileUtils.getBytes(&quot;How do you do&quot;), MiMeType.PLAIN); &#125; &#125; &#125; 上面即是Web服务的框架程序，细节就不贴了。但是有几个问题大家要注意： 服务器怎么和浏览器通信？ 网页里的js和css怎么返回？ Python怎么和Java通信？ 上面的程序处理的正是前两个问题。 先说服务器怎么和浏览器通信，最初定的是ajax，但是后来找到一种更好的方案WebSocket，WebSocket可以让浏览器和服务器保持长连接，有更好的流畅性和速度，这就是上面/ws所处理的内容。 第二个问题，网页中的静态文件js和css需要让服务器返回，就像tomcat这些通用服务器做的那样，这里没什么复杂的，就是一个简单的文件读写，只有一点需要注意：文件的编码，否则页面会乱码。 第三个问题，Python怎么和Java通信，最初采用的是py4j，优点是这个库可以直接在Python里调用Java程序，缺点是需要安装额外的库，对于有着代码洁癖的我不是一个完美的方案，后来一想既然已经有了Web服务器，直接使用Http不就可以了，所以将方案又改为使用Http与Java通信，经过实验，这个方案虽然不用安装额外的库了，但是由于Python的原装urllib库不能保持长连接，随着连接的增多，速度会慢慢降下来，看来还得另寻出路。 private class SocketServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ByteBuf in = (ByteBuf) msg; String string = in.toString(CharsetUtil.UTF_8); LOGGER.info(&quot;Server received: &quot; + string); String[] data = string.split(SEP); switch (data[0]) &#123; case &quot;start&quot;: server = MarkDownServer.getInstance(); server.setTheme(data[2]); server.start(Integer.parseInt(data[1])); break; case &quot;sync&quot;: server.broadcast(&quot;sync&quot;, data[1], Base64Utils.decode2String(data[2]), Integer.parseInt(data[3])); break; case &quot;close&quot;: server.broadcast(&quot;close&quot;, data[1], &quot;&quot;, 1); break; case &quot;stop&quot;: server.destroy(); System.exit(0); break; default: LOGGER.info(&quot;Command &#123;&#125; is unknown&quot;, data[0]); &#125; &#125; &#125; 这就是最终的解决方案：返璞归真，直接使用最底层的Socket与Java通信。经过实验，速度提升明显，而且由于Socket客户端和服务端可以保持长连接，没有运行一段时间，速度变慢的缺点。 通信主要包含四种情况： start：启动Http服务器 sync：同步内容和位置 close：关闭预览窗口 stop：停止Http服务器，退出系统 Java-&gt;浏览器 var url = 'ws://127.0.0.1:' + window.location.port + '/ws'; if (!WebSocket) &#123; console.warn('WebSocket is not support'); &#125; else &#123; console.log('Try to connect ' + url); var ws = new WebSocket(url); ws.onclose = function () &#123; console.log('Disconnected'); close(); &#125;; ws.onmessage = function (d) &#123; console.log('Response : ' + d.data.length); var data = JSON.parse(d.data); var path = $('#path'); if (path.val() === '') &#123; init(data); &#125; else &#123; if (path.val() === data.path) &#123; if (data.command === 'close') &#123; close() &#125; else if (data.command === 'sync') &#123; sync(data); &#125; &#125; &#125; &#125;; &#125; var init = function (data) &#123; $('title').html(data.path); $('#path').val(data.path); $('.markdown-body').html(''); markdown_refresh(data.units); highlight_code(); scroll_if_possible(); &#125;; var sync = function (data) &#123; markdown_refresh(data.units); highlight_code(); scroll_if_possible(); &#125;; 前端就是一个WebSoket客户端，接受两种指令：close和sync，前者用于关闭页面，后者用于同步信息。 大致的流程是浏览器第一次收到服务器消息调用init进行初始化，它会将网页的title和页面元素#path置为文件的路径，将.markdown-body清空，因为浏览器刚启动时会启动一个index介绍页面，需要将其清空，然后调用markdown_refresh刷新显示新的内容，内容显示后hightlight_code负责高亮其中的代码，最后用scroll_if_possible滚动到指定位置。往后浏览器每收到服务器消息都会调用sync同步信息和位置，sync和init内部代码差不多，我就不再赘述了。 Vim-&gt;Java 以上走通了Java到浏览器的路，下面看看如何走Vim到Java的路，在整体思路中提到Vim支持Python，所以这条路的主角就是Python，最初是发送Http请求与Java交互，后来又改为使用Socket，原因参看Java服务器那一节。最终的代码如下： SEP = '\\r\\n\\r\\n' EOF = '$_@' s = None def start(port, theme): global s s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(('127.0.0.1', 23789)) s.send('start' + SEP + str(port) + SEP + theme + EOF) def sync(path, content, bottom): s.send('sync' + SEP + path + SEP + base64.b64encode(content) + SEP + str(bottom) + EOF) def close(path): s.send('close' + SEP + path + EOF) def stop(): s.send('stop' + EOF) s.close() 变量解释：path表示打开文件的路径，content为buffer内容，bottom为当前窗口的末行。 这里的函数和Java Socket服务器那一节里处理的四种情况一一对应，想不起来的可以回去再看下。你可能注意到每次发送消息后面都加了一个EOF，这是因为Tcp是基于流的通信协议，需要一种策略告诉接受方什么时候是一条完整的消息，这里采用的是终结符的形式，即每条消息后面都加了一个EOF告知接收方已经接受了一条完整的消息。另外需要对content进行base64编码，因为content里可能包含一些特殊字符，传输过程中对这些字符处理不一致会导致出错。 下一步就是在Vimscript里调用Python，我就不贴代码了。 一步之遥 至此，插件就基本编写完成了，似乎离成功只有一步之遥了，但成功往往没那么简单。运行一下，乍看起来效果还可以，但是存在两个比较严重的问题： MathJax抖动 每次滚动时，如果页面里包含MathJax表达式，页面就会一抖一抖的。这是因为所有的内容都存在一个&lt;article&gt;&lt;/article&gt;标签里，前端每次加载内容，都要刷新内容里所有的MathJax表达式，表达式加载需要时间，未加载完成时有一个空的占位，加载完成使用真正的元素替换，类似网页中的图片加载流程，占位和真正的元素大小不一致，这样给人的感觉就是页面一抖一抖的，最初用的代码如下： MathJax.Hub.Config(&#123; extensions: [&quot;tex2jax.js&quot;], jax: [&quot;input/TeX&quot;, &quot;output/SVG&quot;], tex2jax: &#123; inlineMath: [ ['$','$'], [&quot;\\\\(&quot;,&quot;\\\\)&quot;] ], displayMath: [ ['$$','$$'], [&quot;\\\\[&quot;,&quot;\\\\]&quot;] ] &#125;, messageStyle: &quot;none&quot; &#125;); MathJax.Hub.Queue([&quot;Typeset&quot;, MathJax.Hub]); 那怎么解决呢？既然是因为刷新全部的MathJax表达式，那么不让它刷新全部，让它刷新的内容越少抖动不就越小了？查阅MathJax的文档，找到一个函数MathJax.Hub.Queue(['Typeset', MathJax.Hub, element])，它只会刷新页面元素element里的表达式，修改服务器同步信息代码，改全量同步为增量同步，如果里面包含MathJax表达式就调用上述命令刷新。 新的前端代码如下： $.each(units, function (i, u) &#123; if (u.operate === 'REPLACE') &#123; if (u.id === 'toc_container') &#123; $('.markdown-body').css('padding-left', '200px'); var toc = $('#' + u.id); toc.html(u.content); toc.show(); &#125; else &#123; $('#' + u.id).replaceWith(u.content); &#125; &#125; else if (u.operate === 'APPEND') &#123; $('.markdown-body').append(u.content); &#125; else if (u.operate === 'REMOVE') &#123; if (u.id === 'toc_container') &#123; $('.markdown-body').css('padding-left', '45px'); var cot = $('#' + u.id); cot.html(''); cot.hide(); &#125; else &#123; $('#' + u.id).remove(); &#125; &#125; if (u.isMathJax === 1) &#123; MathJax.Hub.Queue(['Typeset', MathJax.Hub, u.id]); &#125; &#125;) 本地图片不显示 由于浏览器安全策略的限制，页面的img标签不能打开本地图片，即形如&lt;img src='D:\\path-to-img.jpg'/&gt;这种写法浏览器不会加载图片，而是提示“Not allowed to load local resource”。一般在文章未发布到网上时，图片地址往往写一个本地的绝对路径，如果不能显示本地图片的话将会大大影响方便性。那么该怎么办呢，第一种方法是写相对路径，即&lt;img src='/path-to-img.jpg'/&gt;，这种方式有很大的局限性，即必须将图片放在一个位置，与网页呈一种相对关系；另一种是写的时候还是写绝对路径，经过程序转成服务器地址，然后通过服务器将图片返给浏览器。显然第二种方式更加灵活，核心代码如下： private static void transformLocalImgSrc(Element element) &#123; Elements images = element.select(&quot;img&quot;); for (Element img : images) &#123; String src = img.attr(&quot;src&quot;); if (!src.startsWith(&quot;http&quot;)) &#123; if (isWindows()) &#123; img.attr(&quot;src&quot;, &quot;/image?path=&quot; + src.replace(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;)); &#125; else &#123; img.attr(&quot;src&quot;, &quot;/image?path=&quot; + src); &#125; &#125; &#125; &#125; 上面的代码将形如D:\\path-to-img.jpg的本地路径转成http://127.0.0.1:7788/image?path=D:\\\\path-to-img.jpg(windows系统，其他系统路径与此略有不同)，然后由服务器将图片内容返回。这样就绕过了浏览器的安全策略，实现本地图片的加载了。 阳光总在风雨后 尽管经过了一些风雨，最后还是看到胜利的曙光了。这个项目够小，涵盖的语言和知识并不少，作为一个练手的项目还是不错的，如果碰巧还能给生活提供点便利，何乐而不为呢？想了解大象跳舞的更多细节请戳github。 参考资料： Netty in action write vim plugin in python","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"vim","slug":"vim","permalink":"https://naosense.github.io/tags/vim/"},{"name":"markdown","slug":"markdown","permalink":"https://naosense.github.io/tags/markdown/"},{"name":"python","slug":"python","permalink":"https://naosense.github.io/tags/python/"}]},{"title":"Vim Markdown预览插件markdown-preview-sync","slug":"Vim Markdown预览插件markdown-preview-sync","date":"2018-07-29T10:24:06.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2018/07/29/Vim Markdown预览插件markdown-preview-sync/","link":"","permalink":"https://naosense.github.io/2018/07/29/Vim%20Markdown%E9%A2%84%E8%A7%88%E6%8F%92%E4%BB%B6markdown-preview-sync/","excerpt":"花了大概两个星期整了个Vim预览插件markdown-preview-sync，主要参考了Markdown Viewer和markdown-preview.vim这两款插件，感谢这两款插件的作者。 支持如下特性： 代码高亮 MathJax 自定义CSS GFM-TABLE 目录TOC 运行效果如图：","text":"花了大概两个星期整了个Vim预览插件markdown-preview-sync，主要参考了Markdown Viewer和markdown-preview.vim这两款插件，感谢这两款插件的作者。 支持如下特性： 代码高亮 MathJax 自定义CSS GFM-TABLE 目录TOC 运行效果如图： 为了用户体验，预览并不是实时显示的，而是在换行时或保存时。这一点是有意为之的，毕竟大家对Markdown语法都了如指掌了，只是想偶尔看下效果。相信大家都有这样的体验，眼睛不停的在编辑屏和预览屏来回切换，眼睛很累，同时思路也很容易被打断，而且根据我个人的实验，同步频率太快会影响Vim的流畅性。 最后再啰嗦一句，欢迎大家使用并提出宝贵意见！","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://naosense.github.io/tags/vim/"},{"name":"markdown","slug":"markdown","permalink":"https://naosense.github.io/tags/markdown/"}]},{"title":"Java的equals和hashCode方法浅谈","slug":"Java的equals和hashCode方法浅谈","date":"2018-07-02T16:20:39.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2018/07/02/Java的equals和hashCode方法浅谈/","link":"","permalink":"https://naosense.github.io/2018/07/02/Java%E7%9A%84equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95%E6%B5%85%E8%B0%88/","excerpt":"一、概述 equals和hashCode作为Java基础经常在面试中提到，比如下面几个问题： equals和==有什么区别？ equals和hashCode有什么关系？ equals和hashCode如何编写？ 对于第一个问题不少人只停留在字符串equals比较的是内容，==比较的是内存地址，而对equals的本质极少过问。第二个问题，大多数都知道答案，也有不少记反了，但是更进一步为什么是那样的关系，就不知道了。对于第三个问题，大部分人一上手就把方法签名写错了，就别谈正确的写出实现了。带着这些问题，接下来谈谈自己的一点理解。","text":"一、概述 equals和hashCode作为Java基础经常在面试中提到，比如下面几个问题： equals和==有什么区别？ equals和hashCode有什么关系？ equals和hashCode如何编写？ 对于第一个问题不少人只停留在字符串equals比较的是内容，==比较的是内存地址，而对equals的本质极少过问。第二个问题，大多数都知道答案，也有不少记反了，但是更进一步为什么是那样的关系，就不知道了。对于第三个问题，大部分人一上手就把方法签名写错了，就别谈正确的写出实现了。带着这些问题，接下来谈谈自己的一点理解。 二、equals方法 先来看见equals方法的签名， public boolean equals(Object obj) &#123; return (this == obj); &#125; 可以看到入参是Object，很多人没有注意到这一点，上来就写错了。equals方法顾名思义就判断对象的相等性，默认实现就是==，那么说到二者的区别，个人理解，equals方法是一种用户定义的“逻辑等”，而==是一种“物理等”，用俗语解释就是，equals判断是否相同，==判断是否一样。 equals方法在编写的时候需要遵循以下原则： 自反性 对称性 传递性 一致性 下面展开说一下， 自反性的意思是，对于一个非null的对象x，x.equals(x)一定为true，这是显而易见的，无须赘述。 对称性，对于非null对象x、y，x.equals(y) == true，当且仅当y.equals(x) == true。来看一个来自《Effective Java》的例子， // Broken - violates symmetry! public final class CaseInsensitiveString &#123; private final String s; public CaseInsensitiveString(String s) &#123; this.s = Objects.requireNonNull(s); &#125; // Broken - violates symmetry! @Override public boolean equals(Object o) &#123; if (o instanceof CaseInsensitiveString) return s.equalsIgnoreCase( ((CaseInsensitiveString) o).s); if (o instanceof String) // One-way interoperability! return s.equalsIgnoreCase((String) o); return false; &#125; ... // Remainder omitted &#125; CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;); String s = &quot;polish&quot;; List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;(); list.add(cis); // true or false list.contains(s); 在JDK8运行list.contains(s)返回false，但是有的JDK可能会返回true，甚至直接崩溃，所以如果违反了对称性，程序的行为是不可预测的。 传递性，对于非null对象x、y、z，如果x.equals(y) == true且y.equals(z) == true，那么x.equals(z) == true。同样是来自《Effective Java》的一个例子， public class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public boolean equals(Object o) &#123; if (!(o instanceof Point)) return false; Point p = (Point)o; return p.x == x &amp;&amp; p.y == y; &#125; ... // Remainder omitted &#125; public class ColorPoint extends Point &#123; private final Color color; public ColorPoint(int x, int y, Color color) &#123; super(x, y); this.color = color; &#125; // Broken - violates transitivity! @Override public boolean equals(Object o) &#123; if (!(o instanceof Point)) return false; // If o is a normal Point, do a color-blind comparison if (!(o instanceof ColorPoint)) return o.equals(this); // o is a ColorPoint; do a full comparison return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color; &#125; ... // Remainder omitted &#125; ColorPoint p1 = new ColorPoint(1, 2, Color.RED); Point p2 = new Point(1, 2); ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE); 显然ColorPoint的equals实现违反了传递性，p1.equals(p2) == p2.equals(p3) != p1.equals(p3)。假如Point有两个子类ColorPoint和SmellPoint，colorPoint.equals(smellPoint)将会导致无限递归，最终导致内存耗尽。引用《Effective Java》的说法， There is no way to extend an instantiable class and add a value component while preserving the equals contract, unless you’re willing to forgo the benefits of object-oriented abstraction. 这句话的大意是如果你继承扩展一个类，就没法再保持equals的原则了，除非放弃使用继承。放弃继承？这不是让我们因噎废食嘛，咦，别说，还真能放弃继承，那就是组合，因为本文的重点是equals和hashCode就不展开了。 一致性，对于非null对象x、y，多次调用x.equals(y)返回一致。一致性意味着equals方法不要依赖不可靠的变量，这里“可靠”的意思不光意味着“不该变时不变”，还意味着“想获取时能获取到”，比如java.net.URL的equals实现依赖了ip地址，而网络故障时无法获取ip，这是一个不好的实现。 说了那么多，有人可能会说，哎呀这么多原则顾头不顾尾，都要满足，太难了吧，下面列出实现equals的一些tips，照着做实现起来就易如反掌， 使用==判断是否为null或this，如果是前者返回false，后者就返回true。 使用instanceof检测是否是正确的类型，如果不是直接返回false，如果是，强制转换为正确的类型，然后比较与“逻辑等”相关的变量。 三、hashCode方法 hashCode主要用来在Java中哈希数据结构HashMap、HashSet生成哈希值，hashCode的方法签名， public native int hashCode(); 默认实现会将对象的内存地址转化为一个整数，因此只有同一个对象hashCode才一样，即使两个equals返回true的对象hashCode也不一样，如果不进行重写。和equals一样，hashCode也需要满足一些原则： 一致性，和equals相关的变量没有变化，hashCode返回值也不能变化。 两个对象equals返回true，hashCode返回值应该相等。由上面得知，hashCode默认实现不满足这一条件，因此任何类如果实现了equals就必须实现hashCode，确保二者的步调一致，下面来看一个反例， public class Person &#123; private int age; private String name; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (obj == this) &#123; return true; &#125; if (obj instanceof Person) &#123; Person that = (Person) obj; return age == that.age &amp;&amp; Objects.equals(name, that.name); &#125; return false; &#125; &#125; Map&lt;Person, Integer&gt; map = new HashMap&lt;&gt;(); map.put(new Person(10, &quot;小明&quot;), 1); map.get(new Person(10, &quot;小明&quot;)); 初学者可能觉得最后一条语句会返回1，事实上返回的是null，为什么会这样呢？明明将数据放进去了，而数据却像被黑洞吞噬一样，要解释得从HashMap的数据结构说起，HashMap是由数组和链表组成的一种组合结构，如下图，往里存放时，hashCode决定数组的下标，而equals用于查找值是否已存在，存在的话替换，否则插入；往外取时，先用hashCode找到对应数组下标，然后用equals挨个比较直到链表的尾部，找到返回相应值，找不到返回null。再回过头看刚才的问题，先放进去一个new Person(10, &quot;小明&quot;)，然后取的时候又新建了一个new Person(10, &quot;小明&quot;)，由于没有重写hashCode，这两个对象的hashCode是不一样的，存和取的数组下标也就不一样，自然取不出来了。 两个对象equals返回false，hashCode返回值可以相等，但是如果不等的话，可以改进哈希数据结构的性能。这条原则也可以用HashMap的数据结构解释，举一个极端的例子，假如Person所有对象的hashCode都一样，那么HashMap内部数组的下标都一样，数据就会进到同一张链表里，这张链表比正常情况下要长的多，而遍历链表是一项耗时的工作，性能也就下来了。 那么如何写一个好的hashCode呢？ 声明一个变量int的变量result，将第一个和equals相关的实例变量的hashCode赋值给它。 然后按照下列规则依次计算剩下的实例变量的hashCode值c。 如果是null，设置一个常数，通常为0 如果是原始类型，使用Type.hashCode(f)，Type为它们的装箱类型 如果是数组，如果每一个元素都是相关的，可以使用Arrays.hashCode；否则将相关元素看作独立的变量计算 使用result = 31 * result + c的形式将每个变量的哈希值组合起来，最后返回result。 参考资料：《Effective Java》","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"}]},{"title":"侏罗纪下一部可以叫做We are family","slug":"侏罗纪下一部可以叫做We-are-family","date":"2018-06-25T10:14:51.000Z","updated":"2025-09-16T02:08:42.964Z","comments":true,"path":"2018/06/25/侏罗纪下一部可以叫做We-are-family/","link":"","permalink":"https://naosense.github.io/2018/06/25/%E4%BE%8F%E7%BD%97%E7%BA%AA%E4%B8%8B%E4%B8%80%E9%83%A8%E5%8F%AF%E4%BB%A5%E5%8F%AB%E5%81%9AWe-are-family/","excerpt":"","text":"侏罗纪为了续集越来越无耻了，下一部名字都给你们起好了，就叫We are family，影片一开始，人类和恐龙手牵手围成一圈载歌载舞，一片和谐的景象，或许还可以制定个《恐龙人权保护法》什么的。","categories":[],"tags":[{"name":"侏罗纪公园","slug":"侏罗纪公园","permalink":"https://naosense.github.io/tags/%E4%BE%8F%E7%BD%97%E7%BA%AA%E5%85%AC%E5%9B%AD/"}]},{"title":"Maven插件屏蔽第三方包日志的方法","slug":"Maven插件屏蔽第三方包日志的方法","date":"2018-06-01T15:23:04.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2018/06/01/Maven插件屏蔽第三方包日志的方法/","link":"","permalink":"https://naosense.github.io/2018/06/01/Maven%E6%8F%92%E4%BB%B6%E5%B1%8F%E8%94%BD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E6%97%A5%E5%BF%97%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"这几天写了一个Maven插件，里面用到了Zookeeper（下面简称ZK），里面打印出了很多“Client environment…”字样的info信息，看着挺闹心，就想着怎么屏蔽掉，让世界清净点。","text":"这几天写了一个Maven插件，里面用到了Zookeeper（下面简称ZK），里面打印出了很多“Client environment…”字样的info信息，看着挺闹心，就想着怎么屏蔽掉，让世界清净点。 刚开始认为ZK使用的log4j，那么在工程里建个resources/log4j.properties，使用log4j.logger.org.apache.zookeeper=WARN的形式来屏蔽掉，结果没起作用。后来又使用log4j.xml的形式，也是不行。再后来又用logback，还是不行，感觉把能想到的方法都试试了，统统不管用，真是郁闷。 将要放弃时，忽然想到既然是在Maven插件里，里面的log系统是不是另有一套呢，一看果然不是log4j，而是simplelogger，按着指导修改了[maven home]\\conf\\logging\\simplelogger.properties，现在有作用了。 因为插件jenkins部署的时候也要使用，如果要修改部署脚本或者挨个修改Maven的配置文件太麻烦，最好能在当前插件里设置，最后试了一下将simplelogger.properties里的配置写到Java系统变量里，果然可以，事情终于圆满解决了，解决方式为添加下面的代码： System.setProperty(&quot;org.slf4j.simpleLogger.log.org.apache.zookeeper&quot;, &quot;warn&quot;); 希望能给有类似需求的人一点参考，不得不感叹下Java的日志系统真是杂乱啊！","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"https://naosense.github.io/tags/maven/"},{"name":"日志","slug":"日志","permalink":"https://naosense.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"2018中期计划","slug":"2018中期计划","date":"2018-05-25T15:23:32.000Z","updated":"2025-09-16T02:08:42.938Z","comments":true,"path":"2018/05/25/2018中期计划/","link":"","permalink":"https://naosense.github.io/2018/05/25/2018%E4%B8%AD%E6%9C%9F%E8%AE%A1%E5%88%92/","excerpt":"虽说伟大的大先知鲁迅曾经说过，要立长志，不要常立志。但是为了将来打脸留个证据，还是要立个字据的。","text":"虽说伟大的大先知鲁迅曾经说过，要立长志，不要常立志。但是为了将来打脸留个证据，还是要立个字据的。 Coursera上Algorithms课程，现在已进行到上半部分第二周。 啃完计算机程序与构造，做一部分习题。 至少每隔一天跑一次步，身体革命本钱。 每周一篇博客，不限制长度。 计划看起来不多，难度较大的是2和3。计算机程序和构造啃了好几次了，都不了了之，和1相比，没有Coursera的时间限制和分数激励，导致自己没有动力，成就感不高，加上有些习题难度较大，比较打击信心，希望这次能把这个硬骨头啃掉。跑步这个事说起来不算难事，难得是坚持下来，特别是一个人。北京这地方，冬天冷，夏天热，遇到刮风下雨，很容易给自己找借口开脱，所以我把标准降低了，允许自己偷下懒。我把朋友圈关闭了，就把博客当成朋友圈吧，每周一篇博客应该没啥问题。 好了，别的不说了，立了计划就得执行，希望年末不打脸。","categories":[],"tags":[{"name":"2018","slug":"2018","permalink":"https://naosense.github.io/tags/2018/"},{"name":"计划","slug":"计划","permalink":"https://naosense.github.io/tags/%E8%AE%A1%E5%88%92/"}]},{"title":"一个初级阶段的五子棋ai","slug":"一个初级阶段的五子棋ai","date":"2017-12-11T16:46:03.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2017/12/11/一个初级阶段的五子棋ai/","link":"","permalink":"https://naosense.github.io/2017/12/11/%E4%B8%80%E4%B8%AA%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BA%94%E5%AD%90%E6%A3%8Bai/","excerpt":"一、前言 16年alpha狗接连击败李世石和柯洁后，自己就有个想法，能不能利用机器学习也鼓捣一个类似的五子棋ai？最初的想法是训练一个机器学习模型，喂给它一些棋局，让它自己能够学会落子规则，能够积累优势，最终取得胜利，而且随着下棋盘数的增加，自身的能力可以进一步的提高。但是传统的机器学习需要输入和响应，对于一局棋输入和响应又是什么呢，搜肠刮肚的把自己知道的的几种算法想了一遍，也在网上查了半天，或者模型太复杂，短时间没法掌握相关的知识，或者模型计算代价太高，动辄训练个几天，所谓远水解不了近渴，最好的能一个周末能整出一个初级的ai，能打败我就行，以后有时间功能可以慢慢加，这也是标题的由来。","text":"一、前言 16年alpha狗接连击败李世石和柯洁后，自己就有个想法，能不能利用机器学习也鼓捣一个类似的五子棋ai？最初的想法是训练一个机器学习模型，喂给它一些棋局，让它自己能够学会落子规则，能够积累优势，最终取得胜利，而且随着下棋盘数的增加，自身的能力可以进一步的提高。但是传统的机器学习需要输入和响应，对于一局棋输入和响应又是什么呢，搜肠刮肚的把自己知道的的几种算法想了一遍，也在网上查了半天，或者模型太复杂，短时间没法掌握相关的知识，或者模型计算代价太高，动辄训练个几天，所谓远水解不了近渴，最好的能一个周末能整出一个初级的ai，能打败我就行，以后有时间功能可以慢慢加，这也是标题的由来。 二、Minimax算法 对于这种回合制的游戏，传统的方法就是利用minimax算法，那么什么是minimax算法呢，说白了，就是和人在脑子里模拟往下走几步一样，minimax算法也是模拟往下走棋，轮到自己时选自己最有利的，即max，轮到对方时选自己最不利的，即min，直到某一条件终止，然后选择一条对自己最有利的路径。由此可以看到，如果计算资源足够，计算机是可以找到一条可以使己方胜利的路径，但是事实上这是不可能的，以15X15的五子棋为例，大约有225!种可能的走法，想穷举出这么多种可能性，以目前的计算能力是达不到的，所以一般的做法是往下模拟走一定的步数，然后选择一条最优的。 三、评估函数 由算法描述，必须有一种方法对当前的局势进行衡量，通常的方法就是使用评估函数。评估函数可以根据当前局势给出一个分数，使局势成为可量化的数值。具体到五子棋就是统计棋局中的活三、活四等模式并给予一定的分数然后将总的分数相加，具体请参考代码。 四、优化 1、Alpha-beta剪枝 单纯的minimax算法复杂度是非常高的，从算法的描述，算法的复杂度应该是$O(b^d)$,d是往后走的步数，b是每一步棋可选的位置。以五子棋为例，模拟走5步大约是$225^5=576650390625$，显然这个数目还是太大，所以需要引进alpha-beta剪枝。这种算法就是用一个变量alpha保存着max一方可以得到的最优值，beta保存着min一方只允许max一方获得的最优值，当beta小于等于alpha时其他的情况就不用再看了，因为最优值的上限就是beta。 2、减少可选的落子位置 下过五子棋的可能都知道，如果落子的位置离己方和对方的棋子太远是没有意义的，因此我把这个距离限制为2，这样把原来b从225减少到了20~30，这个优化是很可观的。 3、历史启发 alpha-beta剪枝的效率是和下一步棋的顺序密切相关，如果最合适的那一步棋总是先计算那么算法的效率可以达到$O(b^\\sqrt{d})$，这就相当于同样的时间原来只能往后推算5步，现在可以推算10步，而如果顺序不当，效率和没剪枝的minimax没什么两样。历史启发的原理就是记录那些发生剪枝次数最多的位置，以及得分的极值，赋予它们一定的值，以此来排序。 最终的核心代码如下， private int alphaBeta(Board board, int depth, int alpha, int beta, Player player) &#123; if (board.status().isGameOver() || depth &lt;= 0) &#123; return board.evaluate(this, this.depth - depth); &#125; Board.Pos bestPos = null; int v = (this == player) ? Integer.MIN_VALUE : Integer.MAX_VALUE; List&lt;Board.Pos&gt; childPos = sortChildPos(board); for (Board.Pos pos : childPos) &#123; Board bd = new Board(board); bd.mark(pos, player); int w = alphaBeta(bd, depth - 1, alpha, beta, bd.getEnemy(player)); if (this == player) &#123; if (v &lt; w) &#123; v = w; bestPos = pos; if (depth == this.depth) &#123; this.best = new Move(v, pos); &#125; &#125; alpha = Integer.max(alpha, w); &#125; else &#123; if (v &gt; w) &#123; v = w; bestPos = pos; &#125; beta = Integer.min(beta, w); &#125; if (beta &lt;= alpha) &#123; this.history[pos.getRow()][pos.getCol()] += 2 &lt;&lt; depth; break; &#125; &#125; if (bestPos != null) &#123; this.history[bestPos.getRow()][bestPos.getCol()] += 2 &lt;&lt; depth; &#125; return v; &#125; 五、战力如何 首先是人机对战，当推算的步数达到4步时，我是没赢过，但是这并不能说明它的战力有多强，只能说明我的水平很臭，但是我的初步目标达到了；其次我让两个同等级的电脑对战50局，战绩如下， 等级（步数） 先手赢 后手赢 平局 1 40 10 0 2 16 12 22 3 27 18 5 似乎印证了先手的胜率高一点。 六、下一步工作 可以看到ai的战力是和评估函数密切相关的，获取一个比较好的评估函数是一个优化的方向。 目前ai不能自我学习，如何让ai自我学习，并逐步变强是另一个方向，这也是重点方向。 如果想在我的代码上继续前进，请戳这里，下图是一局电脑对战的动图。 参考资料： Minimax Alpha-beta pruning Killer_heuristic","categories":[],"tags":[{"name":"五子棋","slug":"五子棋","permalink":"https://naosense.github.io/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/"},{"name":"minimax","slug":"minimax","permalink":"https://naosense.github.io/tags/minimax/"},{"name":"alpha beta","slug":"alpha-beta","permalink":"https://naosense.github.io/tags/alpha-beta/"}]},{"title":"浅谈Java泛型","slug":"浅谈Java泛型","date":"2017-11-28T11:03:16.000Z","updated":"2025-09-16T02:08:42.978Z","comments":true,"path":"2017/11/28/浅谈Java泛型/","link":"","permalink":"https://naosense.github.io/2017/11/28/%E6%B5%85%E8%B0%88Java%E6%B3%9B%E5%9E%8B/","excerpt":"相信每个Java程序员对泛型都不陌生，不少人也用过泛型，但是泛型中确实有些点容易让人迷惑，下面我结合自己的使用经历和理解谈谈对泛型的认识，不求面面俱到，但求切中要害。","text":"相信每个Java程序员对泛型都不陌生，不少人也用过泛型，但是泛型中确实有些点容易让人迷惑，下面我结合自己的使用经历和理解谈谈对泛型的认识，不求面面俱到，但求切中要害。 一、泛型是什么 引用Java文档的解释， A generic type is a generic class or interface that is parameterized over types. 大致的意思就是类型经过参数化的类或接口。 二、为什么要泛型 在泛型出现之前你要定义一个存储水果类的列表，你只能这样写， List fruits = new ArrayList(); Elephant e = new Elephant(); fruits.add(e); Fruit f = (Fruit) fruits.get(0); 虽然定义了一个名叫fruits的列表，但是你里面存大象也没人管你，只有在运行时你试图将列表的元素赋值给一个水果时才会报错。为了更早的发现这种错误，Java在5.0引入了泛型机制(Generics)。有了泛型上面的程序就可以这么写， List&lt;Fruit&gt; fruits = new ArrayList&lt;Fruit&gt;(); Elephant e = new Elephant(); fruits.add(e); // Compile error 这样当你往水果的列表里塞一个大象时编译器就会报错，而不用等到运行时，而且也避免了显式的转型。 三、泛型分类 从程序的层次上，泛型分为泛型类和泛型方法。比如Java中的ArrayList类就是一个泛型类， public class ArrayList&lt;E&gt; 而集合工具类Collections中的emptyList方法就是一个泛型方法， public static final &lt;T&gt; List&lt;T&gt; emptyList() &#123; return (List&lt;T&gt;) EMPTY_LIST; &#125; 到这里其实没什么要说的。 四、更进一步 1、通配符? 通配符代表的意思应该是“某个或某些具体但不确定的类型”，首先具体的是指将来要用某个具体的类来替换通配符，其次不确定是指当前还确定不了是哪种具体类型。 2、边界 边界也就是某种类型的子类型或父类型，即super定义的下界和extends定义的上界。 3、类型擦除 如果用一句话解释就是用不用泛型编译后的代码是一样的，更详细更准确的解释是由于泛型是在Java 5.0引入的，为了兼容老版本的Java，编译器会将泛型参数替换为它的边界（上界），如果有多个边界，只保留最左边的，如果没有边界替换为Object，最终保留下来的只有正常的类、接口和方法。 public class GeneralTest&lt;T extends Comparable&lt;T&gt; &amp; Iterable&lt;T&gt; &amp; Serializable&gt; &#123; void test1(T t) &#123; ... &#125; &lt;E&gt; void test2(E e) &#123; ... &#125; &#125; 编译后生成的代码为， void test1(T); descriptor: (Ljava/lang/Comparable;)V &lt;E&gt; void test2(E); descriptor: (Ljava/lang/Object;)V 可以看到T的边界有三个Comparable&lt;T&gt; &amp; Iterable&lt;T&gt; &amp; Serializable，编译后只保留了Comparable，而且Comparable的泛型&lt;T&gt;也去掉了；test2中的E没有边界，它直接被替换为了Object，而且test2作为泛型方法编译后也没有任何泛型的信息。 4、替换原则 一个类型的变量可以接受子类型的变量，一个据有某种参数的方法可以在参数的子类型上调用。这个原则几乎是面向对象编程的基础，它可以让我们这么写代码， Fruit a = new Apple(); List l = new ArrayList(); 可以把一个“苹果”赋值给“水果”，可以把ArrayList赋值给List。 5、PECS原则 也就是所谓的Producer Extends, Consumer Super原则，作为生产者时使用extends，作为消费者时使用super，这条原则其实是替换原则的推论。 List&lt;??&gt; list = Arrays.asList(1, 1.3, 5L); Number i = list.get(0); Map&lt;String, ??r&gt; map = new HashMap&lt;&gt;(); map.put(&quot;212&quot;, 1); 比如你想要从list中取出的数据可以赋值给一个Number，根据替换原则，“一个类型的变量可以接受子类型的变量”，你就得定义list中的类型都是Number的子类型。那么如何表示一个Number的子类型呢，因为extends在Java中本来就表示继承的意思，所以很自然的想法就是? extends Number，这恰恰就是正确答案。 再比如，你想在map值里存储各种数字，根据替换原则，“一个据有某种参数的方法可以在参数的子类型上调用”，也就是你想要put方法适用在各种数字类型上，“各种数字类型”是这里的“子类型”，所以你需要定义map的值是“各种数字类型”的父类型才可以，表示父类Java中同样有个关键字super，所以你可能猜想? super Number表示的就是这个意思，没错，答案就是这个。 你可以看到，在两种情况下，确定泛型是替换原则中的子类型还是父类型是关键中的关键。这恰恰就是PECS原则的内容，即作为生产者，将泛型传递给别的变量时，使用extends；作为消费者，将别的变量传递给泛型时，使用super。 6、是泛型方法还是通配符 在泛型中，经常面临的一个抉择就是是使用泛型方法还是使用通配符。比如下面的方法， interface Collection&lt;E&gt; &#123; public boolean containsAll(Collection&lt;?&gt; c); public boolean addAll(Collection&lt;? extends E&gt; c); &#125; 如果写成泛型方法， interface Collection&lt;E&gt; &#123; public &lt;T&gt; boolean containsAll(Collection&lt;T&gt; c); public &lt;T extends E&gt; boolean addAll(Collection&lt;T&gt; c); &#125; 可以看到类型参数T在方法中只使用了一次，和别的类型参数也没有关系，和函数返回值也没有关系，所以T在这里就显得有点多余。 再看另一个例子， class Collections &#123; public static &lt;T&gt; void copy(List&lt;T&gt; dest, List&lt;? extends T&gt; src) &#123; ... &#125; 这里的类型参数T就是必须的了，它表明了源列表和目标列表元素的依赖关系，如果没有一个具体的类型参数，这种依赖没法表述。但是如果你写成下面这个样子，就有点画蛇添足了。 class Collections &#123; public static &lt;T, S extends T&gt; void copy(List&lt;T&gt; dest, List&lt;S&gt; src) &#123; ... &#125; 可以说，原则就是尽可能的使用通配符，因为它更加精炼，当通配符达不到目的的时候再使用具体的类型参数。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://naosense.github.io/tags/java/"},{"name":"泛型","slug":"泛型","permalink":"https://naosense.github.io/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"疏而不漏：随机森林","slug":"疏而不漏：随机森林","date":"2017-11-18T09:31:53.000Z","updated":"2025-09-16T02:08:42.978Z","comments":true,"path":"2017/11/18/疏而不漏：随机森林/","link":"","permalink":"https://naosense.github.io/2017/11/18/%E7%96%8F%E8%80%8C%E4%B8%8D%E6%BC%8F%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/","excerpt":"一、概述 在三生万物：决策树中我们提到当决策树和装袋法(Bagging)和提升法(Boosting)结合后会成为更强大的算法，那么今天就介绍一种名叫随机森林(Random Forest)的算法，它是将决策树、装袋法以及随机特征选取结合后衍生出的一种增强型的树算法。","text":"一、概述 在三生万物：决策树中我们提到当决策树和装袋法(Bagging)和提升法(Boosting)结合后会成为更强大的算法，那么今天就介绍一种名叫随机森林(Random Forest)的算法，它是将决策树、装袋法以及随机特征选取结合后衍生出的一种增强型的树算法。 它有如下特点： 运行起来非常有效率，可以很容易的并行化 可以无删减的处理成千上万的输入变量，并可以评估变量的重要性 不用将数据专门分为训练集和测试集，随机森林构造完就可以得到近似的测试误差 能够很有效的处理缺失值 可以有效的分离出离群点 对过拟合有很强的抗性 还可以用于非监督式学习 …… 看到随机森林有这么多的优点，你是不是心动了呢？那么接下来和我一起来认识一下它吧！ 二、算法 1、基本步骤 上文提到随机森林不是一种全新的算法，而是几种算法的强强联合。随机森林的构建一般有这么几个步骤： 首先确定树的数量(Tree Size)，而每个树的训练数据通过有放回的抽取原始数据。由于是有放回的抽样，原始数据中约有1/3的量没有被抽到，这些数据称为袋外数据(OOB, Out Of Bag) 树的树训练数据有了，接下来就该训练了，与决策树不同，这里的树在构建的时候，每一次分裂都要进行随机特征选取，也就是在特征的随机子空间进行分裂，比如一个数据集有5个特征，每次分裂有放回的随机取3(Feature Count)个 到这里，所有的树都应该构造完成了，森林也就有了，那么怎么对响应值进行预测呢？这就要依靠集体的智慧了，每个树都有一个预测值，对于分类问题，取频率最高的那个值；对于回归问题，取所有值的平均 2、袋外误差(OOB Error) 算法作者说OOB Error可以作为测试误差的无偏估计，也就是计算出OOB Error就可以得到测试误差，不用专门把数据专门拿出来一部分作为测试集。下面举例说明如何计算OOB Error，比如我们要在一个有7条数据的数据集上构建一个5棵树的随机森林，那么在步骤1的时候会出现下面这样一张表: 数据编号 树1 树2 树3 树4 树5 1 X √ √ X √ 2 √ X X X X 3 √ √ √ √ √ 4 √ √ X √ √ 5 √ X √ √ X 6 √ √ X √ √ 7 X √ √ √ √ 表里的X代表没有选中，√代表选中。对于树1，数据1和7就是OOB，对于树2，数据2和5就是OOB，其他以此类推，那么数据1的预测值由树1和树4决定，数据2的预测值由树2-5来决定，以这样的方式计算出每个数据的预测值，进而得到误差值，即OOB Error。 3、变量重要性(Variable Importance) 假设我们已经计算出了OOB Error，一个变量的重要性可以这么计算，将变量打散，然后重新计算打散后的OOB Error，取打散前后OOB Error差值的绝对值，越大代表这个变量越重要。变量重要性在实践过程中非常好用，比如在一个10000维度的数据集选出100个最重要的变量，即数据的降维。 4、相似性(Proximities) 相似性由相似性矩阵体现，相似性矩阵是一个NxN的对称矩阵，它的计算方式如下，如果数据n和数据p同属于同一颗树的同一个叶子节点，那么相似性加1，即proximities[n,p]和proximities[p,n]均加1，最后除以树的数目进行标准化。 5、离群点(Outliers) 有了相似性，也就可以计算离群点了。它基于这样的假设，如果一条数据和其他数据都不相似或者相似性很低，那么这条数据很可能是个离群点。这和人很类似阿，如果一个人不合群，那么他肯定是比较孤立的。不过在我实际操作的过程中，即使计算出了潜在的离群点，如何确定它真的是不是不是那么容易。 具体的计算过程如下，定义类别为j的数据n的平均相似性为： $$\\bar{P}(n) = \\sum_{cl(k)=j}prox^2(n,k)$$ 得到非相似性： $$Dissimilarity(n) = nsample(j) / \\bar{P}(n)$$ 然后在各自的类别中标准化，得到最终的Dissimilarity，算法作者给出的经验值是如果一条数据的Dissimilarity&gt;10，那么可能是一个潜在的离群点。 6、缺失值 对于缺失值，传统的方法就是数值变量取均值，分组变量取最多的那一类。而随机森林处理缺失值另有一套：先使用一个不太准确的初始值替换缺失值，然后计算数据间的相似性，数值变量取同一类别非缺失值的相似性加权平均；分组变量取频率最高的值，频率要经过相似性加权，然后重复这一过程4-6次。 三、案例 在决策树代码的基础上稍加改动就得到了随机森林，下面检验一下新算法的能力。 1、在三生万物：决策树里我尝试使用花萼长度(Sepal.Length)和花萼宽度(Sepal.Width)这两个变量来预测鸢尾花的种类(Species)，这里用随机森林试一试。 首先来看下不同数目的树对分类的影响，下图的分类边界(Decision Boundary)，使用的Node Size为1，特征数Feature Count也为1, 可以看到，与决策树相比，随机森林对过拟合(Overfit)有着很强的抗性，且随着树的数目增多过拟合越来越少。但是，另一方面也要看到尽管对过拟合很强的抗性，还是可以看到过拟合的影子，即便我们已经用了1000棵树。所以，还是要为随机森林选择一个合适的Node Size, 从上面的第一张图，可以看到Node Size从0～100增加时，OOB Error先降后增，且在Node Size为15时达到最低。从第二张图可以看到随机森林分类边界的变化过程，先是轻微的过拟合继而最合适的边界最后严重的欠拟合。第三张图是最合适的分类边界，尽管和决策树一样，预测的错误率都为0.2左右，但是和决策树的分类边界相比，随机森林的边界更平滑。 2、北京二手房 为了和决策树作对比，我也用随机森林来预测下房价(price)，也是使用区域(area)、是否学区(school)、是否有地铁(subway)、总价(num)这四个变量，使用的参数为树的数目TS=100，特征数Feature Count=4，节点数目Node Size=5，得到的结果如下， $r2 [1] 0.7014904 $importance area 0.48257784 num 0.37338239 school 0.08469551 subway 0.04547572 袋外决策系数R2为0.7，使用模型预测所有房屋价格的决策系数为0.74，比决策树的0.7高了4个百分点，大家不要小看了这4个百分点，在机器学习中哪怕1个百分点都要付出很大的努力。况且，我在这里并没有使用交叉验证获取最佳的参数，只是凭经验选取。另外模型还给出了预测房价各个变量的重要性，可以看到决定房价最重要的就是房子所在的区。 接下来是个分类问题，使用小区(region)、户型(zone)、面积(meters)、朝向(direction)、区域(con)、楼层(floor)、房龄(year)、学区(school)、地铁(subway)、税(tax)、总价(num)、单价(price)来预测区(area)。随机从29790中抽取了10000条数据构造100颗树的随机森林，构建一个100棵树的森林，OOB Error和变量重要性如下， $oob_error [1] 0.1241 $importance con 0.5454 price 0.3717 school 0.1132 year 0.0556 subway 0.0490 region 0.0168 direction 0.0163 meters 0.0043 num 0.0040 zone 0.0026 floor 0.0007 tax 0.0007 OOB Error约为0.12，使用得到的随机森林模型预测29790条房源的区域，误差约为0.08，两者还是比较接近的。不出所料，片区(con)的重要性最高，另外房价(price)、是否学区(school)对房子区域的重要性也决非浪得虚名。 上文提到，随机森林可以作为降维的工具，我从中选择前6个重要的变量重新构建一个随机森林，OOB Error和变量重要性如下， $oob_error [1] 0.11 $importance con 0.5638 price 0.3812 school 0.1140 year 0.0831 subway 0.0490 region 0.0254 可以看到，使用6个变量的OOB Error与使用全部12个变量的OOB Error不相上下。 下面看看有没有潜在的离群点，下图是每套房子的Dissimilarity， 有两套房子的Dissimilarity&gt;10，看看是什么房子， region zone meters direction con floor year school subway tax num price area 福成公寓A 3室1厅 135 南北 燕郊城区二手房 低楼层 2004 无学区 无地铁 非免税 405 30000 燕郊 达观别墅 4室2厅 270 南北 燕郊城区二手房 低楼层 2009 无学区 无地铁 非免税 1600 59260 燕郊 初步看来，这两套房子的总价(num)和价格(price)有点高，是不是这一点让它们鹤立鸡群呢？ 四、总结 本文简单介绍了随机森林的特点及算法，并简单分析了iris和北京二手房两个数据集。本文只是抛砖引玉，其实随机森林的还有一些其他的特性，大家可以多多去发掘。 参考资料： Random Forests Leo Breiman and Adele Cutler Random forest","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://naosense.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"随机森林","slug":"随机森林","permalink":"https://naosense.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"}]},{"title":"三生万物：决策树","slug":"三生万物：决策树","date":"2017-11-11T16:53:19.000Z","updated":"2025-09-16T02:08:42.961Z","comments":true,"path":"2017/11/11/三生万物：决策树/","link":"","permalink":"https://naosense.github.io/2017/11/11/%E4%B8%89%E7%94%9F%E4%B8%87%E7%89%A9%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"一、概述 不知怎么回事，提到决策树我就想起”道生一，一生二，二生三，三生万物“这句话，大概是因为决策树从一个根节点慢慢“长”成一棵树，也要经历“一生二，二生三”的过程。决策树本质上就是一种二叉树，根据特定的标准不停的分成左右两个子树，直到符合某种条件停止。树算法解释性强、简单直观以及接近人的决策方式使它成为流行的机器学习算法之一。当决策树与装袋法(Bag)、提升法(Boosting)结合之后，可以成为更强大的算法。","text":"一、概述 不知怎么回事，提到决策树我就想起”道生一，一生二，二生三，三生万物“这句话，大概是因为决策树从一个根节点慢慢“长”成一棵树，也要经历“一生二，二生三”的过程。决策树本质上就是一种二叉树，根据特定的标准不停的分成左右两个子树，直到符合某种条件停止。树算法解释性强、简单直观以及接近人的决策方式使它成为流行的机器学习算法之一。当决策树与装袋法(Bag)、提升法(Boosting)结合之后，可以成为更强大的算法。 决策树按响应值的类型大致分为分类树和回归树，实现决策树的方法也很多，比如CART、ID3、C4.5等等，本文将对CART这种算法进行介绍。 二、算法 一棵树要长成要解决两方面的问题，一是如何分，二是何时停。这两点对于分类和回归略有区别，先说如何分，对于定量变量一般是将小于某个值的数据划分为左子树，大于等于某个值的划分为右子树；对于定性变量一般是将等于某个值的划分为左子树，不等于某个值的划分为右子树。那么什么才是一个好的划分呢？分类树大致分为两种，一种是按纯度(Purity)，纯度是通过**基尼系数(Gini Index)**进行定义的，基尼系数越小，纯度越大，那么划分效果越好。基尼系数的计算方法如下式所示： $$G = \\sum_{k=1}^K\\hat{p}_k(1 - \\hat{p}_k)$$ $\\hat{p}_k$代表第$k$类所占比例，当$\\hat{p}_k$接近0或1时，基尼系数会很小。 另一种标准是互熵(Cross-entropy)，互熵的定义如下： $$D = -\\sum_{k=1}^K\\hat{p}_k\\log\\hat{p}_k$$ 由定义可以看到，和基尼系数类似，当$\\hat{p}_k$接近0或1时，互熵也很小，划分的效果也越好。 回归树则根据方差： $$Variance = \\frac{1}{N}\\sum_{i=1}^N(y_i - \\bar{y})^2$$ $\\bar{y}$代表平均响应值，我们都知道方差是衡量数据变异性的量，因此越小表示回归模型效果越好。 注意上面的纯度、互熵以及方差均是树的一个分枝上的值，总的值要对左右分枝进行加权平均，例如基尼系数的最终值应该这样计算， $$G_{total} = \\frac{N_{left}}{N} G_{left} + \\frac{N_{right}}{N} G_{right}$$ $N$表示总的样本数，$N_{left}$，$N_{right}$分别代表左分枝和右分枝的样本数，互熵和方差的计算方式类似。 说了如何分，那什么时候停呢？一般的惯例是子树中的预测变量或响应值都一样了就可以停止分裂了。有时候这个条件可能有些苛刻，这时候可以设置一个Node Size值，表示叶子节点包含的最小的样本数。分裂过程中如果一个子树的样本数小于等于这个值就停止分裂，分类数取数目最多的那个类，回归树取响应的均值。 说了这么多，下面举个例子，来演示下决策树算法，比如这里有一份城市和农村儿童身高数据，注意这里的数据都是我杜撰的，只是为了演示决策树的算法。如果已知一个儿童身高和性别，如何判断所处的区域？ 身高 性别 地区 100 男 城市 90 女 城市 90 男 农村 80 女 农村 下面尝试根据基尼系数来构造一个分类树， 第一次分裂： 身高&lt;100：3/4 x (1/3 x 2/3 + 2/3 x 1/3) + 1/4 x (1 x 0) = 1/3 身高&lt;90：1/4 x (1 x 0) + 3/4 x (2/3 x 1/3 + 1/3 x 2/3) = 1/3 身高&lt;80：0/4 x 0 + 4/4 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 性别=男：2/4 x (1/2 x 1/2 + 1/2 x 1/2) + 2/4 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 性别=女：2/4 x (1/2 x 1/2 + 1/2 x 1/2) + 2/4 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 可以看到前面两个都是1/3，选择哪一个都行，这里我选择第一个最小值：“身高&lt;100”，数据被分为： 左子树 身高 性别 地区 90 女 城市 90 男 农村 80 女 农村 右子树 身高 性别 地区 100 男 城市 第二次分裂： 由于右面的子树只有一条数据，因此只需计算左边子树的基尼系数， 身高&lt;90：1/3 x (1 x 0) + 2/3 x (1/2 x 1/2 + 1/2 x 1/2) = 1/3 身高&lt;80：0/3 x 0 + 3/3 x (1/3 x 2/3 + 2/3 x 1/3) = 4/9 性别=女：2/3 x (1/2 x 1/2 + 1/2 x 1/2) + 1/3 x (1 x 0) = 1/3 性别=男：1/3 x (1 x 0) + 2/3 x (1/2 x 1/2 + 1/2 x 1/2) = 1/3 同上选择第一个最低值“身高&lt;90”，数据分成了两部分： 左子树 身高 性别 地区 80 女 农村 右子树 身高 性别 地区 90 女 城市 90 男 农村 第三次分裂： 同理，左边子树只有一条数据，只需计算右子树 身高&lt;90：0/2 x 0 + 2/2 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 性别=女：1/2 x (1 x 0) + 1/2 x (1 x 0) = 0 性别=男：1/2 x (1 x 0) + 1/2 x (1 x 0) = 0 选择“性别=女”这个条件，至此所有的子树的响应值都是唯一的，停止分裂。 最终这个分类树的样子大概如下， 三、树的剪枝 其实树的剪枝就是正则化，剪枝一般分为两种：一种称为预剪枝，通过设置Node Size的大小来达到控制树的分枝个数的目的，这种方式简单易用，但有短视的风险；另一种称为后剪枝，原理是让树充分“生长”，然后尝试合并树的分枝，通过对比合并前后错误率是否降低来决定是否真得合并，这种方式效果较前一种好，但是实现稍微复杂一些。 四、说了就练 俗话说，光说不练假把式，下面我用R语言实现一个决策树，并尝试分析两个实际的数据集。 1、鸢尾花(iris)数据集，这个数据集包括五个变量：花萼长度(Sepal.Length)，花萼宽度(Sepal.Width)，花瓣长度(Petal.Length)，花瓣宽度(Petal.Width)，种类(Species)，下面尝试使用花萼长度(Sepal.Length)和花萼宽度(Sepal.Width)这两个变量来预测鸢尾花的种类(Species)。 为了简便，我采用的是预剪枝的方式。那么选择多大的Node Size合适呢？关于这个问题通常的方法就是**交叉验证(Cross-validation)**。下图是采用10折交叉验证(k-fold cross-validation)得到的错误率, 可以看到，当Node Size为40的时候测试集的错误率Eout最低，从另一个方面也可以看到如果不进行剪枝，Eout约为0.4，比剪枝后的错误率高了将近0.2。从下面的第一张图也可以直观的看到当Node Size从小到大增加时，分类边界(Decision Boundary)从过拟合(Overfit)到欠拟合(Underfit)的变化趋势。第二张图是根据交叉验证得到的最佳分类边界，它和Node Size为30的分类边界非常相似。 最终的错误率约为0.2，从上面第二张图可以看到versicolor和virginica这两类的鸢尾花有些数据在二维空间完全重合在了一起，仅仅依靠花萼长度(Sepal.Length)，花萼宽度(Sepal.Width)这两个变量是无法把它们分开的，这个时候单纯的增加样本数无法进一步提高模型的质量，这个时候最好去寻找新的变量，事实上，当加上花瓣长度(Petal.Length)，花瓣宽度(Petal.Width)这两个变量时，预测的错误率可以降低到0.06左右。 树的样子如下， 2、上面是个分类问题，那么再看一个回归问题。北京二手房这个数据集有13个特征，下面使用决策树根据房子的区域(area)、是否学区(school)、是否有地铁(subway)、总价(num)这四个变量来预测房价(price)。 同样，祭出我们的法宝交叉验证得到一个合适的Node Size，如下所示， 对于回归,我采用了**决策系数R2**作为衡量模型效果的标准，由于R2是越大越好，且0&lt;R2&lt;1，所以这里用1-R2作为模型的误差。和分类树类似，当Node Size从小到大的过程中，模型呈现出了从过拟合到欠拟合的变化过程，显然，当Node Size约为100的时候模型效果是最好的。下图是Node Size为100时从29790条数据中随机选取了10000条进行训练得到的模型，用这个模型预测所有29790条房屋的房价，相对误差((预测房价-实际房价)/实际房价)如下所示， 得到的决策系数R2约为0.7，也就是区域、是否学区、是否有地铁、总价这四个变量解释了70%房价变异。由这个相对误差图可以看出大部分的数据都落在了0附近，实际上有20275条数据落在[-0.2,0.2]，28379条数据落在[-0.5,0.5]。那么，那些误差比较大的都是些什么数据呢？ 下面的数据为相对误差大于3的 area region zone meters direction con floor year school subway tax num price 海淀 东小营甲1号 5室2厅 350 南 西北旺二手房 低楼层 1998 无学区 无地铁 非免税 280 8000 朝阳 北苑家园望春园 1室0厅 36 南北 北苑二手房 地下室 2008 无学区 无地铁 非免税 20 5556 昌平 香堂文化新村二期 5室4厅 460 南北 昌平其它二手房 低楼层 2010 无学区 无地铁 非免税 220 4783 昌平 东亚上北中心 1室0厅 738 北 回龙观二手房 地下室 2007 无学区 无地铁 非免税 370 5012 感觉这些数据好像异常数据，北京还有低于1万的房价？！ 五、总结 当一个小小的种子慢慢成长为一颗参天大树，独霸森林一方，常常让人感受生命的强大，而决策树算法同样让人惊叹，易于实现又足够灵活，既能用于分类又能用于回归，也在机器学习领域赢得了一席之地。本文简单介绍了决策树的算法和剪枝，在此基础上用R实现了一个决策树，并在两个数据集上进行了测验，证实了决策树的能力。","categories":[],"tags":[{"name":"决策树","slug":"决策树","permalink":"https://naosense.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"机器学习","slug":"机器学习","permalink":"https://naosense.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"HTTPS为什么是安全的","slug":"HTTPS为什么是安全的","date":"2016-08-23T17:08:28.000Z","updated":"2025-09-16T02:08:42.958Z","comments":true,"path":"2016/08/23/HTTPS为什么是安全的/","link":"","permalink":"https://naosense.github.io/2016/08/23/HTTPS%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84/","excerpt":"HTTP我们都知道是超文本传输协议，HTTPS与HTTP一字之差，它到底是什么呢？引用《HTTP权威指南》的介绍： HTTPS是最常见的HTTP安全版本。它得到了很广泛的应用，所有主要的商业浏览器和服务器上都提供HTTPS。HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起，使得HTTPS不仅很安全，而且很灵活，很容易在处于无序状态的、分散的全球互联网上进行管理。 HTTPS是最常见的HTTP安全版本。多出的S是Security安全的意思，那么它是如何保证安全的呢？","text":"HTTP我们都知道是超文本传输协议，HTTPS与HTTP一字之差，它到底是什么呢？引用《HTTP权威指南》的介绍： HTTPS是最常见的HTTP安全版本。它得到了很广泛的应用，所有主要的商业浏览器和服务器上都提供HTTPS。HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起，使得HTTPS不仅很安全，而且很灵活，很容易在处于无序状态的、分散的全球互联网上进行管理。 HTTPS是最常见的HTTP安全版本。多出的S是Security安全的意思，那么它是如何保证安全的呢？ 我们先看看HTTP和HTTPS通信协议层。 可以看到，相比HTTP，HTTPS多了一个安全层协议SSL/TLS（安全套接层Secure Sockets Layer和传输层安全协议Transport Layer Security，后者是SSL的后继版本），保证安全的秘密就是这个安全层协议。简单说来，HTTPS就是在安全的传输层上传输报文的HTTP。 让我们具体看看，SSL包括两部分：记录协议（record protocol）和握手协议（handshake protocol），前者主要定义了数据格式，后者定义了安全传输客户端/服务器需要交换的具体信息，这是我们要介绍的重点。 握手协议包括下面十个步骤： 客户端向服务器发送SSL协议版本、自己支持的加密方式、随机产生的一段数据。 服务器向客户端发送SSL协议版本、根据双方支持的加密方式确定一个最安全的加密方式、随机产生的一段数据以及自己的数字证书。 客户端验证服务器的合法性，如果合法进行下一步，否则会话终止，包括如下过程： 数字证书是否过期 数字证书是否可信，即证书的颁发机构是否在客户端往往是浏览器的信任列表 数字证书的公钥能否验证数字签名，即数字签名的合法性，这个过程参见*数字签名是什么* 域名是否与证书的域名匹配 如果第3步中服务器合法，客户端使用使用到目前产生的所有数据为本会话生成一个预置密码（ premaster secret），然后使用服务器的公钥加密预置密码，将密文发送给服务器。 如果服务器要求对客户端进行验证（可选），客户端会将签名数据和证书连同预置密码密文一并发给服务器。 服务器对客户端进行验证，过程与第3步类似。验证不通过会话终止，验证通过，服务器使用私钥解密预置密码，然后执行一系列步骤（客户端会同时执行同样的步骤）生成主密钥（master secret）。 客户端和服务器使用主密钥生成会话密钥（session key），这就是加密后面所有数据的对称密钥。 客户端发送一条消息通知服务器以后的数据都将使用会话密钥加密，然后再发送一条消息表明握手过程的客户端部分完成。 服务器也发送一条消息通知客户端以后的数据都将使用会话密钥加密，然后再发送一条消息表明握手过程的服务器部分完成。 握手过程完成，SSL会话开始使用会话密钥传输数据。 可以看到整个握手过程既包括非对称加密又包括对称加密，先用非对称密钥传送对称密钥，再用对称密钥传送后面的数据，充分利用了两种加密方式的优势，参见*加密和解密*。 回到开头的问题，HTTPS如何保证安全呢？兵法云：知己知彼百战百胜，我们知道互联网安全三大威胁：窃听、篡改和伪装，假如让我们作为攻击者，该如何去做呢？ 事实上，上面十个步骤中第1、2步是明文传输的，我们可以对这两步的信息进行拦截得到双方的协议版本、加密方式、随机数以及服务器证书，然后原封不动的将相应信息再发送给对方，我们在通信中间扮演一个伪装者，对客户端来说我们就是服务器，对服务器来说我们就是客户端。现在来到第3步，客户端对我们的攻击全然不知，还把我们当成真正的服务器，客户端验证我们发送给它的数字证书，结果肯定是通过的，因为我们是将服务器的数字证书原封不动的发过去的。接着客户端将预置密码加密然后发送给服务器，这个信息肯定也没法逃脱我们的火眼金睛，但是我们拿过拦截到的信息一看有点傻眼了，由于我们没有服务器密钥，无法进行解密，也就无法得到预置密码，接下来的步骤就无法进行，客户端这时候就反应过来了，等了这么久没反应，对方肯定就问题，会话终止。至于其他的步骤，都是加密数据，窃听篡改没什么意义，这样，三大威胁就被解决了。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://naosense.github.io/tags/http/"},{"name":"https","slug":"https","permalink":"https://naosense.github.io/tags/https/"}]},{"title":"加密和解密","slug":"加密和解密","date":"2016-08-22T16:40:34.000Z","updated":"2025-09-16T02:08:42.968Z","comments":true,"path":"2016/08/22/加密和解密/","link":"","permalink":"https://naosense.github.io/2016/08/22/%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/","excerpt":"最近学习HTTPS的知识，涉及了一些加密和解密的内容，在Mozilla MDN上找到一篇文章*Encryption and Decryption*，清晰明了，特地翻译一下，与大家分享。 **加密（Encryption ）**是将原始信息转化为对其他用户非明了信息的过程，除非信息的接受者；解密（Decryption）是将非明了信息转化为原始数据的过程。加密算法，也称作密码（cipher， 注：与传统意义上的密码不同），是一种用来加密和解密的数学函数。在大多数情况下，会同时采用两个相关的函数，一个用作加密，另一个用作解密。 当今的大多数加密技术保持信息私密并不依靠算法本身，因为算法都是众所周知的，而是依靠加密和解密的密钥（key）。使用正确的密钥进行解密轻而易举，而使用不正确的密钥想进行解密是非常困难的，在某些实际情况下，可以说是不可能的。 本篇文章将从下面三个方面介绍密钥在加密和解密中的用处： 对称密钥加密（Symmetric-Key Encryption） 公钥加密（Public-Key Encryption，也称作非对称密钥加密） 密钥长度和加密强度","text":"最近学习HTTPS的知识，涉及了一些加密和解密的内容，在Mozilla MDN上找到一篇文章*Encryption and Decryption*，清晰明了，特地翻译一下，与大家分享。 **加密（Encryption ）**是将原始信息转化为对其他用户非明了信息的过程，除非信息的接受者；解密（Decryption）是将非明了信息转化为原始数据的过程。加密算法，也称作密码（cipher， 注：与传统意义上的密码不同），是一种用来加密和解密的数学函数。在大多数情况下，会同时采用两个相关的函数，一个用作加密，另一个用作解密。 当今的大多数加密技术保持信息私密并不依靠算法本身，因为算法都是众所周知的，而是依靠加密和解密的密钥（key）。使用正确的密钥进行解密轻而易举，而使用不正确的密钥想进行解密是非常困难的，在某些实际情况下，可以说是不可能的。 本篇文章将从下面三个方面介绍密钥在加密和解密中的用处： 对称密钥加密（Symmetric-Key Encryption） 公钥加密（Public-Key Encryption，也称作非对称密钥加密） 密钥长度和加密强度 对称密钥加密 在对称密钥加密中，加密密钥可以由解密密钥推知，反之亦然。事实上，在很多情况下，二者是相同的，如下图所示。 对称密钥加密效率非常高，以至于用户几乎察觉不到加密和解密的延迟。对称密钥加密还提供了一定程度的认证机制，因为信息一旦经密钥加密，不可能被其他密钥解密。因此，只要密钥没有泄露且信息可以正确的解密，通信双方都能确定是在与对方通信。 只有在通信双方保持密钥不被泄露的情况下，对称密钥加密才是有效的。如果其他人发现了密钥，将会影响双方的私密性和身份认证。一个未经授权的用户不仅可以使用密钥解密消息，还可以加密和发送一条新消息给通信中的一方，就好像它是拥有此密钥的另一方一样。 对称密钥加密在SSL协议中扮演着重要的角色，它广泛地应用在身份认证、篡改监测以及 TCP/IP网络加密中。另外，SSL也使用了公钥加密，下一节将介绍这种技术。 公钥加密 公钥加密最常用的实现是基于RSA Data Security的专利算法，因此，本节将以RSA这种方式介绍公钥加密。 公钥加密包括一对密钥：一个公钥和一个私钥——还有对其进行电子认证、签名和数据加密的实体。公钥是公开的，而对应的私钥是保密的。公钥加密的数据只能被对应的私钥解密。下图简单展示了公钥加密的工作方式。 上图这种方案可以让你自由发布一个公钥，只有你才能使用公钥读取加密的数据。一般情况下，为了给某些人发送加密数据，你首先使用那人的公钥进行加密，那人收到加密数据后使用对应的私钥进行解密。 对比对称密钥加密，公钥加密需要更大的计算量，因此当数据量比较大时，这种加密方式就不太合适了。然而，可以使用它发送一个对称密钥，然后再用这个对称密钥加密另外的数据（注：这里有两个过程，第一步公钥加密，第二步对称密钥加密）。SSL正是使用的这种方式。 就像上图显示的那样，上面的方案反过来同样适用（注：我觉得原文说反了，图中展示的就是这种方案）：使用私钥加密，然后使用对应的公钥解密。对于敏感数据，这不是一个理想的方式，因为根据定义，拥有公钥的任何人都可进行解密。尽管如此，使用私钥进行加密这种方式还是非常有用的，因为这意味着你能够使用你的私钥进行电子签名，这在电子商务及其他商业应用程序加密中非常重要。客户端程序比如Firefox能够使用你的公钥来确认这份使用你的私钥加密的消息是否被篡改。*数字证书是什么*这篇文章介绍了这个确认过程。 密钥长度和加密强度 破解一个加密算法就是要找到将加密数据变为原始数据的密钥。对于对称密钥加密来说就是要找到进行数据加密的密钥，对于公钥加密来说，就是获得通信双方的私钥。 破解对称密钥加密的一个方式是挨个测试算法中的每个密钥直到找到正确的密钥。对于公钥加密，密钥对中的一个（公钥）是公开的，另一个（私钥）经过已经公布的复杂数学计算得到。挨个测试密钥的方法被称作暴力破解法。 加密算法被破解将会带来私密信息被拦截、被冒充甚至被欺诈的风险。 加密算法的密钥强度是由破解此算法的最快方法与暴力破解法的速度对比值确定（注：意思是最快的破解方法和暴力破解速度差不多那么密钥强度高，如果最快的破解方法比暴力破解快得多那么密钥强度低）。 对于对称密钥，加密的强度是由加密密钥的长度或者大小确定的：一般情况下，密钥越长，强度越高。密钥长度是使用位（bit）进行衡量的。例如，SSL协议的RC4对称密钥加密算法，128位的密钥要比40位的密钥安全的多。大致来说，128位的RC4加密强度是40位的RC4加密强度的3 x 1026倍（关于SSL中RC4加密的更多信息，详见*Introduction to SSL*）。如果加密密钥已知最快的破解方法和暴力破解差不多，那么就可以说这个密钥是强力的（full strength）。 不同的加密算法可能需要不同的密钥长度来达到同样的加密强度。例如，公钥加密中的RSA算法，因为它所基于数学原理，密钥只能是给定长度所有值的一个子集。其他加密算法，比如对称密钥加密的用到的算法，密钥可以是给定长度所有值，而不只是一个子集。 因为RSA密钥破解起来相对容易，RSA加密算法的密钥长度要比较长，为了达到较高的加密强度，至少要达到1024位。相比之下，对于对称密钥加密的大部分算法，达到同样的加密强度，密钥长度只需要80位。","categories":[],"tags":[{"name":"加密","slug":"加密","permalink":"https://naosense.github.io/tags/%E5%8A%A0%E5%AF%86/"},{"name":"解密","slug":"解密","permalink":"https://naosense.github.io/tags/%E8%A7%A3%E5%AF%86/"}]},{"title":"数字签名是什么","slug":"数字签名是什么","date":"2016-08-20T11:49:30.000Z","updated":"2025-09-16T02:08:42.975Z","comments":true,"path":"2016/08/20/数字签名是什么/","link":"","permalink":"https://naosense.github.io/2016/08/20/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"随着现在网银、电子商务的普及，“数字签名”屡屡被提到，我也曾一度迷惑，直到看到Mozilla MDN上的一篇文章*Digital Signatures*，下面我将翻译一下这篇文章。 加密和解密解决了三大互联网安全隐患（窃听、篡改、伪装）之窃听的问题，但是却没法避免信息被篡改。 本篇文章将向你介绍公共秘钥加密如何解决这个问题。 信息篡改及相关的认证技术依赖于一个数学函数单向哈希函数（one-way hash，也称作信息摘要）。单项散列函数可以根据原始数据生成一个定长的数据摘要，并且具有如下特性： 原始数据不同，摘要不同（注：严格说来这句话不对，当数据大到一定程度，会发生碰撞的可能，但是概率实在太小了，可以忽略不计）。只要修改或者删除原始数据中哪怕一个字符，摘要都会发生显著的改变。 原始数据不可能由摘要推出，这也是单向哈希的名字由来。 同样地，在公共密钥加密中为了进行数字签名，要产生一对秘钥（key），一个称为私有签名秘钥（private signing key ），一个称为公开验证秘钥（public verification key）。后者是公开的，前者是保密的，只有所有者知道。二者在数学上有一定的联系，想从公开验证秘钥推出私有签名秘钥几乎是不可能的或者要付出高昂的代价（注：比如时间、金钱）。摘要及其他相关信息，连同哈希算法，一并被称为数字签名。 下图简单展示了数字签名如何验证数据的合法性。 上图显示发送者将两份数据发送给接受者：一份原始数据，一份加密过的摘要数据，即用私钥和相关的单向哈希算法加密过的数据摘要（注：这里有两个过程，第一步求数据摘要：原始数据-&gt;摘要，第二步加密：摘要-&gt;加密过的摘要）。为了验证数据的合法性，接受者首先使用签名者的公钥对加密摘要进行解密得到摘要，然后对原始数据应用同样的单向哈希算法得到一份新的摘要（单项哈希算法会和数据一并发送给接受者，图中未标出），最后，接受者对比这两份摘要。如果二者一致，那么说明数据没有篡改，否则数据可能被篡改或者发送过来的公钥和签名者的私钥不匹配。 如果两份摘要一致，接受者就能确定解密签名的公钥和生成签名的私钥是匹配的，然后进一步确认签名者的身份，尽管要确认签名者的身份还需要其他一些步骤来确定这个公钥确实属于某个人或实体，详见*Introduction to Public-Key Cryptography*. 数字签名的意义堪比手写签名。如果秘钥没有失去所有者的控制，一旦签名，过后很难进行否认。数字签名的这个特性提供了高度的不可否认性，签名者签名后就无法抵赖。以致在一些情形中，数字签名具有手写签名的同等法律效力。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://naosense.github.io/tags/http/"},{"name":"https","slug":"https","permalink":"https://naosense.github.io/tags/https/"},{"name":"加密","slug":"加密","permalink":"https://naosense.github.io/tags/%E5%8A%A0%E5%AF%86/"},{"name":"解密","slug":"解密","permalink":"https://naosense.github.io/tags/%E8%A7%A3%E5%AF%86/"},{"name":"数字签名","slug":"数字签名","permalink":"https://naosense.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"}]},{"title":"他们征友（婚）时，他们征什么？","slug":"他们征友（婚）时，他们征什么？","date":"2016-08-17T22:06:53.000Z","updated":"2025-09-16T02:08:42.963Z","comments":true,"path":"2016/08/17/他们征友（婚）时，他们征什么？/","link":"","permalink":"https://naosense.github.io/2016/08/17/%E4%BB%96%E4%BB%AC%E5%BE%81%E5%8F%8B%EF%BC%88%E5%A9%9A%EF%BC%89%E6%97%B6%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%BE%81%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"有道是年年岁岁花相似，岁岁年年征友人，征友贴一茬又一茬，简历投了一波又一波，为什么迟迟得不到回复？当男女征友时，他们到底在征什么？你真的看懂征友贴了吗？你还在为你屡屡投条未收到答复而苦恼吗？你还在为简历被女神刷掉自怨自艾吗？","text":"有道是年年岁岁花相似，岁岁年年征友人，征友贴一茬又一茬，简历投了一波又一波，为什么迟迟得不到回复？当男女征友时，他们到底在征什么？你真的看懂征友贴了吗？你还在为你屡屡投条未收到答复而苦恼吗？你还在为简历被女神刷掉自怨自艾吗？ 本文以北邮人论坛征友贴为主要原料，使用独家秘制八卦手法，希望从中发现一些有意思的事，本着娱乐至上，看热闹不嫌事大的原则，有些观点和分析请观者自行甄别，图例中F(emale)代表女生，M(ale)代表男生。 一、总体情况 首先是大家喜闻乐见的我邮男女比例，如下图所示， 我从论坛总共扒拉下来274个帖子，其中女征男148个，男征女126个，男女比例大概是1:1.17，好像并没有想象的那么悬殊。从年龄上看征友的主力军还是80后，如下所示， 80后约占66%，几乎是90后的两倍，且男女比例基本持平，是啊90后都26了，80后压力好大啊，想静静。值得一提的是90后征友者，女生明显比男生多。从平均年龄上来看，男生为27.9，女生为27.7，女生稍小。整个年龄区间主要集中在26 ~ 30， 女生中26、27岁的占了四分之一。 下面再来看看大家的发帖时间吧， 可以看到，帖子的发布时间集中在晚上23点左右，这可能是和论坛的十大机制有关系，大家选在这个点发帖，目标是为了十大。有几个帖子是在凌晨发的，但都是男征女，看来女神们都很注重养生啊，不熬夜。一周七天，周一、周二和周末两天帖子数稍多，中间三天稍微少点，总体差别不如上面时间那么明显。 二、征友关键词 接下来，重点来了，回到开头我们提出的问题，当男女征友时他们在征什么？ 1、征友者说 我选取了男女征友者都提到的高频词，列举如下， 除了“工作”、“生活”、“喜欢”、“性格”、“身高”这些千篇一律的词，还有一些有趣的词。不知道大家注意到那个扎眼的“山东”没，因为身为山东人，对“山东”这个字眼比较敏感，这么多词只有一个关于地域的词汇就是“山东”，我很纳闷为什么“山东”出现在这里，山东人那么多没对象吗，我统计了下，平均约12%的帖子提到了山东。我不知道是山东人征友的比较多还是山东人比较受征友者的欢迎，不管怎样我就当成后者吧，哈哈。大家经常议论的“京户”也出现了，约有14%的帖子，不算很多。另外“感情经历”都是双方比较重视的一点，其他的大家自己看看吧。 2、男生vs女生 都说”男人来自火星，女人来自金星“，看过了男女生共同的话题，接下来看看两个来自不同星球的生物有哪些差别呢。 男生说的可以总结为：好“哥们”生于“86年”、“88年”，“收入”不错，有“户口”，有“能力”，“技术”过硬，爱好“羽毛球”、“游泳”、“健身”等，身体“健康”，寻“通情达理”，身高“160”以上妹子，插一句男生那么多都喜欢“羽毛球”吗，感觉没那么多啊。 女生可以总结为：单位“姐姐”、多年“闺蜜”生于“87年”、“90年”、“91年”，“活泼”可爱，性格“独立”，“喜欢运动”，会“做饭”，喜欢“孩子”，寻觅人“在北京”，“有责任”、“有上进心”，成熟“稳重”，“170”、“175”以上汉子，“非诚勿扰”，“哈哈哈”。 是的，我们又看到了万恶的“175”，可以看到男生更多的提到表示自己客观实力的字眼，女生则比较喜欢用一些主观一些的词汇。男生对女生最多的要求是“通情达理”，女生对男生最多的要求是“有责任”。 3、80后vs90后 是的我又带节奏了，都说“80后是XXX的一代，90后是XXX的一代”，那么这两代人在择偶观上有没有差别呢？ 80后男生可以总结为“寒窗苦读十余载，一朝成名在今朝，高头马，黄金屋，良人你咋还不来”，90后男生则是“世界那么大，未来那么远，唯一不变的就是寻觅你的心，亲爱的，你在哪里”。 80后女生“爱过，痛过，笑过，哭过，姐累了，想结婚了”，90后女生“爱哭爱笑，爱美食爱运动，一直在路上，我要我自己的未来”。 很明显，80后和90后说的话还是挺不一样的，80后可能更“现实”了。不过我不认为这是出生年代造成的，我更愿意把这看成年龄大小的差别，或者更残酷点，成熟与否的区别，就像现在的自己和20岁那年的自己相比，确实有那么一点不同。 至此，相信你已经大概了解男女征友需求了，下次投简历更有针对些吧。不过这可能并没有什么卵用，毕竟一个看脸的社会-_-。 最后祝征友者都能找到理想的另一半，应征者都能面试成功，该玩的年纪勇敢去玩，该爱的年纪勇敢去爱！","categories":[],"tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://naosense.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"r","slug":"r","permalink":"https://naosense.github.io/tags/r/"}]},{"title":"简洁高效的Boyer-Moore算法","slug":"简洁高效的Boyer-Moore算法","date":"2016-07-31T21:40:41.000Z","updated":"2025-09-16T02:08:43.018Z","comments":true,"path":"2016/07/31/简洁高效的Boyer-Moore算法/","link":"","permalink":"https://naosense.github.io/2016/07/31/%E7%AE%80%E6%B4%81%E9%AB%98%E6%95%88%E7%9A%84Boyer-Moore%E7%AE%97%E6%B3%95/","excerpt":"子串检索有着很广泛的应用，例如在文档软件中查找关键词，网站过滤敏感词，生物学家查找某种模式的基因组序列等等，很多人听说过著名的KMP算法，Boyer-Moore算法做到的更多，有迹象表明在某些情况下效率是前者的3-5倍，且实现起来更加简单，符合我简单高效的原则。","text":"子串检索有着很广泛的应用，例如在文档软件中查找关键词，网站过滤敏感词，生物学家查找某种模式的基因组序列等等，很多人听说过著名的KMP算法，Boyer-Moore算法做到的更多，有迹象表明在某些情况下效率是前者的3-5倍，且实现起来更加简单，符合我简单高效的原则。 下面先抛开算法不谈，如果让你在ABCSAKDFFEHHJDDEFKLD中查找DDEFK，你会怎么做？ ABCSAKDFFEHHJDDEFKLD DDEFK 最直接的就是暴力检索法，挨个比较文本和模式的每个字符，成功就继续比较模式字符的下一个，否则将模式往右移动一位，继续上述过程，直到文本的结尾或者搜索成功，通常情况下效率还可以，因为对于大部分文档往往只需要比较模式中的一两个字符，就会有非匹配字符，因此模式可以快速的向右移动，整体运行时间接近线性。java示例代码为 int M = pat.length(); int N = txt.length(); for(int i = 0; i &lt;= N - M; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (txt.charAt(i + j) != pat.charAt(j)) &#123; break; &#125; if (j == M - 1) &#123; return i; &#125; &#125; &#125; return -1; 而本文的主角BM算法可谓别出心裁，它从后往前匹配模式的每一个字符，看看BM算法是如何处理上面的例子的，我们用i表示文本的起始位置，j表示模式中待匹配字符的位置。 第一步，i=0，j=4，A与K匹配失败，没有必要再往前匹配，i往后移动4+1=5个字符，因为小于这个数字，A都会与模式中的某个字符重叠，而模式中没有这个字符，无论如何都会失败。 i=0 ABCSAKDFFEFKJDDEFKLD DDEFK j=4 第二步，i=5，j=4，E与K匹配失败，i需要再次往后移动，这次需要移动几个字符呢，答案是2，这样会将模式中最右边的E与文本中E对齐，小于这个数，文本中E会与模式E右边的字符重叠，这些字符中没有E，因此不可能成功。 i=5 ABCSAKDFFEFKJDDEFKLD DDEFK j=4 第三步，i=7，j=4，这次匹配成功了，j减一j=3，又成功了，j再减一j=2，又成功了，j再减一j=1，这次F与D没有匹配成功，这次i要移动多少呢，F在文本和模式中都出现了，但是模式中的F已经匹配过了，我们不想让i回退，只能让i简单的加1。 i=7 ABCSAKDFFEFKJDDEFKLD DDEFK j=4 j=3 j=2 j=1 第四步，i=8，j=4，同样J和K匹配失败，且J不在模式字符串中，同第一步，我们将i移动4+1=5个字符。 i=8 ABCSAKDFFEFKJDDEFKLD DDEFK j=4 第五步，i=13，k=4，当j=4…0时，每个字符都匹配成功，成功检索到模式，将i=13返回，或者将i的值存储起来继续往后搜索，如果想得到模式的所有位置。 i=13 ABCSAKDFFEFKJDDEFKLD DDEFK j=4 j=3 j=2 j=1 j=0 这样i移动5次，总共比较了12个字符，就完成了查找。 总结一下，BM算法的策略是从后往前匹配模式中的每个字符，直到文本中出现一个不匹配的字符txt.charAt(i+j)或者检索成功返回i。与暴力检索不同的是，当匹配失败时，BM算法不会按部就班的移动i，它首先会构造一个right数组，数组中存储的是字符集中每个字符在模式中最右边的位置，如果字符不在模式中设为-1，比如上面的例子， right['D']=1 right['E']=2 right['F']=3 right['K']=4 下面是可能出现的三种情形， 当非匹配字符txt.charAt(i+j)不在模式中时，就像上面第一步那样，i需要右移j+1个字符，否则非匹配字符就会与模式字符串的某个字符重叠。 当非匹配字符txt.charAt(i+j)是模式中一员时，如上第二步那样，i需要右移j-right[txt.charAt(i+j)]，小于这个步数也会发生重叠。 第三种情形其实是第二种情形的补充，虽然非匹配字符txt.charAt(i+j)在模式中，但是已经比较过，这样j-right[txt.charAt(i+j)] &lt; 1，这种情形下只让i简单的右移1位。 这是一段示例代码， public List&lt;Integer&gt; search(String txt) &#123; int N = txt.length(); int M = pat.length(); List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0, skip = 0; i &lt;= N - M; i += skip) &#123; for (int j = M - 1; j &gt;= 0; j--) &#123; if (pat.charAt(j) != txt.charAt(i + j)) &#123; skip = j - right[txt.charAt(i + j)]; if (skip &lt; 1) &#123;skip = 1;&#125; break; &#125; if (j == 0) &#123; pos.add(i); skip = M; break; &#125; &#125; &#125; return pos; &#125; 上面的代码会找出文本中模式出现的所有位置，在大部分情况下，上面这段代码的运行效率为$O(N/M)$，但是，当文本中包括大量的重复字符时，搜索的效率为$O(NM)$，请看下面的例子， txt length: 20 pat length: 5 -------------------- BBBBBBBBBBBBBBBBBBBB ABBBB #0 0 ABBBB #1 5 ABBBB #2 10 ABBBB #3 15 ABBBB #4 20 ABBBB #5 25 ABBBB #6 30 ABBBB #7 35 ABBBB #8 40 ABBBB #9 45 ABBBB #10 50 ABBBB #11 55 ABBBB #12 60 ABBBB #13 65 ABBBB #14 70 ABBBB #15 75 每一步后面有两个数字，第一个数字表示i移动的次数，后一个表示比较的字符数，如上所示，这个例子i移动了15次，总共比较了75个字符，接近于20*5，效率为$O(NM)$。这不是我们想看到的，为了应对这种情形需要引进另一个数组delta，delta数组中存储的是文本中每个字符最后出现的地方，默认值为模式的长度，这样当遇到非匹配字符txt.charAt(j)时至少delta[pat.charAt(j)]-j这一段是不可能匹配的，因为在文本中这一段没有出现pat.charAt(j)，比较的时候就有了两个移动距离，取其大者。下面是新的代码， public List&lt;Integer&gt; search(String txt) &#123; int N = txt.length(); int M = pat.length(); List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0, skip = 0; i &lt;= N - M; i += skip) &#123; for (int j = M - 1; j &gt;= 0; j--) &#123; char c1 = txt.charAt(i + j); char c2 = pat.charAt(j); delta[c1] = j; if (c1 != c2) &#123; int skip1 = j - right[c1]; int skip2 = delta[c2] - j; skip = Math.max(skip1, skip2); if (skip &lt; 1) &#123;skip = 1;&#125; break; &#125; if (j == 0) &#123; pos.add(i); skip = M; resetDelta(); break; &#125; &#125; &#125; return pos; &#125; 每次匹配成功，需要重置delta数组，即上面resetDelta()。将这段代码与上面那一版进行对比，看看有哪些区别。完整代码在这里，用这一段代码再运行上面的例子， txt length: 20 pat length: 5 -------------------- BBBBBBBBBBBBBBBBBBBB ABBBB #0 0 ABBBB #1 5 ABBBB #2 10 ABBBB #3 15 这次好多了，i移动了3次，只比较了15个字符，就完成了整个检索，算法复杂度基本为线性。好了，算法分析与证明不是那么有意思，最后就以我做的两个实验来结束吧。 横轴为文本长度，纵轴表示比较的字符数，文本和模式从26个大写字母随机生成。可以看到，对于长度为10的模式，BM算法复杂度大约为$O(N/M)$，暴力检索为$O(N)$。 与上图不同，这幅图的文本和模式是从4个大写字母随机选择，因此重复率要高的多。可以看到，对于重复率很高的字符串，BM算法效率也能达到$O(N)$，而暴力检索接近$O(NM)$。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://naosense.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"boyer moore","slug":"boyer-moore","permalink":"https://naosense.github.io/tags/boyer-moore/"}]},{"title":"Javascript中的this","slug":"Javascript中的this","date":"2016-03-27T23:07:42.000Z","updated":"2025-09-16T02:08:42.959Z","comments":true,"path":"2016/03/27/Javascript中的this/","link":"","permalink":"https://naosense.github.io/2016/03/27/Javascript%E4%B8%AD%E7%9A%84this/","excerpt":"对于js的函数有两个特殊的关键字，this和arguments，后者存储的是函数的参数，类似于一个数组。例如如下的函数， var testArgus = function() &#123;console.log(arguments);&#125; // [1, 2] testArgus(1,2)","text":"对于js的函数有两个特殊的关键字，this和arguments，后者存储的是函数的参数，类似于一个数组。例如如下的函数， var testArgus = function() &#123;console.log(arguments);&#125; // [1, 2] testArgus(1,2) arguments的含义比较明确，而this就不那么直白了，this指代的是函数运行时所处的上下文。这句话有两点需要注意：一是this是在运行时决定的，也就是函数在调用之前this的值是不确定的，二是函数所处的上下文，也就是函数运行时所处的环境。 首先看看什么是上下文，对比下面的代码，注意它们的差别。 var o = &#123;testThis: function() &#123;return this;&#125;&#125;; var b = &#123;testThis: function() &#123;return this;&#125;()&#125;; o.testThis(); b.testThis; 它们的分别会输出什么？事实上，前者会输出Object，也就是o本身；后者会输出window，也就是全局对象。如果感到疑惑，再看《JavaScript高级程序设计》中的一个例子， window.color = &quot;red&quot;; var o = &#123;color: &quot;blue&quot;&#125;; function sayColor() &#123; alert(this.color); &#125; // &quot;red&quot; sayColor(); o.sayColor = sayColor; // &quot;blue&quot; o.sayColor(); 需要明确的是，函数的名字仅仅是一个包含指针的变量而已。即使是在不同的环境中执行，全局的sayColor()和o.sayColor()指向的仍然是同一个函数。前者在全局作用域调用，因此this指向的是window，因此输出&quot;red&quot;，当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此会输出&quot;blue&quot;。再回头看上面的代码，匿名函数在b中执行，并没有附加到任何对象，实际上相当于在window中执行，因此返回this，指向的是window。 事实上this有那么一条规律，如果调用函数时是以构造函数的形式，即new函数的形式，this会指向创建的新变量，如果是以普通函数的形式调用，this指向的是全局变量。还是老样子，用代码说话。 var Flower = function(name) &#123;this.name = name;&#125; // error alert(name); var f1 = Flower(&quot;f1&quot;); // &quot;f1&quot; alert(name); var f2 = new Flower(&quot;f2&quot;); // &quot;f1&quot; alert(name); // &quot;f2&quot; alert(f2.name); 根据这条规律，也可以解释为什么b.testThis为什么指向window，匿名函数在b中执行，是以普通函数的形式被调用，因此this指向的是全局变量，即window。 既然说到了this，就不得不提call和apply，js中这两个函数用来改变函数所处的上下文，也就是this的指向。例如上面的代码， window.color = &quot;red&quot;; var o = &#123;color: &quot;blue&quot;&#125;; function sayColor() &#123; alert(this.color); &#125; // &quot;blue&quot; sayColor.call(o); call和apply用法一样，只是接受的参数不一样，二者第一个参数都代表新的上下文，call接受逗号分隔的各个参数，apply接受数组形式的参数。要注意到，sayColor并不是o的一个方法，但是通过call我们却可以像使用自身的方法一样来调用一个函数，这提供了极大的灵活性，在各大js库中十分常见。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://naosense.github.io/tags/javascript/"}]},{"title":"Oracle中的高水位线","slug":"Oracle中的高水位线","date":"2016-03-25T09:37:21.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2016/03/25/Oracle中的高水位线/","link":"","permalink":"https://naosense.github.io/2016/03/25/Oracle%E4%B8%AD%E7%9A%84%E9%AB%98%E6%B0%B4%E4%BD%8D%E7%BA%BF/","excerpt":"","text":"高水位线(High Water Mark, HWM)类似于一个指针，用来标识分配给段(segment)的块(block)状态。块是Oracle中数据分配和操作的最小单位，段是类似于表、索引这样的数据库实体。块有下面几种状态： 在HWM之上，块是未格式化和未使用的(unformated and unused) 在HWM之下，块又有下面几种状态： 分配的(allocated)，但是还未格式化 格式化并且存有数据 格式化但是没有数据，delete操作会造成这种状态 另有一个低水位线的概念(Low HWM)，处于Low HWM之下的块都是格式化的，处于Low HWM和HWM之间有可能格式化也可能未格式化。 示意图如下， -- ============================================================= -- &lt;-formated--&gt;Low HWM&lt;----allocated-----&gt;hwm&lt;-----empty----&gt;total -- ================^========================^===================^ HWM有如下特点： 一般情况下只升不降，只有在truncate、move、shrink等操作才会降低，delete不会降低，delete后留下的空间，以后insert可以使用。 执行全表扫描时，数据库扫描Low HWM以下所有的块，不管有没有数据，读取两个水位线之间的块时则要小心一点，因为这中间的块并不一定都是格式化的。如果频繁的删除插入操作，会在HWM下的块中留下大量碎片，影响性能。 当insert和update的时候，数据库在Low HWM和HWM之间或者Low HWM之下的空余空间进行写入。 可是为什么要设置一个HWM呢？既然有了一个位图块记录块的状态，为什么要设置一个水位线，全表扫描时还要扫描下面的所有块，而不是那些有数据的？这不是出力不讨好吗，百度了半天，没找到满意的答案，基本上大家都是说“它是这样的”，而没有说“它为什么是这样的”，知道的告诉一声。 下面是检测表水位线的一个小程序： PROCEDURE P_TABLE_HWM_ANALYSE(TABLE_NAME IN VARCHAR2) IS -- 表占用空间高水位检测 LVC_TABLE_TMP VARCHAR2(50); LVC_MB NUMBER; -- 表的大小MB LVC_TOTAL NUMBER; -- 总的block数 LVC_BLOCKS NUMBER; -- 水位线，即hwm LVC_EMPTY_BLOCKS NUMBER; -- 空余block LVC_USED NUMBER; -- 使用的block LVC_USED_PERCENT NUMBER; -- 使用百分比，LVC_USED/LVC_TOTAL LVC_HWM_PERCENT NUMBER; -- 水位线百分比，LVC_BLOCKS/LVC_TOTAL LVC_USED_PERCENT_POS NUMBER; LVC_HWM_PERCENT_POS NUMBER; BEGIN LVC_TABLE_TMP := UPPER(TABLE_NAME); EXECUTE IMMEDIATE 'ANALYZE TABLE ' || LVC_TABLE_TMP || ' ESTIMATE STATISTICS'; SELECT ROUND(SUM(DECODE(BYTES, NULL, 0, BYTES)) / 1024 / 1024, 1), SUM(DECODE(BLOCKS, NULL, 0, BLOCKS)) INTO LVC_MB, LVC_TOTAL FROM USER_SEGMENTS WHERE SEGMENT_NAME = LVC_TABLE_TMP GROUP BY SEGMENT_NAME; SELECT DECODE(BLOCKS, NULL, 0, BLOCKS), DECODE(EMPTY_BLOCKS, NULL, 0, EMPTY_BLOCKS) INTO LVC_BLOCKS, LVC_EMPTY_BLOCKS FROM USER_TABLES WHERE TABLE_NAME = LVC_TABLE_TMP; EXECUTE IMMEDIATE 'SELECT COUNT(DISTINCT DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID) || DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID)) FROM ' || LVC_TABLE_TMP INTO LVC_USED; IF LVC_TOTAL = 0 THEN LVC_USED_PERCENT := 0; LVC_HWM_PERCENT := 0; ELSE LVC_USED_PERCENT := ROUND(LVC_USED / LVC_TOTAL * 100); LVC_HWM_PERCENT := ROUND(LVC_BLOCKS / LVC_TOTAL * 100); END IF; IF LVC_USED_PERCENT &lt; 6 THEN LVC_USED_PERCENT_POS := 3; ELSE LVC_USED_PERCENT_POS := ROUND(LVC_USED_PERCENT / 2); END IF; IF LVC_HWM_PERCENT &lt; 6 THEN LVC_HWM_PERCENT_POS := 3; ELSE LVC_HWM_PERCENT_POS := ROUND(LVC_HWM_PERCENT / 2); END IF; DBMS_OUTPUT.PUT_LINE(RPAD(LVC_TABLE_TMP || ': ' || LVC_MB || 'MB', 50) || LPAD('U: Used, H: HWM, T: Total', 52)); DBMS_OUTPUT.PUT_LINE(LPAD('=', 102, '=')); DBMS_OUTPUT.PUT_LINE(LPAD(LVC_USED_PERCENT || '%', LVC_USED_PERCENT_POS)); DBMS_OUTPUT.PUT_LINE('|' || LPAD('|U', LVC_USED_PERCENT + 2, '-')); DBMS_OUTPUT.PUT_LINE(LPAD(LVC_HWM_PERCENT || '%', LVC_HWM_PERCENT_POS)); DBMS_OUTPUT.PUT_LINE('|' || LPAD('|H', LVC_HWM_PERCENT + 2, '-')); DBMS_OUTPUT.PUT_LINE(''); DBMS_OUTPUT.PUT_LINE(LPAD('T', 103, '=')); EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(LVC_TABLE_TMP || ', ' || SQLERRM); END P_TABLE_HWM_ANALYSE; 测试一下， DM2_LDCX_SY: 10MB U: Used, H: HWM, T: Total ====================================================================================================== 88% |----------------------------------------------------------------------------------------|U 98% |--------------------------------------------------------------------------------------------------|H ======================================================================================================T","categories":[],"tags":[{"name":"高水位线","slug":"高水位线","permalink":"https://naosense.github.io/tags/%E9%AB%98%E6%B0%B4%E4%BD%8D%E7%BA%BF/"},{"name":"oracle","slug":"oracle","permalink":"https://naosense.github.io/tags/oracle/"},{"name":"数据库","slug":"数据库","permalink":"https://naosense.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Javascript中的原型","slug":"Javascript中的原型","date":"2016-03-20T13:28:20.000Z","updated":"2025-09-16T02:08:42.959Z","comments":true,"path":"2016/03/20/Javascript中的原型/","link":"","permalink":"https://naosense.github.io/2016/03/20/Javascript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/","excerpt":"首先要明确的是， js中的原型是一个对象，而且这个对象是函数(对象)的一个属性，即prototype。 当以构造函数的形式调用函数时，即new一个函数，会创建一个实例对象，这个实例的__proto__属性会指向构造函数的prototype，由于原型也是对象，所以它也有一个__proto__属性，这个属性指向的是原型对象的构造函数的prototype，这样一步一步上溯到Object.prototype,Object.prototype对象的__proto__指向的是null，这就形成了一个锁链一样的东西，称为原型链。如果把原型链看做一条河流那么null就是源头了。注意原型prototype是函数的属性而不是实例的。 当一个函数被创建时，Function构造器产生的函数对象会执行类似的代码：this.prototype = &#123;constructor: this&#125;","text":"首先要明确的是， js中的原型是一个对象，而且这个对象是函数(对象)的一个属性，即prototype。 当以构造函数的形式调用函数时，即new一个函数，会创建一个实例对象，这个实例的__proto__属性会指向构造函数的prototype，由于原型也是对象，所以它也有一个__proto__属性，这个属性指向的是原型对象的构造函数的prototype，这样一步一步上溯到Object.prototype,Object.prototype对象的__proto__指向的是null，这就形成了一个锁链一样的东西，称为原型链。如果把原型链看做一条河流那么null就是源头了。注意原型prototype是函数的属性而不是实例的。 当一个函数被创建时，Function构造器产生的函数对象会执行类似的代码：this.prototype = &#123;constructor: this&#125; 下面我们用代码来阐述一下上面的结论，假设有这样一段代码： var Flower = function(name) &#123;this.name = name;&#125; var f = new Flower(&quot;flower&quot;); 那么这段代码的原型链是什么样子的呢？ 原型链为图中红色虚线，我们用代码验证下我们的猜想， // true f.__proto__ === Flower.prototype; // true; Flower.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null; 如果把原型链看做一条河流，那么null那一端就是上游，另一端为下游。我们都知道河流是有方向的，水只能由上游流向下游，而不能相反。 那么这个原型链有什么作用呢？它是js继承系统的基础。上面提到，原型也是一个对象，既然是对象就可以拥有属性和方法，但是这个对象有点特殊，如果你往这个对象里添加了属性和方法，处于下游的对象包括原型都会拥有这个属性和方法，甚至会影响到已有的对象。这有点像你往河里面导入一瓶墨水，那么下游很快就会被染上颜色。 还是老样子，用代码验证下， Object.prototype.nishishui = &quot;wo&quot; // &quot;wo&quot; Flower.prototype.nishishui // &quot;wo&quot; Flower.nishishui // &quot;wo&quot; f.nishishui // &quot;[object Object]&quot; f.toString() 我们从来没有在Flower和f上定义nishishui这个属性，但是它们都可以访问到。这是怎么回事呢，实际上当f调用nishishui这个属性时，首先检查自身，当然没有，然后通过__proto__去Flower.prototype中去找发现也没有，最后，以同样的方法找到Object.prototype，发现这小子原来在这里，当然不能放过了。js正是通过这种方式实现自己的继承，例如上面的toString()方法。不过如果原型链过长，会有潜在的性能问题，这个以后再说吧。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://naosense.github.io/tags/javascript/"}]},{"title":"统计中的p值","slug":"统计中的p值","date":"2016-03-20T11:36:27.000Z","updated":"2025-09-16T02:08:43.025Z","comments":true,"path":"2016/03/20/统计中的p值/","link":"","permalink":"https://naosense.github.io/2016/03/20/%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%9A%84p%E5%80%BC/","excerpt":"在我看来，假设检验从本质上是一种反证法。当你想证明一样事物是对的，有时候不太好证明，因为一件你以为对的东西可能只是因为你还没发现它错的一面，相反你想证明一件事物是错的就容易多了。在假设检验中，证明备择假设H1存在困难，我们就去证明它的反面原假设H0。","text":"在我看来，假设检验从本质上是一种反证法。当你想证明一样事物是对的，有时候不太好证明，因为一件你以为对的东西可能只是因为你还没发现它错的一面，相反你想证明一件事物是错的就容易多了。在假设检验中，证明备择假设H1存在困难，我们就去证明它的反面原假设H0。 p值一直是一个令人迷惑的地方，p值实际上是当H0假设为真，一些极端情况出现的概率。即 $$ p值 = {极端情况概率|H0} $$ 那么极端情况是什么呢？在H0的前提下，假设样本均值符合正态分布，我们都知道偏离均值3个均方差的概率几乎为0，但是这种情况还是出现了，我们就有理由判断前提条件错了，即H0是错的，由此我们拒绝H0。 上面提到在正态分布的情况下，偏离均值3个均方差的概率几乎为0，但毕竟不是0，事实上约为0.27%。虽然概率很小，但是还是有一定的可能性会拒绝本是正确的H0，这个犯错概率称为第一类错误，也称为显著性水平$\\alpha$。 那么，这个显著性水平$\\alpha$和p值有什么关系呢？在我看来就是拒绝一个真H0所允许的最大错误概率，也就是这种极端情况出现的最高概率，当p小于等于$\\alpha$时我们拒绝H0，否则不能拒绝H0。 在假设检验中，通常的流程为： 提出原假设和备择假设。 指定显著性水平$\\alpha$，通常取0.01或0.05。 搜集样本数据计算检验统计量的值。 利用检验统计量的值计算p值。 如果p值&lt;=$\\alpha$，则拒绝H0，否则不能拒绝H0。","categories":[],"tags":[{"name":"统计","slug":"统计","permalink":"https://naosense.github.io/tags/%E7%BB%9F%E8%AE%A1/"}]},{"title":"VIM中的正则表达式","slug":"VIM中的正则表达式","date":"2015-11-01T21:00:10.000Z","updated":"2025-09-16T02:08:42.960Z","comments":true,"path":"2015/11/01/VIM中的正则表达式/","link":"","permalink":"https://naosense.github.io/2015/11/01/VIM%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"VIM作为一款编辑软件有着强大的操作指令，灵活的配置方法，通过适当的组合能够实现令人眼花缭乱的功能，而正则表达式作为一门处理文本和数据的重要工具，和VIM异曲同工，通过元字符的简单组合就可以匹配千变万化的文本和数据，它是如此的强大以至于有些任务如果没有正则表达式几乎没有其他好的方法实现。下面看看这两个强大的武器是如何结合在一起的。","text":"VIM作为一款编辑软件有着强大的操作指令，灵活的配置方法，通过适当的组合能够实现令人眼花缭乱的功能，而正则表达式作为一门处理文本和数据的重要工具，和VIM异曲同工，通过元字符的简单组合就可以匹配千变万化的文本和数据，它是如此的强大以至于有些任务如果没有正则表达式几乎没有其他好的方法实现。下面看看这两个强大的武器是如何结合在一起的。 本文翻译自http://www.vimregex.com/，算是一篇比较全面的VIM正则表达式介绍。 2.介绍 2.1什么是VIM？ VIM（VI Improve）是VI编辑器的改进版，它在UNIX中无处不在。VIM由Bram Moolenaar发明，是一款免费的编辑器，当然如果你愿意，可以捐助一部分钱。 VIM有自己的网站为www.vim.org和邮件列表，上面的资料涵盖VIM的方方面面。目前，VIM能够运行在各大操作系统上，甚至是一些linux发型版本（redhat）的默认编辑器。 VIM拥有现代编辑的许多特点：语法高亮、可以定制化的用户界面、可以方便的与多种IDE集成在一起，从而具有一些更加吸引人的特色，比如故障恢复、自动命令补全、会话管理等。 VIM拥有庞大的用户群，仅linux用户就超过1000万，这个数字还在进一步增加。 2.2关于本教程 之所以写这个教程，只是因为我爱正则表达式，没有什么能比写出一个精心设计满足需要的正则表达式更让人兴奋的了，我希望这能作为一个引言。 不过说真的，正则表达式作为一个处理文本和数据的工具不是独立存在，而是嵌入在其他的程序语言或工具中，比如UNIX中的著名的grep程序，它根据一定的模式查找文件中的内容。你可以把正则表达式看做一种模式匹配语言，用它来处理一些棘手的文本问题会有意想不到的效果。 2.3致谢 感谢Benji Fisher, Zdenek Sekera, Preben “Peppe” Guldberg, Steve Kirkendall, Shaul Karl（排名不分先后）以及所有给我建议的人。 如果你有好的建议或者想法，随时发信给我（olontir at yahoo dot com）。 3.替换命令 3.1查找/替换 :range s[ubstitute]/pattern/string/cgiI c 每次替换都要确认 g 替换一行当中所有的匹配项（没有g只替换第一个匹配值，pingao注：注意与%区别） i 忽略大小写 I 不忽略大小写 []中表示可选项 3.2范围操作、行地址及标记 在讲匹配模式之前，先来了解下行地址。一些命令可以接受行范围，这样命令就会限定在这个范围内执行。行范围通常由逗号（，）或者分号（；）分隔的标示符组成，你也可以使用命令mI在当前位置作一个标记，以方便后面使用，&quot;I&quot;可以是任何字母。 标示符 说明 数字 行号 . 当前行 $ 文件的最后一行 % 整个文件，与1,$相同 't 标记t /pattern[/] pattern的下一个匹配行 ?pattern[?] pattern的上一个匹配行 / 最近一个搜索pattern的下一个匹配行 ? 最近一个搜索pattern的上一个匹配行 &amp; 最近一个替换pattern的下一个匹配行 如果没有指定行，操作只针对当前行。 这里有一些例子， 10, 20 -10到20行 /Section 1/+,/Section 2/- -所有Section 1和Section 2之间的行，不包括它们所在行，+标示加一，-标示减一，可以重复多个 :/Section/+ y -复制Section的下一个匹配行 :// normal p -粘贴到Section下一个匹配行的下一行 Tip1:如果你在pattern里使用/，一定要使用\\进行转义，比如， s/\\/dir1\\/dir2\\/dir3\\/file/dir4\\/dir5\\/file2/g 为了避免这种令人迷惑的转义灾难，VIM中可以自定义分隔符，我喜欢用冒号（:） Tip2：将下面两个快捷键映射放在你的vimrc文件中， noremap ;; :%s:::g&lt;Left&gt;&lt;Left&gt;&lt;Left&gt; noremap ;' :%s:::cg&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;&lt;Left&gt; 有了这两个快捷键，你会省去不少敲击键盘的时间，它会直接定位到搜索模式那里，输入搜索部分后再输入替换部分然后按回车键。第二个快捷键增加了确认标志。 4.模式说明 4.1锚 假设你想把所有的vi替换为VIM，很容易会想到下面的命令， s/vi/VIM/g 但是如果你真的这么做了，你会发现，它会把所有vi替换为VIM，甚至vi只是某个单词的一部分，这可能不是你想要的。 你可能还会想到，在vi两边添加空格来达到想要的效果， s: vi : VIM :g 你会发现结果并没有变化，正确的方法是使用单词边界标志\\&lt;\\&gt;， s:\\&lt;vi\\&gt;:VIM:g 行开始和结束有自己的标识符^和$，替换所有在行开始出现的vi， s:^vi\\&gt;:VIM: 如果一行之中只有vi则进行替换， s:^vi$:VIM: 现在假设你不仅要替换vi还要替换Vi、VI，有几种方法可以实现， 最简单的方法是使用i标志， %s:vi:VIM:gi 定义字符类（character class），:%s:[Vv]i:VIM:将会替换所有的Vi和vi 4.2转义字符或元字符 到目前为止，所有的匹配模式（pattern）都是由一些正常字符组成的，而正则表达式的真正强大之处就在于元字符（metacharacter），元字符是是指一些具有特殊含义的字符，从外观上它们的前面常有一个反斜杠，如下表所示， # 匹配 # 匹配 . 除换行符之外的任意字符 \\s 空白字符 \\S 非空白字符 \\d 数字 \\D 非数字 \\x 十六进制 \\X 非十六进制 \\o 八进制 \\O 非八进制 \\h 单词头（a-zA-Z_） \\H 非单词头 \\p 可打印字符 \\P 非打印字符 \\w 单词字母 \\W 非单词字母 \\a 字母 \\A 非字母 \\l 小写字母 \\L 非小写字母 \\u 大写字母 \\U 非大写字母 比如，你想匹配 09/01/2000，可以使用下面的正则表达式， \\d\\d/\\d\\d/\\d\\d\\d\\d 匹配一个首字母大写的六字母单词， \\u\\w\\w\\w\\w\\w 如果你想匹配一个不知道长度的单词或者一个长单词，写出每个\\w不是很方便，这就要用到下面介绍的**量词（quantifiers）**概念了。 4.3量词、贪婪匹配与惰性匹配 将一个量词（quantifiers）放置在模式（pattern）一部分后面，就可以限制这部分的重复次数。 量词 说明 * 0个或多个，.*匹配任何东西，甚至一个空行 \\+ 1个或多个 \\= 0个或1个（pingao注：相当于?） \\{n, m} 匹配n到m次 \\{n} 匹配n次 \\{, m} 匹配0到m次 \\{n, } 至少匹配n次 n和m都必须是正整数 现在很容易就能写出一个匹配任意长度单词的表达式：\\u\\w\\+。 上面这些量词都是工作在贪婪模式下的，它们会尽可能多的匹配字符。有时候这会带来意想不到的问题，考虑一个典型的例子，假如你想匹配一个含有某种限定符的文本，比如被引号或者括号包围的文本，因为你不知道这些限定符里有什么，我们可以使用/&quot;.*&quot;/。 但是这个表达式将会匹配任何处于第一个引号和最后一个引号中间的文本，如粗体标注的部分 this file is normally “$VIM/.gvimrc”. You can check this with “:version”. 这种问题可以使用惰性（non-greedy）量词来解决， 量词 说明 \\{-} 0个或多个，尽可能少的匹配 \\{-n,m} n个或多个，尽可能少的匹配 \\{-n, } 至少匹配n次，尽可能少的匹配 \\{-, m} 至多匹配m次，尽可能少的匹配 让我们用\\&#123;-&#125;替换上面的*，所以.\\&#123;-&#125;将会匹配第一个引号的内容。 this file is normally “$VIM/gvimrc”. You can check this with “:version”. \\&#123;-&#125;确实没有让我们失望，下面看看执行下面的命令将会发生什么， :s:.\\&#123;-&#125;:_:g 执行前： n and m are decimal numbers between 执行后： n a_n_d m a_r_e d_e_c_i_m_a_l n_u_m_b_e_r_s b_e_t_w_e_e_n &quot;尽可能的少的匹配&quot;在这里的意思是匹配0个字符，然而匹配竟然发生在了字符之间，下面我引用Bram自己的话来解释这种行为， 匹配到0个字符也是一种匹配，因此它会将0字符替换为一个&quot;_&quot;，然后走到下一个位置，继续匹配到0个字符。 大部分情况下，\\&#123;-&#125;没有多大的用处，它的这种运行方式主要是为了和*保持一致，后者也会匹配0个字符，相比之下，x\\&#123;-1,&#125;是一种更加没用的写法，它只会匹配一个x，和x功能一样，比较有用的一种写法为x\\&#123;70&#125;，至于x\\&#123;-3,&#125;&quot;, &quot;x\\&#123;-2,&#125;&quot;, &quot;x\\&#123;-1,&#125;用处也不大，只是为了和贪婪模式的量词保持一致。 -Bram 但是如果你只想匹配第二个引号的内容呢？或者我们只想改变引号中的一部分内容呢？我们将会用到分组（grouping）和反向引用（backreference），在这之前我们先来看下字符区间的概念（character range）。 4.4字符区间 典型的字符区间： [012345]将会匹配括号中的任意一个，[0-5]与之等价，类似地，我们可以定义全部小写字母的字符区间[a-z]，所有的字母 [a-zA-Z]，数字加字母[0-9a-zA-Z]，根据你所在的区域，你可以在字符区间添加à, Ö, ß这样的非ASCII字符。 注意字符区间仅仅匹配其中的一个字符，[0123]和0123不同，顺序对于一个字符区间不重要，[0123]和[0231]一样，而0123和0231是两个截然不同的模式。看看执行下面的句子会发生什么， s:[65]:Dig:g 执行前： High 65 to 70. Southeast wind around 10 执行后： High DigDig to 70. Southeast wind around 10 然后执行 s:65:Dig:g 执行前： High 65 to 70. Southeast wind around 10 执行后： High Dig to 70. Southeast wind around 10 通过放置一个反选符号（^）在字符区间的最前面可以很容易的去除不愿匹配的字符，下面将会匹配除大写字母外的任意字符， /[^A-Z]/ 我们可以使用字符区间重写匹配引号内的文本， /&quot;[^&quot;]\\+&quot;/ 注意[]内部的元字符会失去其特殊的意义，所以如果你想要一个包含-的字符区间，把-放在最前面，如下表达式将会匹配所有的数字和-， /[-0-9]/ 同时^如果不在最前面，也会失去其特殊意义。 现在考虑一个现实的例子，假设有一个语法检测器想找出所有不以大写字母开头的句子，下面的表达式可以实现这一点， \\.\\s\\+[a-z] 这将会匹配一个句号、一个或多个空格然后是一个小写字母，我们现在知道如何找到错误，下面来看看如何修复它。这里就需要我们记住前面的匹配值以便后面可以重新调用它，这就是反向引用大显身手的地方了。 4.5分组和反向引用 你可以使用\\(\\)对模式匹配项进行分组，然后通过\\1, \\2 ... \\9来引用。一个典型的例子为交换每一行的头两个单词， s:\\(\\w\\+\\)\\(\\s\\+\\)\\(\\w\\+\\):\\3\\2\\1: \\1代表第一个单词，\\2代表一个或多个空白符，\\3代表第二个单词。如何知道哪个数字代表哪个匹配项，从左往右数\\(的个数。 # 含义 # 含义 &amp; 模式匹配到的全部内容 \\L 将后面的字符都转换为小写 \\0 同上 \\U 将后面的字符都转换为大写 \\1 第一个括号中匹配的内容 \\E end of \\U and \\L \\2 第二个括号中匹配的内容 \\e end of \\U and \\L … … \\r 将一行分为两行 \\9 第九个括号中匹配的内容 \\I 将下一个字符转换为小写 ~ 前面替换的字符串 \\u 将下一个字符转换为大写 看下上面的语法检查问题完整的表达式， s:\\([.!?]\\)\\s\\+\\([a-z]\\):\\1 \\u\\2:g 我们将0个或多个空白符替换为两个空格。 4.6备选 备选（alternation）是指用\\|将多个表达式结合在一起，这样一旦有一个表达式匹配到，则整个表达式匹配成功，返回这个表达式匹配内容。（pingao注：类似于逻辑操作符|） \\(Date:\\|Subject:\\|From:\\)\\(\\s.*\\) 上面的表达式将会把邮件的头部和内容放在\\1和\\2中，对于备选需要注意的是，它不是贪婪匹配的，一旦多个表达式有一个表达式匹配到，后面的表达式将不再匹配，这意味着对于一个备选，表达式的顺序十分重要。 Tip3:将\\(\\)快速的放在表达式中， cmap ;\\ \\(\\)&lt;Left&gt;&lt;Left&gt; 4.7正则表达式操作符的优先级 和算数表达式一样，正则表达式的运算符也有一定的优先级，下表从高到低列出了各个操作的优先级， 优先级 操作符 说明 1 \\(\\) 分组 2 \\=,\\+,*,\\&#123;n&#125; 量词 3 abc\\t\\.\\w 字符、元字符 4 “|” 备选 5.全局命令 5.1全局搜索及执行 我想介绍另一个用处广泛功能强大的命令， :range g[lobal][!]/pattern/cmd 在range的范围内，在pattern匹配行执行Ex cmd（默认为:p[rint]），如果pattern前面加上一个!，表示pattern没有匹配的行。 全局命令的工作原理为，第一遍扫描range范围的每一行，并对pattern匹配行做一个标记；第二遍对每一个标记行执行cmd。range默认为整个文件。 注意：Ex command包括所有你在VIM命令行输入的命令，比如 :s[ubstitute], :co[py] , :d[elete], :w[rite] 非Ex command（normal command）也可以执行， :norm[al]non-ex command 5.2例子 :g/^$/ d -删除文件中所以的空行 :g/^$/,/./-j -将多个空行转换为一个空行 :10,20g/^/ mo 10 -颠倒10到20行的顺序 下面是一个来自 Walter Zintz vi教程的例子，例子有改动 :'a,'b g/^Error/ . w &gt;&gt; errors.txt -在标记’a和’b之间找到以Error开始的行，然后将这些行追加到errors.txt。注意：w前面的.（当前行）不要漏掉，否则将会把整个文件追加到errors.txt中。 你可以使用|作为分隔符执行多个命令，如果你想在参数中使用|，要用\\对其进行转义。 Zintz的另一个例子， :g/^Error:/ copy $ | s /Error/copy of the error/ 将所有Error行拷贝到文件的最后，然后将Error替换为copy of the error。s命令没有指定地址，默认为当前行。 :g/^Error:/ s /Error/copy of the error/ | copy $ 将上面的操作顺序颠倒了一下，先替换后复制。 6.更多的例子 6.1小贴士 (1)由Antonio Colombo提供 去掉所有行尾部的空白符， s:\\s*$::或者s:\\s\\+$:: 6.2创建一个大纲 这个例子需要你有点html的背景，我们需要将&lt;h1&gt;和&lt;h2&gt;标签中的标题和副标题分离出来，做一个表格。 (1)首先我们给每个标签做一个标记，&lt;h1&gt;&lt;a name=&quot;anchor&quot;&gt;Heading&lt;/a&gt;&lt;/h1&gt;，anchor是标签的唯一标示，实现表达式如下， :s:\\(&lt;h[12]&gt;\\)\\(.*\\s\\+\\([-a-zA-Z]\\+\\)\\)\\s*\\(&lt;/h[12]&gt;\\):\\1&lt;a name=&quot;\\3&quot;&gt;\\2&lt;/a&gt;\\4: 说明： (2)接下来，将标题拷贝到一个地方， :%g/&lt;h[12]&gt;/ t$ 上面的命令将会把&lt;h1&gt;和&lt;h2&gt;标签所在行拷贝到文件的最后。现在文件的样子如下， &lt;h1&gt;&lt;a name=&quot;anchor1&quot;&gt;Heading1&gt;&lt;/a&gt;&lt;/h1&gt; &lt;h2&gt;&lt;a name=&quot;anchor2&quot;&gt;Heading2&gt;&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a name=&quot;anchor3&quot;&gt;Heading3&gt;&lt;/a&gt;&lt;/h2&gt; .......................... &lt;h1&gt;&lt;a name=&quot;anchorN&quot;&gt;HeadingN&gt;&lt;/a&gt;&lt;/h1&gt; 第一步，为了要把表格的元素链接到各自的位置，我们要把name=&quot;替换为href=&quot;#。 s:name=&quot;:href=&quot;#: 第二步，要让h1与h2看起来不同，我们定义&quot;majorhead&quot;和&quot;minorhead&quot;两个CSS类， g/&lt;h1&gt;/ s:&lt;a:&amp; class=&quot;majorhead&quot;: g/&lt;h2&gt;/ s:&lt;a:&amp; class=&quot;minorhead&quot;: 现在文件看起来像这样， &lt;h1&gt;&lt;a class=&quot;majorhead&quot; name=&quot;anchor1&quot;&gt;Heading1&gt;&lt;/a&gt;&lt;/h1&gt; &lt;h2&gt;&lt;a class=&quot;minorhead&quot; name=&quot;anchor2&quot;&gt;Heading2&gt;&lt;/a&gt;&lt;/h2&gt; #（pingao注：我认为此时文件应该是这样的） &lt;h1&gt;&lt;a class=&quot;majorhead&quot; href=&quot;#&quot;&gt;Heading1&gt;&lt;/a&gt;&lt;/h1&gt; &lt;h2&gt;&lt;a class=&quot;minorhead&quot; href=&quot;#&quot;&gt;Heading2&gt;&lt;/a&gt;&lt;/h2&gt; 我们不再需要&lt;h1&gt;和&lt;h2&gt;标签， s:&lt;h[21]&gt;:: 替换&lt;/h1&gt;和&lt;/h2&gt;标签为&lt;br&gt;， s:/h[21]:br: 现在文件的样子， &lt;a class=&quot;majorhead&quot; name=&quot;anchor1&quot;&gt;Heading1&gt;&lt;/a&gt;&lt;br&gt; &lt;a class=&quot;minorhead&quot; name=&quot;anchor2&quot;&gt;Heading2&gt;&lt;/a&gt;&lt;br&gt; #（pingao注：我认为此时文件应该是这样的） &lt;a class=&quot;majorhead&quot; href=&quot;#&quot;&gt;Heading1&gt;&lt;/a&gt;&lt;br&gt; &lt;a class=&quot;minorhead&quot; href=&quot;#&quot;&gt;Heading2&gt;&lt;/a&gt;&lt;br&gt; 6.3处理表格 很多情况下，你需要处理表格形式的文本。例如，下面的文本， Asia America Africa Europe Africa Europe Europe Africa Europe Asia Europe Europe Asia America Africa Europe Africa Europe Asia Africa Europe Asia Asia Europe Europe America Africa Asia Africa Europe Europe Africa Europe Asia Europe Europe 假设你想把第三列的&quot;Europe&quot;替换为 “Asia”， :%s:\\(\\(\\w\\+\\s\\+\\)\\&#123;2&#125;\\)Europe:\\1Asia: 交换前两列， :%s:\\(\\w\\+\\)\\(.*\\s\\+\\)\\(\\w\\+\\)$:\\3\\2\\1: 未完待续… 7.其他语言正则表达式特点 现在我将VIM的正则表达式与其他语言的正则表达式做一个对比，特别是Perl。提起正则表达式，Perl肯定不得不提。 （在Steve Kirkendall的帮助下整理）Perl和VIM的主要区别为， Perl的大多数元字符不需要反斜杠。个人认为，反斜杠越少越好，这样正则表达式会更加可读。 Perl中你可以在量词后加上一个?将贪婪模式的量词转换为非贪婪模式， 比如*?为非贪婪模式的*。 Perl的正则表达式支持各种奇怪的选项。 Perl的正则表达式可以包含变量，变量将会替换为具体的值，这称作&quot;变量替换&quot;。 8.链接 在正常模式下，输入&quot;:help pattern&quot;，阅读VIM帮助文档的正则表达式和搜索章节。 市场上有两本不错的介绍VIM正则表达式的书， “Learning the vi Editor” by Linda Lamb and Arnold Robbins. “vi Improved - VIM” by Steve Oualline Jeffrey Friedl的&quot;Mastering Regular Expressions&quot;是一本正则表达式的权威指南，此书主要介绍Perl的正则表达式，由O’Reilly出版，官网上有一章免费。","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://naosense.github.io/tags/vim/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://naosense.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"大道至简：朴素贝叶斯分类器","slug":"大道至简：朴素贝叶斯分类器","date":"2015-10-11T13:45:30.000Z","updated":"2025-09-16T02:08:42.968Z","comments":true,"path":"2015/10/11/大道至简：朴素贝叶斯分类器/","link":"","permalink":"https://naosense.github.io/2015/10/11/%E5%A4%A7%E9%81%93%E8%87%B3%E7%AE%80%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/","excerpt":"万物之始,大道至简,衍化至繁。 ——ifelse(is.element(this, 道德经), 道德经, unknown) 一、背景 提到贝叶斯分类，首先来看下贝叶斯其人，贝叶斯(Thomas Bayes,1701—1761)英国牧师、业余数学家。可别小看了欧洲的牧师，孟德尔，被誉为“遗传学之父”也曾为一名神父，假如你不记得孟德尔是谁，那么你肯定记得高中生物上那个著名的豌豆实验。","text":"万物之始,大道至简,衍化至繁。 ——ifelse(is.element(this, 道德经), 道德经, unknown) 一、背景 提到贝叶斯分类，首先来看下贝叶斯其人，贝叶斯(Thomas Bayes,1701—1761)英国牧师、业余数学家。可别小看了欧洲的牧师，孟德尔，被誉为“遗传学之父”也曾为一名神父，假如你不记得孟德尔是谁，那么你肯定记得高中生物上那个著名的豌豆实验。 具有讽刺意味的是，当初贝叶斯发明概率统计理论是为了证明上帝的存在，而至死这个愿望都没有实现，不过感谢伟大的贝叶斯，因为他的无心插柳，才有了今天的贝叶斯公式。接下来，来一睹贝叶斯公式的风采， $$P(B|A)=\\frac{P(B)P(A|B)}{P(A)}$$ 公式看起来是不是很简洁，看起来很有对称美。记得上学那会数学老师的一句话，假如你算出来的答案不够简洁，那么多半这道题你算错了。贝叶斯公式有什么意义呢？它解决了两个事件条件概率的转换问题。比如说，已知感冒导致流鼻涕的概率，那么流鼻涕有多大的概率感冒呢？贝叶斯可以解决这类问题。 二、贝叶斯分类 贝叶斯可以解决条件概率转换，可是它怎么与分类联系起来的呢？ 让我以一个例子加以说明，假设有这样一个数据集（本例来自朴素贝叶斯分类器的应用）， 症状(A1) 职业(A2) 疾病(B) 打喷嚏 护士 感冒 打喷嚏 农夫 过敏 头痛 建筑工人 脑震荡 头痛 建筑工人 感冒 打喷嚏 教师 感冒 头痛 教师 脑震荡 那么一个打喷嚏的建筑工人是感冒还是没感冒呢？ 根据贝叶斯定理， P(感冒|打喷嚏x建筑工人) = P(打喷嚏x建筑工人|感冒) x P(感冒) / P(打喷嚏x建筑工人) 假定&quot;打喷嚏&quot;和&quot;建筑工人&quot;这两个特征是独立的，因此，上面的等式就变成了 P(感冒|打喷嚏x建筑工人) = P(打喷嚏|感冒) x P(建筑工人|感冒) x P(感冒) / P(打喷嚏) x P(建筑工人) = 0.66 x 0.33 x 0.5 / 0.5 x 0.33 = 0.66 同理， P(非感冒|打喷嚏x建筑工人) = P(打喷嚏|非感冒) x P(建筑工人|非感冒) x P(非感冒) / P(打喷嚏) x P(建筑工人) = 0.33 x 0.33 x 0.5 / 0.5 x 0.33 = 0.33 因为P(感冒|打喷嚏x建筑工人) &gt; P(非感冒|打喷嚏x建筑工人) ，所以我们更愿意相信一个打喷嚏的建筑工人是感冒的。 从上面的例子可以看出，贝叶斯分类的步骤是这样的： 设$x = {a_1,a_2,\\cdots}$为一个待分类项，每个a为x的一个特征属性。 有类别集合$C = {y_1,y_2,\\cdots,y_n}$. 根据训练集计算，$P(y_1|x), P(y_2|x),\\cdots,P(y_n|x)$. 如果$P(y_k|x)=max{P(y_1|x), P(y_2|x),\\cdots,P(y_n|x)}$，则$x$的分类为$y_k$。 说到贝叶斯分类，还有几个需要注意的问题： 如果已知条件不止一个属性，二是多个呢，这个时候贝叶斯公式可以写作$$P(y|a_1a_2\\cdots)=\\frac{P(y)P(a_1a_2\\cdots|y)}{P(a_1a_2\\cdots)}=\\frac{P(y)P(a_1|y)P(a_2|y)\\cdots}{P(a_1)P(a_2)\\cdots}$$上述公式假设特征属性$a_1,a_2\\cdots$相互独立，这也是“朴素”一词的由来。另外，可以看到对于不同的分类，分母都是恒定的，而我们只想找到概率最大的类别，因此可以把分母省略，求条件概率的相对值，$$P(y|a_1a_2\\cdots)_{relative}=P(y)P(a_1|y)P(a_2|y)\\cdots$$ 不知道大家有没有注意到，上面的已知条件都是离散值，如果是连续值呢，对于连续值通常有两种办法，一是将连续值截取为离散值，然后求概率，二是假定离散值服从高斯分布，即$$f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}exp(-\\frac{(x-\\mu)^2}{2\\sigma^2})$$因为我们只需求概率的相对值，所以这里只需计算属性的概率密度值即可。 还有一个问题，当某些类别下某个特征值计数为0，即$P(a_i|y_j)$=0，这会使某些分类最终的概率为0，会降低分类器的准确性，为了解决这个问题，引入Laplace校准，就是对这些类别的某些特征值计数加1，这样如果训练样本集数量充分大时，并不会对结果产生影响。 如果想更详细的了解贝叶斯分类，请参考这两篇文章分类算法之朴素贝叶斯分类和朴素贝叶斯分类器的应用。 接下来，我用R语言实现一个分类器并用一些数据集测试分类效果。 三、算法实现 程序主要由三部分组成： 分类器主要由下面几个函数组成，具体的代码见GitHub。 # 1.求各个分类概率P(ycol) get.ytable &lt;- function(ycol, trainset) # 2.1求离散属性xcol的条件概率P(xcol|ycol) get.discrete.xtable &lt;- function(xcol, ycol, trainset) # 2.2求连续属性xcol的概率密度，假设服从高斯分布 get.continout.xdensity &lt;- function(xcol, ycol, trainset) # 3.对于某些概率为零的类别，采用Laplace校准设置默认值 get.defaultx &lt;- function(ycol, trainset) # 注：xcol特征属性，ycol类别属性，trainset训练集 下面以基础包里的iris数据集验证一下分类器的效果，选取前四列为特征，预测鸢尾花的种类， 图上有两条曲线，黑色为我实现的贝叶斯分类器，红色虚线为e1071包里的一个贝叶斯分类器实现。观察可得，随着训练集样本数的增加，测试集的分类正确率越来越高。 再来看看特征属性的选取对正确率的影响， 这次只选择了第二列（花萼宽度）作为特征值，可以看到正确率明显下降了。 再来看一个多分类问题，采用北京二手房这个数据集， 通过房价和是否学区这两列来预测房子所在的区，可以看到这两个特征属性的预测正确率稳定在0.4左右，下面再添加户型、朝向、楼层三列， 上图显示，添加了三个特征属性后，正确率并没有明显的改善，但是如果再添加一个区域列(con)， 由图观察，添加了区域这一列后，正确率得到了大幅度的提升，事实上仅保留区域这一列，预测的正确率也很高，这是因为区域(con)与区(area)的相关性较强。 根据我实验的结果，通常情况下，提高预测正确率的方法有两种： 增加训练集样本数，但是样本到达一定的数目正确率就保持稳定，很难再提高了。 选取恰当的特征，注意单纯的增加特征数目并不能提高正确率，反而会引入更多的误差造成过拟合。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://naosense.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"贝叶斯","slug":"贝叶斯","permalink":"https://naosense.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"当Python和R遇上北京二手房（下）","slug":"当Python和R遇上北京二手房（下）","date":"2015-09-05T11:47:00.000Z","updated":"2025-09-16T02:08:42.975Z","comments":true,"path":"2015/09/05/当Python和R遇上北京二手房（下）/","link":"","permalink":"https://naosense.github.io/2015/09/05/%E5%BD%93Python%E5%92%8CR%E9%81%87%E4%B8%8A%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"四、各区情况 作为买房者第一步就是看房选房，那么各区的情况是怎样的呢？下面从买房者比较注重的五个方面横向对比一下。","text":"四、各区情况 作为买房者第一步就是看房选房，那么各区的情况是怎样的呢？下面从买房者比较注重的五个方面横向对比一下。 1.各区总价 （图中红点为本区域的均值） 果然不出所料，西城、东城、海淀、朝阳四区均值和中位数均在前列，且数据区间分布比较广，而一些新兴的郊区如房山、门头沟、燕郊总价则较为集中，大概是因为房子是同一时期建设，功能需求也比较单一的缘故。 另外我注意到，各区的总价均值均不同程度的偏离中位点，城区偏离较大，郊区偏离较小，是不是因为城区房子需求多样，一些别墅豪宅拉高了均值？值得注意是顺义的均值超过了上四分位数，是不是顺义有较大比例的高档房产呢？ 下面换个角度，以二维直方图来展示下 由于各区二手房总量差异较大，这里的颜色代表的是总价区间在本区的占比，从这张图上可以看到西城、东城、海淀、朝阳、顺义确实有一定数量的千万房产。 2.各区单价 这张图很有意思，能发现很多东西。 第一，市区的房价高，郊区房价低，这傻子都知道，呵呵。第一梯队东西城、海淀50%的房子单价都在5万以上，想买这些地方的房子，看看腰包鼓不鼓，第二梯队朝阳、丰台、石景山大部分房子都在3万以上，第三梯队剩下的区房价大部分都在2万5以下，燕郊最低，基本上在1万2左右； 第二，市区的房价范围广，均值偏离中位数幅度大，比如东西城，应该是这两区一些高质量的学区房导致。 3.各区面积 （图中红点为本区域的均值） 可以看出一个趋势，郊区的房子要比市区的房子大。例如东西城面积中位数在75平米左右，而昌平、亦庄等均在100平米左右。还有就是市区房子面积范围较大，而郊区可能起步较晚，基本上建筑年代都在同一时期，房子的面积也较为单一。 顺义200平米的房子比例不少，再结合其千万以上的总价，看来顺义卧虎藏龙。 4.各区建筑年代 这张图上印证了上面的猜测，昌平、房山、亦庄、通州、燕郊等郊区房子建筑年代较为集中，尤其是燕郊，基本上都是2010年左右的房子，而最近因市政府东迁而大火的通州75%的房子是2000年后。而东西城、海淀等区域则是各个年代的房子都有。 从这张图似乎更能明显的看出，昌平、通州、亦庄、燕郊都有一些颜色较深的色块。大兴、房山、顺义、亦庄、燕郊均有超过20%的2010年后的房子，东城、石景山、西城则有20%的90年以前的老房子。 5.各区学区 再来看一下喜闻乐见的学区房，不出所料，海淀区的学区房最多，朝阳区学区次之。由于没有对学区的质量进行分类，东西城这两区虽然数量不如前两者，但是从质量上这两区应该是不言而喻的。 上面，从5个方面分区域做了一下比较，总结一下，喜欢新房的多去昌平通州等区走走，想要学区房的海淀、朝阳是你的选择，如果你只想最贵的，那么东城、西城是你的不二之选，如果你是土豪，顺义是个好去处。 五、一些有意思的事 1.房子是不是随着时代的发展越来越大了呢？ 因为大部分房子都在1985 ~ 2015这个时间段，我将视角集中在这个时间段。图中红线为均值， 蓝线为中位数。 从图上可以很清楚的看出在1995年房屋面积有一个很明显的上扬，到2000年左右保持平稳，从之前的60平到100平，从2005年开始又有小幅度的下降，难道是刚开始起高了？还有一点是，1995年前的房子，均值和中位数基本持平，95年之后均值大于中位数10个平方左右，是否可以得出以前我们都是无产阶级，现在确实有一部分先富起来了哈哈。 看来，随着时代的发展房屋面积确实有了不小的增长，希望随着时代的进步，人人都能住得起大房子。 2.学区房房价要比非学区贵多少呢？ 数据显示，各个区学区房房价确实要比非学区贵一些，这个差距大概在5000 ~ 15000左右,石景山、西城这个差距 较大，都在10000以上，昌平和海淀稍微低些，大约每平方相差8,9千，朝阳东城相差的不多，丰台通州几乎持平。 3.那些地方房价最贵？ 这些房价最贵的地方除万柳其余都在二环以里，基本上分布在北京最中心的地带，果然寸土寸金啊。 4.哪些地方千万豪宅最多？ 而一些豪宅就不一样了，除金融街其余都在三环以外。这也难怪，三环里面就那么点地方，早就占满了，想要豪宅就得往郊区盖，比如中央别墅区、西北旺都在五环以外。 5.哪些地方学区最多呢？ 学区最多的十个区域，朝阳四个，海淀两个，西城两个，东城两个。 六、总结 通过两篇文章，我尝试对北京二手房的一些特点进行了分析，分析很初级，基本上就是统计个数量或者比例，对于一些高大上的统计分析方法也在学习当中，等学的差不多了，再补上。 说句题外话，即便是最简单的数据展示和统计分析也能让人学到不少东西，当你着手开始做的时候，你会碰到各种各样的问题，小到图形的字体怎么调整、图形的legend如何改变，大到一些统计方法的实用、数据的处理方法等，鼓励大家根据自己的兴趣，自己动手整一个小的数据集，在这个基础上有目的的进行学习，有道是，当你上路了，你就已经进步了。","categories":[],"tags":[{"name":"r","slug":"r","permalink":"https://naosense.github.io/tags/r/"},{"name":"python","slug":"python","permalink":"https://naosense.github.io/tags/python/"},{"name":"统计","slug":"统计","permalink":"https://naosense.github.io/tags/%E7%BB%9F%E8%AE%A1/"},{"name":"北京","slug":"北京","permalink":"https://naosense.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"二手房","slug":"二手房","permalink":"https://naosense.github.io/tags/%E4%BA%8C%E6%89%8B%E6%88%BF/"}]},{"title":"当Python和R遇上北京二手房（上）","slug":"当Python和R遇上北京二手房（上）","date":"2015-09-02T22:26:36.000Z","updated":"2025-09-16T02:08:42.975Z","comments":true,"path":"2015/09/02/当Python和R遇上北京二手房（上）/","link":"","permalink":"https://naosense.github.io/2015/09/02/%E5%BD%93Python%E5%92%8CR%E9%81%87%E4%B8%8A%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"最近忙活了一阵子，终于把房子的事情落实了，俗话说饱暖思淫欲，某天突发奇想能不能利用手头上的一些工具对北京的二手房数据捣鼓一下，看看能不能有一些有意思的发现？想到以前有点python经验，正巧最近也在看R，正好借此机会巩固一下，齐活，走起！","text":"最近忙活了一阵子，终于把房子的事情落实了，俗话说饱暖思淫欲，某天突发奇想能不能利用手头上的一些工具对北京的二手房数据捣鼓一下，看看能不能有一些有意思的发现？想到以前有点python经验，正巧最近也在看R，正好借此机会巩固一下，齐活，走起！ 一、数据准备 看了下各大房产网站，从数据的量级、真实性、即时性等方面对比了下，有的数据挺多，但是数据真实性不高，上面既有房主的帖子，也有中介的帖子；有的真实性不错，但是房源太少，综合对比下来，最终选择了某家网。 有了数据源，用Python写了一个爬虫，从网站上随机爬取了30000条房源数据。有人可能说数据太少了，少就少吧，这里只是想起到一个抛砖引玉的作用。 二、数据整理 来看下获取的数据，每条数据描述了房子的13个属性，分别为：区、小区、户型、面积、朝向、区域（区下面更细分的一级，比如昌平的天通苑、回龙观）、楼层、房龄、学区、地铁、税、总价、单价。 区，原始数据都是英文代号，比如BJCP代表昌平，BJCY代表朝阳，为了查看起来方便，将它们都替换为相应的中文名。 楼层，原始数据大部分是以“低楼层”、“中楼层”这样的楼层区间划分的，不过有少量数据也写了具体楼层，我统一把它替换为楼层区间。 学区和地铁，我进行了简化，只进行了是否学区、是否地铁的划分，对于学区的品质，地铁的远近没有细分。 税，抓取的30000条数据里面很奇怪只有“满五唯一”和空值这两种，并没有例如“满二不唯一”、“满二唯一”等类型，为了简化，就认为空值没有免税。 对异常值的处理，查看了一下数据，通过与网站上同区域同小区的数据对比，有一些年代过早、总价、单价过高过低等异常情况，比如年代为1000年的房子，总价43亿的“西山小镇”等等，这可能是信息录入员笔误或者采用了默认值造成，由于异常值占比较小，我进行了简单的删除处理。 为了对面积、年代这样的连续值进行分组，我增加了四列， 面积分组：0~50, 50~100, 100~150, 150~200, &gt;200 年代分组：&lt;1990, 90~95, 95~00, 00~05, 05~10, 10~15, &gt;=2015 总价分组：0~1, 1~2, 2~3, 3~4, 4~5, 5~6, 6~7, 7~8, 8~9, 9~10, &gt;10，单位为百万 单价分组：0~1万, 1~2万, 2~3万, 3~4万, 4~5万, 5~6万, 6~7万, 7~8万, 8~9万, 9~10万, &gt;10万 整理完共有29790条数据，这是数据的结构： ## 'data.frame': 29790 obs. of 17 variables: ## $ area : Factor w/ 15 levels &quot;昌平&quot;,&quot;朝阳&quot;,..: 2 13 7 7 15 5 6 14 2 11 ... ## $ region : Factor w/ 5139 levels &quot;@北京&quot;,&quot;10AM新坐标&quot;,..: 674 2299 1789 1955 1063 463 2764 407 2480 2601 ... ## $ zone : Ord.factor w/ 53 levels &quot;0室0厅&quot;&lt;&quot;0室1厅&quot;&lt;..: 12 27 12 6 11 16 11 6 6 16 ... ## $ meters : int 67 408 75 47 83 136 68 57 55 128 ... ## $ direction: Factor w/ 50 levels &quot;&quot;,&quot;北&quot;,&quot;北东北&quot;,..: 40 26 27 26 26 27 27 26 2 27 ... ## $ con : Factor w/ 221 levels &quot;CBD二手房&quot;,&quot;安定门二手房&quot;,..: 169 158 132 207 196 215 189 201 73 114 ... ## $ floor : Ord.factor w/ 4 levels &quot;地下室&quot;&lt;&quot;低楼层&quot;&lt;..: 2 2 2 4 3 2 3 4 3 3 ... ## $ year : int 2000 2002 1996 1997 2007 2010 2011 2008 2000 1998 ... ## $ school : Ord.factor w/ 2 levels &quot;无学区&quot;&lt;&quot;有学区&quot;: 2 2 1 1 1 1 1 1 1 1 ... ## $ subway : Ord.factor w/ 2 levels &quot;无地铁&quot;&lt;&quot;有地铁&quot;: 2 1 2 1 1 1 1 2 2 1 ... ## $ tax : Factor w/ 2 levels &quot;非免税&quot;,&quot;满五年唯一&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ num : int 360 950 290 260 95 350 220 120 180 205 ... ## $ price : int 53732 23285 38667 54622 11446 25736 32353 21053 32728 16016 ... ## $ meters_cg: Ord.factor w/ 5 levels &quot;0~50&quot;&lt;&quot;50~100&quot;&lt;..: 2 5 2 1 2 3 2 2 2 3 ... ## $ year_cg : Ord.factor w/ 7 levels &quot;&lt;1990&quot;&lt;&quot;90~95&quot;&lt;..: 4 4 3 3 5 6 6 5 4 3 ... ## $ num_cg : Ord.factor w/ 11 levels &quot;0~1&quot;&lt;&quot;1~2&quot;&lt;&quot;2~3&quot;&lt;..: 4 10 3 3 1 4 3 2 2 3 ... ## $ price_cg : Ord.factor w/ 11 levels &quot;0~1万&quot;&lt;&quot;1~2万&quot;&lt;..: 6 3 4 6 2 3 4 3 4 2 ... 三、数据概览 下面从总体上看下数据， 1.县区分布 本次抽到的数据包括北京13个区和2个特别区域亦庄和燕郊，后两个地方不是区，但是在北京的朋友都知道，这两个地方有可能比某些区还有名。 总体来看市区的二手房市场比较活跃，可以看到朝阳、海淀、丰台分列三甲，三个区的二手房之和几乎占去了北京二手房一半的数量，朝阳一个区的岀房量更是比后两名都多。昌平区和燕郊紧随其后，昌平区有天通苑和回龙观这两个人口聚集区（这个后面会看到），而燕郊满足了一些在城区无法买房，又要在市区工作的人的需求，二手房数量也是不容小觑。 2.户型分布 最多的是两室一厅，占到33%，然后是一室一厅、三室两厅、三室一厅这样的户型。 看来小户型还是主流，不过这有可能因为一是大部分二手房年代较早，小户型较多,不过查看了下数据，2000年以后的房子二室一厅也有26%；另外一点可能是北京房价太贵，作为购房者的主体普通大众大部分购买力有限，开发商盖房的时候主要盖的就是这种户型。 3.面积分布 右上角密度图显示本次抽取的数据，面积的区间为0 ~ 3000平方，不过大部分的房子的面积还是集中在一个 较小的范围内。从下图可以看到大部分面积都落在50 ~ 150这个区间，50 ~ 100的房子约为54%，而200平米 以上的大房子仅为6%。 不太清楚其他地方的房子，在北京房子的面积和要交的税是有关系的。这可能在一定程度上会遏制房子的面积。 4.朝向分布 买过房的都知道，朝向很重要。什么东西向的只有早晚才能见阳光，北向的天天喝西北风，衣服都晒不干，还有一些风水上的讲究就更复杂了，反正我是不懂，凡此种种，充分说明了买房者对朝向的注重。 由于朝向比较多，这里只挑选了数量最多的10种。从图上我发现南北向、南向这些大家都比较喜欢的朝向竟然最多，二者合起来约有61%，这点和自己的看房经历不太一样，咋看有点不可思议，细想原因可能是这样的，一般楼房建设的时候，都是南北朝向的，我想没有哪个傻帽故意把房子盖成朝北的，盖好以后一些边角没有办法，朝向为东西、北等等，所以主体还是南北。 5.区域分布 由于区域众多，我这里只选择了出房量最多的10个区域。从上图可以看到，二手房数量最多的10个区域恰恰也是北京人口较为密集的区域，10个区域朝阳3个，昌平2个，房山1一个，顺义1个，门头沟1个，石景山1个，燕郊1个。 前面我们看到，北京二手房数量以朝阳为最，朝阳以望京为最，望京一个区域占了朝阳12%的房产数量。而天通苑、回龙观也不负众望，分别为第三和第四，另外如良乡、顺义城等我们熟知的人口聚居区交易也异常火爆，假如岀房量能在一定程度上代表交易量的话。 6.楼层分布 买房者对楼层的重视也是不言而喻，众所周知，顶层和低层的房子一般人都不太喜欢，顶层房子冬天冷夏天热，低楼层比较潮湿等等，这两种房子住起来不是那么舒服，所以我原本以为卖房的大部分是这两种楼层。 不过从数据上看，楼层分布比较平均，这点也和自己的看房经历不太一样，从自己的看房经历来看中楼层较少，大部分的二手房都是高楼层或者低楼层。原因可能和楼层的划分有关系，比如一座20层的楼房，1 ~ 5为低层，6 ~ 15为中层，16 ~ 20为高层，这样中楼层就比较多了。 7.建筑年代分布 房子的建筑年代对于土豪不是那么重要，但是对于普通购房者就不一样了，因为贷款的年限和房龄是有关系的。一般情况下钢混结构带电梯的贷款年限为57减去房龄，砖结构比如6层不带电梯的板楼是45减去房龄，具体的年限和你的房屋具体评估值有关系，我在网上找了半天，没有找到这种算法的明文规定，这应该是一个经验值，不过具有一定的准确性。也就是说你想贷款30年，钢混的必须至少为88年后的，砖混的必须至少是2000年后的。 数据显示，建筑年代区间为1952 ~ 2015，从图中可以看到，建筑年代主要集中在1995年到2015年这个时间段， 2000年后的房子竟然占了总量的72%。这是我没有想到的，因为看房的时候，看到的房子基本上都是90年代的房子，这可能和当初我的定位有关系，当初买房的时候就想买个离市区近点的，上班方便，房子老点没关系，而市区可能新房子较少。 8.学区房、地铁房、免税房 这三个属性有点相似，放在了一起。这里没有对学区的优劣，地铁的远近等进行细分，只是简单粗暴的分为有无两种。 从图上可以看到学区的差异性较大，学区房只占总量的20%，怪不得学区房这么贵了；而地铁就较为普遍了，随着北京城市交通的建设地铁越来越多，表现在住房上就是地铁房的比例越来越高，约占41%，相信随着城市的发展，这个比例会越来越高。 税费这一项对于普通购房者也很重要，例如满五唯一只有1%的契税，满二唯一还要加收差价20%的个税，具体的费率和是否首套，房屋面积也有一定的关系，买房的朋友可以去查查。 数据显示，满五唯一的房子约为38%，比例不算低，看来，虽说大部分的房子都是2000年后的房子，有相当一部分的人还是在房子满五年之后再出售，虽然房主可以把税费转移到购房者身上，但是定价太高，房屋就不好出了，所以国家的征税政策对房产的恶意交易是有一定的作用的。 9.总价分布 对于总价和单价两种数据，我都是抱着猎奇的态度看待的，不过这两个数据的重要性自不必说，特别是总价，因为这关系到你的预算。看密度图（单位为万元），还真有3亿元的房子，我应该没数错0的个数，不过好在这样的房子只是凤毛麟角，让我等凡人还有些念想。 从直方图上可以看出100 ~ 300万的房子大概有50%，不过大于500万的房子也占到了17%，还得好好努力挣钱啊。 10.单价分布 单价对于普通购房者可能不够直接，因为在我看来，一般人买房之前先确定了总价，也就是自己能拿出多少钱，然后再结合自己大致的需求，比如想要一个多大的，什么户型的等等，总价和需求定了基本上能购买的单价也就定了，也就是说单价影响你选择的余地，比如说你本来想买个100平方的，你在看房过程中特别中意一个小区，那个小区单价贵，你能拿出的钱就那些，那你只能换一个小点的房子了。 密度图（单位元）显示还有30万一平方的房子，赶紧看看是何方宝地，原来是两套5平方的学区房，好吧，喝口水压压惊。不过好在单价主要还是集中在1 ~ 5万的区间，约占80%，其中2 ~ 4万最多，约为总量的50%。 上面大致看了下数据的总体情况，并尝试对一些原因做了分析，当然有些只是推测，这段时间比较忙，正好趁阅兵放假的时间看看能不能从数据中发现一些有利的证据。","categories":[],"tags":[{"name":"r","slug":"r","permalink":"https://naosense.github.io/tags/r/"},{"name":"python","slug":"python","permalink":"https://naosense.github.io/tags/python/"},{"name":"统计","slug":"统计","permalink":"https://naosense.github.io/tags/%E7%BB%9F%E8%AE%A1/"},{"name":"北京","slug":"北京","permalink":"https://naosense.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"二手房","slug":"二手房","permalink":"https://naosense.github.io/tags/%E4%BA%8C%E6%89%8B%E6%88%BF/"}]}]}