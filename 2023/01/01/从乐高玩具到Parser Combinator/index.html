<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>从乐高玩具到Parser Combinator - 扯淡有理</title>
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:site" content="扯淡有理"/>
  <meta name="twitter:creator" content="@songneverend"/>
  <meta name="twitter:title" content="从乐高玩具到Parser Combinator - 扯淡有理"/>
  <meta name="twitter:description" content="&lt;h2 id=&#34;什么是Parser-Combinator&#34;&gt;什么是Parser Combinator&lt;/h2&gt;
&lt;p&gt;作为程序员，或多或少都会接触到解析字符串的任务， 比如从日志中解析出用户和id，这种工作可以用正则表达式轻松搞定，但是如果是解析json、xml这样复杂的结构，正则表达式就有点力不从心啦，这个时候有经验的程序员可能会想起Antlr、Yacc类似的解析器生成器，没错，这是一个可行的方案，这个方案需要你了解基本的词法、语法知识，编写一些晦涩的EBNF文件，不过好在除了这套方案，还有另一种方法，那就是今天要说的Parser Combinator。&lt;/p&gt;"/>
  <meta name="twitter:image" content="https://naosense.github.io/2023/01/01/%E4%BB%8E%E4%B9%90%E9%AB%98%E7%8E%A9%E5%85%B7%E5%88%B0Parser%20Combinator/lego.png"/>
  <meta property="og:site_name" content="扯淡有理">
  <meta property="og:title" content="从乐高玩具到Parser Combinator - 扯淡有理"/>
  <meta property="og:type" content="website"/>
  <meta property="og:locale" content="zh-CN"/>
  <meta property="og:description" content="&lt;h2 id=&#34;什么是Parser-Combinator&#34;&gt;什么是Parser Combinator&lt;/h2&gt;
&lt;p&gt;作为程序员，或多或少都会接触到解析字符串的任务， 比如从日志中解析出用户和id，这种工作可以用正则表达式轻松搞定，但是如果是解析json、xml这样复杂的结构，正则表达式就有点力不从心啦，这个时候有经验的程序员可能会想起Antlr、Yacc类似的解析器生成器，没错，这是一个可行的方案，这个方案需要你了解基本的词法、语法知识，编写一些晦涩的EBNF文件，不过好在除了这套方案，还有另一种方法，那就是今天要说的Parser Combinator。&lt;/p&gt;"/>
  <meta property="og:image" content="https://naosense.github.io/2023/01/01/%E4%BB%8E%E4%B9%90%E9%AB%98%E7%8E%A9%E5%85%B7%E5%88%B0Parser%20Combinator/lego.png"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=Parser Combinator,Rust,Scala>
  
    <meta name="description" content="Java Python R 机器学习 统计 扯淡">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="扯淡有理" type="application/atom+xml">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdn.bootcss.com/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.7.0/languages/scala.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=default"></script>
  <script>
      hljs.highlightAll();
  </script>
  <script type='text/x-mathjax-config'>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/SVG"],
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        },
        messageStyle: "none"
    });
  </script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-44085500-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-44085500-1');
  </script>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-D4YST94BJZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-D4YST94BJZ');
  </script>

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">扯淡有理</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">主页</a>
        </li>
      
        <li class="menu-item">
          <a href="/tags" class="menu-item-link">标签</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">关于</a>
        </li>
      
        <li class="menu-item">
          <a href="/atom.xml" class="menu-item-link">订阅</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">从乐高玩具到Parser Combinator</h1>
    
  </div>
   <div class="post-meta">
    <span class="post-time">2023-01-01</span>
  </div>
  <div class="post-content">
    <h2 id="什么是Parser-Combinator">什么是Parser Combinator</h2>
<p>作为程序员，或多或少都会接触到解析字符串的任务， 比如从日志中解析出用户和id，这种工作可以用正则表达式轻松搞定，但是如果是解析json、xml这样复杂的结构，正则表达式就有点力不从心啦，这个时候有经验的程序员可能会想起Antlr、Yacc类似的解析器生成器，没错，这是一个可行的方案，这个方案需要你了解基本的词法、语法知识，编写一些晦涩的EBNF文件，不过好在除了这套方案，还有另一种方法，那就是今天要说的Parser Combinator。</p>
<span id="more"></span>
<p><img src="lego.png" alt="lego"></p>
<p>如果你去网上搜索它，上面的文章上来不是Monad、Functor，就是范畴论、幺半群这些玄而又玄的概念，导致我虽然很早就听过Parser Combinator，但一直都只敢远观。直到最近看了Bodil<a target="_blank" rel="noopener" href="https://bodil.lol/parser-combinators/">一篇文章</a>，写的深入浅出。看完之后我才知道Parser Combinator原来是两种算子，一种叫解析器，另一种叫组合器，也叫组合子，原理也很直接，就像搭积木，由一些基本的构件搭出城堡的各个部分，再由各个部分搭出整个城堡，整个过程没啥玄学。原文中的程序是Rust编写的，考虑到Rust语言的受众规模，以及Rust的一些核心理念会平白增加编写Parser Combinator的难度，比如借用引用、生命周期，我打算用Scala重写一下，并按照Scala的习惯做下调整。</p>
<p>我一直认为最好的学习方法是<em>learn by doing</em>。因此建议大家在电脑上跟着敲一遍代码，哪怕只是粘贴一下看看运行效果，你绝对能找到和玩乐高类似的乐趣。</p>
<h2 id="简化版xml解析器">简化版xml解析器</h2>
<p>我们的目标是编写一个简化版的xml解析器，因为完整的xml包含namespaces、schema等一大堆琐碎的概念，要实现一个完备的解析器用来作为入门还是过于复杂了，因此我们只实现xml的一个子集，下面是一段示例，</p>
<pre><code class="language-xml">&lt;parent-element&gt;
  &lt;single-element attribute=&quot;value&quot; /&gt;
&lt;/parent-element&gt;
</code></pre>
<p>可以看到，它的结构有两种：</p>
<ul>
<li>一开一闭(open-close-element)：<code>&lt;标识符&gt;&lt;/标识符&gt;</code></li>
<li>单元素(single-element)：<code>&lt;标识符/&gt;</code></li>
</ul>
<p>第一种通常会包含一些子元素，子元素通常又会包含孙元素，形成一种递归结构。标识符后面还会有一些空白符分割的可选属性对，比如上面的<code>attribute=&quot;value&quot;</code>。合格的标识符由字母开头，后面可以使用字母数字或-。</p>
<h3 id="解析器的类型">解析器的类型</h3>
<p>让我们首先想一下，什么是解析器？一个解析器就是给它一个字符串，然后它把你感兴趣的内容挑出来输出给你，在scala中就可以这么表示，</p>
<pre><code class="language-scala">String =&gt; Try[(String, Output)]
</code></pre>
<p><code>Try</code>有两个子类<code>Success</code>和<code>Failure</code>，正好可以用来表示解析成功与否，<code>(String, Output)</code>是一个二元组，前面的元素表示剩余未被解析的字符串，后面的<code>Output</code>表示最终的输出格式，由于这个格式不定，所以表示为一个泛型。</p>
<h3 id="字符a解析器">字符<code>a</code>解析器</h3>
<p>先拿一个简单的练练手，来编写关于字符a的解析器。</p>
<pre><code class="language-scala">def theLetterA(input: String): Try[(String, Unit)] = &#123;
  input.toList match &#123;
    case first :: rest if first == 'a' =&gt; Success((rest.mkString, ()))
    case _ =&gt; Failure(ParseError(input))
  &#125;
&#125;
case class ParseError(input: String) extends Throwable
case class Element(name: String, attributes: Vector[(String, String)], children: Vector[Element])
</code></pre>
<p>这段代码的逻辑是将<code>input</code>转成字符列表，如果第一个字符为a，则解析成功，否则失败。这里我们定义了自己的错误类<code>ParseError</code>以及最终的解析结果数据结构<code>Element</code>。你可能注意到输出的位置上写的是<code>Unit</code>，它的含义类似Java中的<code>void</code>，这表示我们并不关心解析器的输出，这种解析器的作用只是为了将输入的解析位置往前推进，这种类型的解析器下面还会看到。</p>
<h3 id="字面量解析器">字面量解析器</h3>
<p>有了前面字符a的解析器基础，下面我们编写一个解析任意字符串字面量的解析器，</p>
<pre><code class="language-scala">def literal(expected: String): Parser[Unit] = &#123;
  (input: String) =&gt; &#123;
    input.take(expected.length) match &#123;
      case s if s == expected =&gt; Success((input.drop(expected.length), ()))
      case _ =&gt; Failure(ParseError(input))
    &#125;
  &#125;
&#125;
</code></pre>
<p>注意看，这个函数属于高阶函数，它的返回值本身也是一个函数。基本逻辑是输入的开头部分如果和字面量<code>expected</code>匹配上就成功，否则失败。</p>
<p>下面编写这个解析器的测试用例，使用的测试框架是munit，</p>
<pre><code class="language-scala">test(&quot;literal parser&quot;) &#123;
  val parseJoe = literal(&quot;Hello Joe!&quot;)
  assertEquals(parseJoe.parse(&quot;Hello Joe!&quot;), Success(&quot;&quot;, ()))
&#125;
</code></pre>
<p>运行一下，测试通过。因为<code>literal</code>返回是一个函数，所以可以像函数那样调用它。作为一个小tip，如果你使用sbt，你可以使用<code>~testOnly YOUR-TEST_CASE</code>进行持续测试，源文件一发生改变，测试就会自动运行，可以提高测试的效率。</p>
<h3 id="标识符解析器">标识符解析器</h3>
<p>还记得上面我们说过一个合法的标识符组成规则吗，对，首字符字母，后面是任意个字母数字或-。</p>
<pre><code class="language-scala">def identifier(input: String): ParseResult[String] = &#123;
  val matched = new StringBuilder()

  input.toList match &#123;
    case first :: _ if first.isLetter =&gt; matched.append(first)
    case _ =&gt; return Failure(ParseError(input))
  &#125;

  matched.append(input.drop(1).takeWhile(c =&gt; c.isLetterOrDigit || c == '-'))

  val nextIndex = matched.length;
  Success((input.drop(nextIndex), matched.toString()))
&#125;
</code></pre>
<p>这里的逻辑是首先去检测第一个字符是不是合法，如果合法将它收集到<code>matched</code>中，并检测后续符合要求的字符并收集，否则直接失败退出。与之前不同的一点是，在返回值上<code>Output</code>的位置这次为<code>String</code>，这是因为标识符的名字通常是很重要的信息，我们需要将它保存下来。</p>
<p>同样，我们编写这个解析器的测试用例，</p>
<pre><code class="language-scala">test(&quot;identifier parser&quot;) &#123;
  assertEquals(identifier(&quot;i-am-an-identifier&quot;), Success((&quot;&quot;, &quot;i-am-an-identifier&quot;)))
  assertEquals(identifier(&quot;not entirely an identifier&quot;), Success((&quot; entirely an identifier&quot;, &quot;not&quot;)))
  assertEquals(identifier(&quot;!not at all an identifier&quot;), Failure(ParseError(&quot;!not at all an identifier&quot;)))
&#125;
</code></pre>
<p>这三个用例第一个很好理解，i-am-an-identifier一整个是一个合法的标识符，第二个因为空格不能包含在标识符中，所以解析到not后面的空格就终止了，第三个因为开头的叹号不属于合法的字符，因此返回失败。</p>
<h3 id="组合组合子">组合组合子</h3>
<p>现在解析字符串的解析器有了，解析标识符的解析器也有了，想要解析&lt;identifier这样的字符串，还得有个将两个解析器组合起来的功能。</p>
<pre><code class="language-scala">def pair[R1, R2](parser1: (String) =&gt; Try[(String, R1)], parser2: (String) =&gt; Try[(String, R2)]): String =&gt; Try[(String, (R1, R2))] = &#123;
  (input: String) =&gt; &#123;
    parser1(input) match &#123;
      case Success((nextInput, result1)) =&gt; parser2(nextInput) match &#123;
        case Success((finalInput, result2)) =&gt; Success((finalInput, (result1, result2)))
        case Failure(ex) =&gt; Failure(ex)
      &#125;
      case Failure(ex) =&gt; Failure(ex)
    &#125;
  &#125;
&#125;
</code></pre>
<p>这里的逻辑是<code>parser1</code>先去解析，如果失败直接退出，否则由<code>parser2</code>去解析剩余的输入<code>nextInput</code>，如果成功，将两个解析器的结果组成一个二元组输出，否则失败退出。这意味着，两个解析器的都得解析成功，整体才是成功，否则就失败了。</p>
<p>有了这个组合器我们就有了组合任意两个解析器的能力，有点搭积木的意思了哈。同样地，测试用例来一个。</p>
<pre><code class="language-scala">test(&quot;pair combinator&quot;) &#123;
  val tagOpener = pair(literal(&quot;&lt;&quot;), identifier _)
  assertEquals(tagOpener.parse(&quot;&lt;my-first-element/&gt;&quot;), Success((&quot;/&gt;&quot;, ((), &quot;my-first-element&quot;))))
  assertEquals(tagOpener.parse(&quot;oops&quot;), Failure(ParseError(&quot;oops&quot;)))
  assertEquals(tagOpener.parse(&quot;&lt;!oops&quot;), Failure(ParseError(&quot;!oops&quot;)))
&#125;
</code></pre>
<p>注意第一个用例的<code>Output</code>类型为<code>((), String)</code>，<code>()</code>其实对我们没意义，我们只想要第二个解析器的结果，这就引申出来两个通用的组合子<code>left</code>和<code>right</code>，用于对结果进行修剪。</p>
<h3 id="类型转换组合子">类型转换组合子</h3>
<p>在认识<code>left</code>和<code>right</code>之前，我们先认识另一个通用的组合子<code>map</code>，map在很多编程语言中都有，作用大同小异，基本上就是将一个类型转换成另一个，有了它编写<code>left</code>和<code>right</code>就水到渠成了，因为使用<code>map</code>配合一个映射函数很容易就可以将二元组的其中一个元素挑出来。</p>
<pre><code class="language-scala">def map[A, B](parser: (String) =&gt; Try[(String, A)], fn: A =&gt; B): (String) =&gt; Try[(String, B)] = &#123;
  (input: String) =&gt; &#123;
    parser(input) match &#123;
      case Success((nextInput, result)) =&gt; Success((nextInput, fn(result)))
      case err@Failure(_) =&gt; err.asInstanceOf[Try[(String, B)]]
    &#125;
  &#125;
&#125;
</code></pre>
<p>首先<code>parser</code>去解析<code>input</code>，如果成功，转换函数<code>fn</code>将输出转换为另一种类型，如果失败，将原始错误返回。</p>
<h3 id="打扫屋子再请客">打扫屋子再请客</h3>
<p>在继续前进之前，先让我们停下来看一看已经完成的代码，大量的<code>Try[(String, Output)]</code>，<code>String =&gt; Try[(String, Output)]</code>冗长的类型充斥期间，是时候对代码进行一波“打扫”了。首先，使用type alias对<code>Try[(String, Output)]</code>进行化简，</p>
<pre><code class="language-scala">type ParseResult[Output] = Try[(String, Output)]
</code></pre>
<p>然后定义一个trait <code>Parser</code>，然后使用隐式转换机制将<code>String =&gt; Try[(String, Output)]</code>转换为<code>Parser</code>，</p>
<pre><code class="language-scala">@FunctionalInterface
trait Parser[Output] &#123;
  def parse(input: String): ParseResult[Output]
&#125;

implicit def function2parser[Output](f1: String =&gt; ParseResult[Output]): Parser[Output] = &#123;
  (input: String) =&gt; f1.apply(input)
&#125;
</code></pre>
<p>然后使用<code>Parser</code>和<code>ParseResult</code>分别去替换<code>Try[(String, Output)]</code>和<code>String =&gt; Try[(String, Output)]</code>，比如<code>map</code>重写后的如下，</p>
<pre><code class="language-scala">def map[A, B](parser: Parser[A], fn: A =&gt; B): Parser[B] = &#123;
  (input: String) =&gt; &#123;
    parser(input) match &#123;
      case Success((nextInput, result)) =&gt; Success((nextInput, fn(result)))
      case err@Failure(_) =&gt; err.asInstanceOf[ParseResult[B]]
    &#125;
  &#125;
&#125;
</code></pre>
<p>是不是比之前看起来比之前清爽多了。同样，重写下<code>pair</code>，</p>
<pre><code class="language-scala">def pair[R1, R2](parser1: Parser[R1], parser2: Parser[R2]): String =&gt; ParseResult[(R1, R2)] = &#123;
  (input: String) =&gt; &#123;
    parser1(input) match &#123;
      case Success((nextInput, result1)) =&gt; parser2(nextInput) match &#123;
        case Success((finalInput, result2)) =&gt; Success((finalInput, (result1, result2)))
        case Failure(ex) =&gt; Failure(ex)
      &#125;
      case Failure(ex) =&gt; Failure(ex)
    &#125;
  &#125;
&#125;
</code></pre>
<p>同样的方式，将前面所有的代码进行下替换。</p>
<h3 id="结果提取组合子">结果提取组合子</h3>
<p>有了<code>pair</code>和<code>map</code>，<code>left</code>和<code>right</code>已经呼之欲出了。</p>
<pre><code class="language-scala">def left[R1, R2](parser1: Parser[R1], parser2: Parser[R2]): Parser[R1] = &#123;
  map(pair(parser1, parser2), &#123; case (l, _) =&gt; l &#125;)
&#125;

def right[R1, R2](parser1: Parser[R1], parser2: Parser[R2]): Parser[R2] = &#123;
  map(pair(parser1, parser2), &#123; case (_, r) =&gt; r &#125;)
&#125;
</code></pre>
<p>逻辑很简单，<code>left</code>将二元组的第一个元素返回，<code>right</code>将二元组的第二个元素返回。</p>
<p>老样子，测试用例</p>
<pre><code class="language-scala">test(&quot;right combinator&quot;) &#123;
  val tagOpener = right(literal(&quot;&lt;&quot;), identifier _)
  assertEquals(tagOpener.parse(&quot;&lt;my-first-element/&gt;&quot;), Success((&quot;/&gt;&quot;, &quot;my-first-element&quot;)))
  assertEquals(tagOpener.parse(&quot;oops&quot;), Failure(ParseError(&quot;oops&quot;)))
  assertEquals(tagOpener.parse(&quot;&lt;!oops&quot;), Failure(ParseError(&quot;!oops&quot;)))
&#125;
</code></pre>
<p>这些用例和上面<code>pair</code>的用例极为相似，需要注意的只有第一个用例，观察和<code>pair</code>的第一个用例有哪些不同，对，类型由<code>((), String)</code>变成了<code>String</code>，这正是我们想要达成的效果。</p>
<h3 id="表示重复的组合子">表示重复的组合子</h3>
<p>还记得我们最开始介绍xml格式的时候说过，xml包含一些可选的属性对，它们以空白字符分割。这里面有两个关键词：“一些”和“可选”，如何表示这种含义呢？为此我们抽象出两个组合子：“一次及以上”和“零次及以上”，想想看，正则表达式也有类似的设计。<br>
我们先来看“一次及以上”</p>
<pre><code class="language-scala">def oneOrMore[A](parser: Parser[A]): Parser[Vector[A]] = &#123;
  (input: String) =&gt; &#123;
    var result = Vector[A]()
    var remain = input
    parser.parse(remain) match &#123;
      case Success((nextInput, firstItem)) =&gt; &#123;
        remain = nextInput
        result :+= firstItem
        var break = false
        while (!break) &#123;
          parser.parse(remain) match &#123;
            case Success((nextInput, nextItem)) =&gt; &#123;
              remain = nextInput
              result :+= nextItem
            &#125;
            case Failure(exception) =&gt; break = true
          &#125;
        &#125;
        Success((remain, result))
      &#125;
      case err@Failure(exception) =&gt; err.asInstanceOf[ParseResult[Vector[A]]]
    &#125;
  &#125;
&#125;
</code></pre>
<p>这里的逻辑是<code>parser</code>解析<strong>第一次</strong>必须得成功，否则直接就失败了，因为是一次及以上嘛。之后，可以成功，也可以失败，都不重要。聪明的你肯定已经想到了“零次及以上”的写法，就是把第一段去掉呗。</p>
<pre><code class="language-scala">def zeroOrMore[A](parser: Parser[A]): Parser[Vector[A]] = &#123;
  (input: String) =&gt; &#123;
    var result = Vector[A]()
    var remain = input

    var break = false
    while (!break) &#123;
      parser.parse(remain) match &#123;
        case Success((nextInput, nextItem)) =&gt;
          remain = nextInput
          result :+= nextItem
        case Failure(_) =&gt; break = true
      &#125;
    &#125;
    Success((remain, result))
  &#125;
&#125;
</code></pre>
<p>不需赘述。</p>
<p>测试用例</p>
<pre><code class="language-scala">test(&quot;one or more combinator&quot;) &#123;
  val parser = oneOrMore(literal(&quot;ha&quot;))
  assertEquals(parser.parse(&quot;hahaha&quot;), Success((&quot;&quot;, Vector((), (), ()))))
  assertEquals(parser.parse(&quot;ahah&quot;), Failure(ParseError(&quot;ahah&quot;)))
  assertEquals(parser.parse(&quot;&quot;), Failure(ParseError(&quot;&quot;)))
&#125;

test(&quot;zero or more combinator&quot;) &#123;
  val parser = zeroOrMore(literal(&quot;ha&quot;))
  assertEquals(parser.parse(&quot;hahaha&quot;), Success((&quot;&quot;, Vector((), (), ()))))
  assertEquals(parser.parse(&quot;ahah&quot;), Success((&quot;ahah&quot;, Vector.empty)))
  assertEquals(parser.parse(&quot;&quot;), Success(&quot;&quot;, Vector.empty))
&#125;
</code></pre>
<p>注意比较这两个解析器的不同，后两个一样的用例，一个失败，一个成功。想想为什么？</p>
<h3 id="谓词组合子">谓词组合子</h3>
<p>盘点一下，我们可以用<code>literal</code>解析&lt;&gt;这样的字面量，可以用<code>identifier</code>解析标识符，可以用<code>pair</code>组合任意两个解析器，可以使用<code>oneOrMore</code>或者<code>zeroOrMore</code>多次应用一个解析器，用这些去解析空白符分割的属性对时是否已经够了呢？注意这里是空白符，不单指空格，还包括制表符、换行符、回车符，还有一堆unicode字符也属于空白符。对，我们还缺少一个空白符解析器。</p>
<p>如果我们有“或”组合子，可以用它将一堆空格、制表符、换行符等连起来，但这个法子太笨了。我们是聪明人，我们肯定得用聪明的法子。聪明的办法是一种更通用的方法：抽象出一个谓词组合子，通过传入的谓词判断是否是空白符，在各种语言中，这种函数基本上是现成的。</p>
<pre><code class="language-scala">def pred[A](parser: Parser[A], predicate: A =&gt; Boolean): Parser[A] = &#123;
  (input: String) =&gt; &#123;
    parser.parse(input) match &#123;
      case Success((nextInput, value)) if predicate(value) =&gt; Success((nextInput, value))
      case _ =&gt; Failure(ParseError(input))
    &#125;
  &#125;
&#125;
</code></pre>
<p>逻辑基本上就是上面所说的，只有当<code>parser</code>的结果符合<code>predicate</code>的要求时，才会返回成功，否则一律失败。</p>
<p>为了实现空白符解析器，还需要一个<code>anychar</code>，它的作用是返回任意一个字符，用来驱动解析位置往前走。</p>
<pre><code class="language-scala">def anychar(input: String): ParseResult[Char] = &#123;
  input.toList match &#123;
    case first :: rest =&gt; Success((rest.mkString, first))
    case _ =&gt; Failure(ParseError(input))
  &#125;
&#125;
</code></pre>
<p>有了这两个，空白符就可以表示为符合<code>c =&gt; c.isWhitespace</code>的任意字符。</p>
<pre><code class="language-scala">def whitespace(): Parser[Char] = &#123;
  pred(anychar, c =&gt; c.isWhitespace)
&#125;
</code></pre>
<p>老样子，编写下测试用例，验证下算子的逻辑</p>
<pre><code class="language-scala">test(&quot;predicate combinator&quot;) &#123;
  val parser = pred(anychar, (c: Char) =&gt; c == 'o')
  assertEquals(parser.parse(&quot;omg&quot;), Success((&quot;mg&quot;, 'o')))
&#125;
</code></pre>
<p>有了<code>whitespace</code>，配合<code>oneOrMore</code>和<code>zeroOrMore</code>，就可以表示“一个及以上的空白符”和“零个及以上的空白符”。</p>
<pre><code class="language-scala">def space1(): Parser[Vector[Char]] = &#123;
  oneOrMore(whitespace())
&#125;

def space0(): Parser[Vector[Char]] = &#123;
  zeroOrMore(whitespace())
&#125;
</code></pre>
<h3 id="引用字符串">引用字符串</h3>
<p>属性的值都是双引号包裹的字符串，因此我们还需要编写一个解析引用字符串的解析器，</p>
<pre><code class="language-scala">def quotedString(): Parser[String] = &#123;
  map(
    right(
      matchLiteral(&quot;\&quot;&quot;),
      left(
        zeroOrMore(pred(anyChar, (c: Char) =&gt; c != '&quot;')),
        matchLiteral(&quot;\&quot;&quot;)
      )
    ),
    (chars: Vector[Char]) =&gt; chars.mkString
  )
&#125;
</code></pre>
<p>这里的逻辑是，首先匹配开头的一个双引号，然后中间匹配除双引号之外的任何字符，最后再匹配结尾的一个双引号。使用<code>left</code>和<code>right</code>只将中间的值拿出来。<br>
让我们快速写一个用例，来验证下正确性。</p>
<pre><code class="language-scala">test(&quot;quoted string parser&quot;) &#123;
  assertEquals(quotedString().parse(&quot;\&quot;Hello Joe!\&quot;&quot;), Success(&quot;&quot;, &quot;Hello Joe!&quot;))
&#125;
</code></pre>
<p>不错，一切正常，胜利就在眼前！</p>
<h3 id="属性对解析器">属性对解析器</h3>
<p>现在，关于属性解析已经万事俱备了，我们可以先写一个解析单个属性对的解析器，配合<code>zeroOrMore</code>再写出解析若干属性对的解析器。单个的如下，</p>
<pre><code class="language-scala">def attributePair(): Parser[(String, String)] = &#123;
  pair(identifier, right(literal(&quot;=&quot;), quotedString()))
&#125;
</code></pre>
<p>逻辑直截了当，首先匹配一个标识符，再匹配一个＝，最后匹配属性值，也就是引用字符串。使用<code>zeroOrMore</code>将其组合起来就可以解析多个属性对了，同时不要忘了中间的空白符。</p>
<pre><code class="language-scala">def attributes(): Parser[Vector[(String, String)]] = &#123;
  zeroOrMore(right(space1(), attributePair()))
&#125;
</code></pre>
<p>测试一下</p>
<pre><code class="language-scala">test(&quot;attribute parser&quot;) &#123;
  assertEquals(attributes().parse(&quot; one=\&quot;1\&quot; two=\&quot;2\&quot;&quot;), Success(&quot;&quot;, Vector((&quot;one&quot;, &quot;1&quot;), (&quot;two&quot;, &quot;2&quot;))))
&#125;
</code></pre>
<p>运行，一切正常，和谐完美！</p>
<h3 id="一步之遥">一步之遥</h3>
<p>随着“一块一块积木“的搭建，城堡最终的样子已经越来越清晰了。让我们稍微按捺一下激动的心情，回想一下上文说过的：xml的元素分两种，一种是一开一闭可以包含子元素<code>&lt;div class=&quot;good&quot;&gt;children&lt;/div&gt;</code>，一种是单元素结构<code>&lt;div class=&quot;good&quot;/&gt;</code>，它们有一个共同结构即<code>&lt;div class=&quot;good&quot;</code>部分，因此将这一部分提炼出来可能会大有用处。</p>
<pre><code class="language-scala">def elementStart(): Parser[(String, Vector[(String, String)])] = &#123;
  right(literal(&quot;&lt;&quot;), pair(identifier, attributes()))
&#125;
</code></pre>
<p>首先去匹配<code>&lt;</code>，然后匹配标识符和属性对，然后使用<code>right</code>将标识符和属性对的值拿出来放在<code>Vector[(String, String)]</code>。单元素的解析器如下，相比上面只需在后面匹配下<code>/&gt;</code>就可以了。</p>
<pre><code class="language-scala">def singleElement(): Parser[Element] = &#123;
  map(
    left(elementStart(), matchLiteral(&quot;/&gt;&quot;)),
    &#123; case (name, attributes) =&gt;
      Element(name, attributes, Vector())
    &#125;
  )
&#125;
</code></pre>
<p>类似地，open-element可以这么写，</p>
<pre><code class="language-scala">def openElement(): Parser[Element] = &#123;
  map(
    left(elementStart(), literal(&quot;&gt;&quot;)),
    &#123; case (name, attributes) =&gt; Element(name, attributes, Vector()) &#125;
  )
&#125;
</code></pre>
<p>注意它的返回值是我们一开始定义的<code>Element</code>，通过<code>map</code>算子将结果转成这个类型。 但是close-element咋写呢？这里的难点是开闭元素的名字要对应起来，在使用的时候将开元素的名字传进去。</p>
<pre><code class="language-scala">def closeElement(expected: String): Parser[String] = &#123;
  pred(
    right(
      literal(&quot;&lt;/&quot;),
      left(identifier, literal(&quot;&gt;&quot;))
    ), name =&gt; name == expected
  )
&#125;
</code></pre>
<p>开闭元素这一对可以表示为</p>
<pre><code class="language-scala">def parentElement(): Parser[Element] = &#123;
  pair(
    openElement(),
    left(zeroOrMore(element()), closeElement(**name**))
  )
&#125;
</code></pre>
<p>但是如何把<code>openElement</code>的解析结果传给<code>closeElement</code>呢？这就要引入另一个通用组合子<code>flatMap</code>，为了更好的可读性将其放在<code>Parser</code>中，类似地，把<code>pred</code>、<code>map</code>也加一下，虽然它们只是外面的<code>pred</code>、<code>map</code>的简单映射，但是可以极大的改善代码可读性。</p>
<pre><code class="language-scala">@FunctionalInterface
trait Parser[Output] &#123;
  def parse(input: String): ParseResult[Output]

  def map[NewOutput](fn: Output =&gt; NewOutput): Parser[NewOutput] = &#123;
    ParserCombinator.map(this, fn)
  &#125;

  def pred(predicate: Output =&gt; Boolean): Parser[Output] = &#123;
    ParserCombinator.pred(this, predicate)
  &#125;

  def flatMap[NewOutput](fn: Output =&gt; Parser[NewOutput]): Parser[NewOutput] = &#123;
    (input: String) =&gt; &#123;
      this.parse(input) match &#123;
        case Success((nextInput, result)) =&gt; fn(result).parse(nextInput)
        case err@Failure(_) =&gt; err.asInstanceOf[ParseResult[NewOutput]]
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p><code>parentElement</code>使用新方法的样子</p>
<pre><code class="language-scala">def parentElement(): Parser[Element] = &#123;
  openElement().flatMap(el =&gt;
    left(zeroOrMore(element()), closeElement(el.name))
      .map(children =&gt; el.copy(children = children))
  )
&#125;
</code></pre>
<p><code>openElement</code>将解析结果<code>el</code>返回，然会将<code>el.name</code>传给<code>closeElement</code>，这样只有open和close是一对才会成功。不过回顾xml的结构，我们还需要一个表示“或”的组合子，因为xml有两种元素结构。不过，这对已经身经百炼的你已经是易如反掌了。</p>
<pre><code class="language-scala">def either[A](parser1: Parser[A], parser2: Parser[A]): Parser[A] = &#123;
  (input: String) =&gt; &#123;
    parser1.parse(input) match &#123;
      case ok@Success(_) =&gt; ok
      case _ =&gt; parser2.parse(input)
    &#125;
  &#125;
&#125;
</code></pre>
<p><code>either</code>有两个解析器入参，如果<code>parser1</code>的结果成功，直接返回结果，如果失败，继续尝试<code>parser2</code>，直接将结果返回。这意味着，只要两个解析器只要有一个成功，那整体结果就是成功的。</p>
<h3 id="最后一块积木">最后一块积木</h3>
<p>好吧，终于看到胜利的曙光了。让我们将最后一块积木放上去，然后好好欣赏下我们的作品吧！</p>
<pre><code class="language-scala">def element(): Parser[Element] = &#123;
  either(singleElement(), parentElement())
&#125;
</code></pre>
<pre><code class="language-scala">test(&quot;xml parser&quot;) &#123;
  val doc =
    &quot;&quot;&quot;&lt;top label=&quot;Top&quot;&gt;
      |    &lt;semi-bottom label=&quot;Bottom&quot;/&gt;
      |    &lt;middle&gt;
      |        &lt;bottom label=&quot;Another bottom&quot;/&gt;
      |    &lt;/middle&gt;
      |&lt;/top&gt;
      |&quot;&quot;&quot;.stripMargin

  val parseDoc = Element(
    &quot;top&quot;,
    Vector((&quot;label&quot;, &quot;Top&quot;)),
    Vector(
      Element(&quot;semi-bottom&quot;, Vector((&quot;label&quot;, &quot;Bottom&quot;)), Vector()),
      Element(&quot;middle&quot;, Vector(), Vector(Element(&quot;bottom&quot;, Vector((&quot;label&quot;, &quot;Another bottom&quot;)), Vector())))
    )
  )
  assertEquals(element().parse(doc), Success((&quot;&quot;, parseDoc)))
&#125;
</code></pre>
<p>运行下，竟然报错了，好在报错信息还是比较详细。</p>
<pre><code>values are not the same
=&gt; Diff (- obtained, + expected)
-Failure(
-  exception = ParseError(
-    input = &quot;&quot;&quot;
-    &lt;semi-bottom label=&quot;Bottom&quot;/&gt;
-    &lt;middle&gt;
-        &lt;bottom label=&quot;Another bottom&quot;/&gt;
-    &lt;/middle&gt;
-&lt;/top&gt;
-&quot;&quot;&quot;
+Success(
+  value = Tuple2(
+    _1 = &quot;&quot;,
+    _2 = Element(
+      name = &quot;top&quot;,
+      attributes = Vector(
+        Tuple2(
+          _1 = &quot;label&quot;,
+          _2 = &quot;Top&quot;
+        )
+      ),
+      children = Vector(
+        Element(
+          name = &quot;semi-bottom&quot;,
+          attributes = Vector(
+            Tuple2(
+              _1 = &quot;label&quot;,
+              _2 = &quot;Bottom&quot;
+            )
+          ),
+          children = Nil
+        ),
+        Element(
+          name = &quot;middle&quot;,
+          attributes = Nil,
+          children = Vector(
+            Element(
+              name = &quot;bottom&quot;,
+              attributes = Vector(
+                Tuple2(
+                  _1 = &quot;label&quot;,
+                  _2 = &quot;Another bottom&quot;
+                )
+              ),
+              children = Nil
+            )
+          )
+        )
+      )
+    )
   )
</code></pre>
<p>仔细看下报错，可以看到解析器好像解析完<code>&lt;top label=&quot;Top&quot;&gt;</code>就停止了，这是咋回事呢？观察要解析的xml，在标签之间有许多换行和空格，而<code>element</code>并没有处理这一情况。</p>
<pre><code class="language-xml">&lt;top label=&quot;Top&quot;&gt;
    &lt;semi-bottom label=&quot;Bottom&quot;/&gt;
    &lt;middle&gt;
        &lt;bottom label=&quot;Another bottom&quot;/&gt;
    &lt;/middle&gt;
&lt;/top&gt;
</code></pre>
<p>我们需要引入另一个组合子<code>wrap</code>，它会忽略周围的空白符。</p>
<pre><code class="language-scala">def wrap[A](parser: Parser[A]): Parser[A] = &#123;
  right(space0(), left(parser, space0()))
&#125;
</code></pre>
<p>这应该就是xml解析器的完全体了。</p>
<pre><code class="language-scala">def element(): Parser[Element] = &#123;
  wrap(either(singleElement(), parentElement()))
&#125;
</code></pre>
<p>重新运行下测试用例，通过，完美！真是好事多磨啊！</p>
<p>让我们简单的总结下，最开始通过<code>theLetterA</code>第一次认识了解析器，由此隐身出来解析字符串的<code>literal</code>，接下来又结识了解析标识符的<code>identifier</code>，然后通过<code>pair</code>将二者结合起来完成了对xml标识符的解析，接下来又引入了<code>map</code>、<code>oneOrMore</code>、<code>zeroOrMore</code>、<code>pred</code>等完成了对属性的解析，最后引入<code>either</code>处理单元素结构和包含子元素的开闭结构，整个过程是不是特别像搭积木？</p>
<h3 id="下一步工作">下一步工作</h3>
<p>如果想在实际项目中使用，我们这个toy解析器还是太naive了。如果大家想更深入的了解Parser Combinator，Scala可以看下<a target="_blank" rel="noopener" href="https://github.com/com-lihaoyi/fastparse">fastparse</a>, Rust可以看下<a target="_blank" rel="noopener" href="https://github.com/rust-bakery/nom">nom</a>。</p>
<h2 id="Common-Pattern">Common Pattern</h2>
<p>也许在一开始，你可能会疑问为啥要实现这些算子而不是那些算子，因为在上面的旅程中，你可能已经体会到到达终点的路不是一条，那为什么独独选这一条呢？很好的问题，事实上，上面的好多算子彼此有不少联系，一些更专有的算子可以用另一些更基础的算子重写，通过不停的分解，归并，你就会发现一些公共模式(Common Pattern)。</p>
<p>比如<code>pair</code>可以重写为，</p>
<pre><code class="language-scala">def identifier(input: String): ParseResult[String] = &#123;
pair(
  (anychar _).pred(c =&gt; c.isLetter),
  zeroOrMore((anychar _).pred(c =&gt; c.isLetterOrDigit || c == '-'))
).parse(input) match &#123;
  case Success((rest, (first, second))) =&gt;
    Success((rest, first + second.mkString))
  case Failure(exception) =&gt; Failure(ParseError(input))
&#125;
</code></pre>
<p><code>oneOrMore</code>可以重写为，</p>
<pre><code class="language-scala">def oneOrMore[A](parser: Parser[A]): Parser[Vector[A]] = &#123;
  pair(parser, zeroOrMore(parser)).map(
    &#123; case (head: A, tail: Vector[A]) =&gt; head +: tail &#125;
  )
&#125;
</code></pre>
<p>可以发现大部分的算子都用到了<code>map</code>、<code>flatMap</code>、<code>pair</code>、<code>pred</code>，<code>pair</code>有时候也叫<code>combine</code>，<code>pred</code>有时候叫<code>filter</code>，你可能已经在各种编程语言中找到这些算子的影子。有了这些基础算子，你就可以按照自己的喜好构筑自己的应用算子，这就是基础的重要性，或许这就是老子所说的“一生二，二生三，三生万物”吧。</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/naosense/e398b49dfa2e4bb964de97b8a63a670b">完整代码</a></p>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Parser-Combinator/" rel="tag">Parser Combinator</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li></ul>
    

    <a href="#top" class="top">返回顶部</a>
  </div>
</article>
<footer>
    &copy; 2023
    <span class="author">
        naosense
    </span>

     
        <span class="motto">
            世上无难事，只要肯登攀
        </span>
     
     
        <div id="disqus_thread">
        <script>
        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        var disqus_config = function () {
        this.page.url = 'https://naosense.github.io/2023/01/01/%E4%BB%8E%E4%B9%90%E9%AB%98%E7%8E%A9%E5%85%B7%E5%88%B0Parser%20Combinator/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '2023/01/01/从乐高玩具到Parser Combinator/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        this.page.title = '从乐高玩具到Parser Combinator';
        };

        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://pingao777.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
     
    </div>
</footer>


    </div>
  </body>
</html>