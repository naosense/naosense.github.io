---
title: 'HotSpot虚拟机垃圾收集优化指南 '
date: 2019-05-03 18:39:07
categories: 技术人生
tags: [垃圾收集, 虚拟机, Java]
---
现在是个人都要谈谈虚拟机了，不懂点虚拟机都不好意思说是Java程序员，看到Oracle官网上有一篇将虚拟机调优的文章不错，翻译一下。

## 1 垃圾收集优化介绍

从桌面上的小应用程序到大型服务器上的网络服务，各种各样的应用程序都使用标准版的Java平台。为了支持这种多样化的部署，Java HotSpot虚拟机提供了多个垃圾收集器，每个都是为了满足不同的需求而设计的。Java SE根据运行应用程序的计算机的类别选择最合适的垃圾收集器。然而，这种选择并不是对每个应用都是最佳的。具有严格性能目标或其他要求的用户、开发人员和管理员可能需要显式选择垃圾收集器，并调整某些参数以达到所需的性能水平。本文档提供了帮助完成这些任务的信息。

首先，垃圾收集器的一般特性和基本的调优选项是在串行的stop-the-world收集器的上下文中描述的。然后介绍其他收集器的具体特征以及选择收集器时要考虑的因素。

本节主题：
- 什么是垃圾收集器？
- 垃圾收集器的选择为什么重要？
- 文档中支持的操作系统

### 什么是垃圾收集器？

垃圾收集器自动管理应用程序的动态存储分配请求。

垃圾收集器通过以下操作执行自动动态内存管理:
- 从操作系统分配内存并将内存交还给操作系统。
- 根据应用程序的请求，将内存分配给它。
- 确定哪些内存还在使用。
- 回收未使用的内存供应用程序重用。

Java HotSpot垃圾收集器采用各种技术来提高这些操作的效率:
- 将年代清理与老化结合使用，将精力集中在堆中最有可能包含大量可回收内存区域的区域。
- 使用多线程使操作并行，或者在应用程序的后台并行执行一些长期运行的操作。
- 通过压缩活动对象，尝试恢复更大的连续可用内存。

### 垃圾收集器的选择为什么重要？

垃圾收集器的目的是将应用程序开发人员从手动动态内存管理中解放出来。开发人员无需关心内存的分配与回收，也不用密切关注分配的动态内存的生存期。这完全消除了一些与内存管理相关的错误，代价是增加了一些运行时开销。Java HotSpot虚拟机提供了一系列垃圾收集算法可供选择。

垃圾收集器的选择什么时候重要？对于某些应用，答案是永远不会。也就是说，应用程序在垃圾收集的情况下性能良好，暂停的频率和持续时间适中。然而，对于一大类应用程序，尤其是那些具有大量数据(几十亿字节)、许多线程和高事务率的应用程序，情况并非如此。

Amdahl定律(给定问题中的并行加速受问题串行部分的限制)意味着大多数工作负载不能完全并行化；有些部分总是串行的，并没有从并行中获益。在Java平台中，目前有四种支持的垃圾收集替代方案，除了其中一种serial GC，其他的都能并行化以提高性能。尽可能降低垃圾收集的开销是非常重要的。这可以在下面的例子中看到。

图1-1中的图表模拟了一个理想的系统，除了垃圾收集之外，它是完全可伸缩的。红线是在单处理器系统上只花费1%时间进行垃圾收集的应用程序。这意味着在拥有32个处理器的系统上，吞吐量损失超过20%。洋红色线显示，对于垃圾收集时间为10%的应用程序(在单处理器应用程序中，垃圾收集时间不算太长)，当扩展到32个处理器时，会损失75%以上的吞吐量。

![图1-1 垃圾收集所用时间的百分比对比](https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

该图显示，在小型系统上开发时，可以忽略的吞吐量问题可能会成为扩展到大型系统时的主要瓶颈。然而，在减少这种瓶颈方面的微小改进可以带来巨大的性能提升。对于一个足够大的系统，选择合适的垃圾收集器并在必要时对其进行调整变得很有价值。

serial收集器对于大多数小型应用已经足够了，尤其是那些在现代处理器上需要高达约100兆字节的堆的应用。其他收集器有额外的开销或复杂性，这是高级特性的代价。如果应用程序不需要备用收集器的高级特性，适用serial收集器就可以了。serial收集器不是最佳选择的一种情况是运行在具有大量内存和两个或更多处理器的机器上的大型多线程应用程序。当应用程序在这样的服务器级计算机上运行时，默认情况下会选择垃圾优先(G1)收集器；参见[工效学](https://docs.oracle.com/en/java/javase/12/gctuning/ergonomics.html#GUID-DB4CAE94-2041-4A16-90EC-6AE3D91EC1F1)。

### 文档中支持的操作系统

本文档及其建议适用于所有JDK 12支持的系统配置，受某些垃圾收集器特定配置实际可用性的限制。请参阅[甲骨文JDK认证系统配置](http://www.oracle.com/pls/topic/lookup?ctx=javase12&id=latest_certified_system_configurations)。

## 2 工效学

工效学是Java虚拟机(JVM)启发式垃圾收集(如基于行为的试探法)提高应用程序性能的过程。

JVM为垃圾收集器、堆大小和运行时编译器提供依赖于平台的默认选择。这些选择符合不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的动态优化堆的大小，以满足应用程序的指定行为。

本节描述这些默认选择和基于行为的调整。在使用后续章节中描述的更详细控件之前，使用这些默认值。

本节主题：
- 垃圾收集器、堆和运行时编译器默认选择
- 基于行为的优化
    - 最大暂停时间
    - 吞吐量
    - Footprint
- 调优策略

### 垃圾收集器、堆和运行时编译器默认选择

这些是重要的垃圾收集器、堆大小和运行时编译器默认选择:
- 垃圾优先(G1)收集器
- 垃圾收集线程的最大数量受堆大小和可用CPU资源的限制
- 堆的初始容量为1/64物理内存
- 堆的最大容量为1/4物理内存
- 分层编译器，使用C1和C2

### 基于行为的优化

Java HotSpot虚拟机垃圾收集器可以配置为优先满足两个目标之一:最大暂停时间和应用程序吞吐量。如果达到了首选目标，收集者将尝试最大化另一个目标。当然，这些目标并不总是能够实现的:应用程序需要最小的堆来保存至少所有的实时数据，而其他配置可能会阻止实现一些或所有的期望目标。

#### 最大暂停时间

暂停时间是指垃圾收集器停止应用程序并恢复不再使用的空间的持续时间。最大暂停时间目的是限制这些暂停的最长时间。

垃圾收集器维护暂停的平均时间和平均值的方差。平均值是从执行开始时取的，但是它是加权的，所以最近的暂停计数更大。如果暂停时间的平均值加上方差大于最大暂停时间目标，则垃圾收集器认为目标没有实现。

最大暂停时间目标是用命令行选项`-XX:MaxGCPauseMillis=<nnn>`指定的。这被解释为向垃圾收集器提示需要`< nnn >`毫秒或更少的暂停时间。垃圾收集器会调整Java堆大小和其他与垃圾收集相关的参数，以使垃圾收集暂停时间短于`< nnn >`毫秒。最大暂停时间目标的默认值因收集器而异。这些调整可能会导致垃圾收集更加频繁，从而降低应用程序的整体吞吐量。然而，在某些情况下，期望的暂停时间目标无法实现。

#### 吞吐量

吞吐量目标是以收集垃圾花费的时间来衡量的，垃圾收集之外花费的时间就是应用时间。

吞吐量通过命令选项`-XX:GCTimeRatio=nnn`指定。垃圾收集时间与应用时间之比为1/ (1+nnn)。例如，`-XX:GCTimeRatio=19`设置了垃圾收集时间占总时间的1/20或5%。

垃圾收集花费的时间是所有垃圾收集导致的暂停的总时间。如果没有达到吞吐量目标，那么垃圾收集器的一个可能的操作是增加堆的大小，以便在垃圾收集之间的应用程序中花费的时间可以更长。

#### Footprint

如果吞吐量和最大暂停时间目标已经达到，那么垃圾收集器会减小堆的大小，直到其中一个目标(总是吞吐量目标)无法达到为止。垃圾收集器可以使用的最小和最大堆大小可以分别使用`-Xms=<nnn >`和`-Xmx=<mmm >`设置为最小和最大堆大小。

### 调优策略

堆增长或收缩到以支持所选吞吐量。了解堆优化策略，如选择最大堆大小和选择最大暂停时间目标。

除非您确定需要大于默认最大堆大小的堆，否则不要为堆选择最大值。为您的应用选择一个足够的吞吐量目标。

应用程序行为的改变会导致堆增长或收缩。例如，如果应用程序开始以更高的速率分配，那么堆就会增长以保持相同的吞吐量。

如果堆增长到其最大大小，并且没有达到吞吐量目标，则最大堆大小对于吞吐量目标来说太小。将最大堆大小设置为接近平台上总物理内存的值，但不会导致应用程序交换。再次执行应用程序。如果仍然没有达到吞吐量目标，那么应用程序时间的目标对于平台上的可用内存来说太高了。

如果可以达到吞吐量目标，但暂停时间过长，则选择(更小的，译者加)最大暂停时间目标。选择最大暂停时间目标可能意味着您的吞吐量目标无法实现，因此请选择对应用程序来说可以接受的折衷值。

垃圾收集器试图满足竞争目标时，堆的大小通常会发生波动。即使应用程序已经达到稳定状态，也是如此。实现吞吐量目标(可能需要更大的堆)的压力与最大暂停时间和最小占用空间(两者都可能需要更小的堆)的目标相竞争。

## 3 垃圾收集器实现

Java SE平台的一个优势是它保护开发人员免受内存分配和垃圾收集的复杂性的困扰。

然而，当垃圾收集成为主要瓶颈时，理解实现的某些方面是有用的。垃圾收集器对应用程序使用对象的方式进行假设，这些假设反映在可调参数中，这些参数可以在不牺牲抽象能力的情况下进行调整以提高性能。

本节主题：
- 分代垃圾收集
- 分代
- 性能考虑
- 吞吐量和Footprint考量

### 分代垃圾收集

一个对象被认为是垃圾，当运行程序中的任何其他活动对象的任何引用不能再访问它时，虚拟机可以重用它的内存。

理论上，最简单的垃圾收集算法每次运行时都会遍历每个可到达的对象。任何剩余的对象都被认为是垃圾。这种方法花费的时间与活动对象的数量成正比，这对维护大量活动数据的大型应用程序来说是禁止的。

Java HotSpot虚拟机包含许多不同的垃圾收集算法，这些算法都使用一种称为分代收集的技术。虽然简单的垃圾收集每次都会检查堆中的每个活动对象，但是分代收集利用了大多数应用程序的观察到的几个经验特性来最小化回收未使用(垃圾)对象所需的工作。这些观察到的特性中最重要的是*弱分代假说(weak generational hypothesis)*，它指出大多数对象只能存活很短的一段时间。

图3-1中的蓝色区域是对象寿命的典型分布。x轴显示的是对象生命周期。y轴显示的是存活的字节数。左边的尖峰代表分配后不久可以回收的对象(换句话说，已经“死亡”)。例如，迭代器对象通常只在单个循环期间有效。

![图3-1对象生命周期的典型分布](https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)

有些对象确实寿命更长，所以分布向右侧延伸。例如，通常有一些在初始化时分配的对象会一直存在，直到虚拟机退出。在这两个极端之间是在某个中间计算期间存在的对象，在这里被视为初始峰值右侧的块。一些应用程序具有非常不同的外观分布，但令人惊讶的是，大量应用程序具有这种一般性的形状。通过关注大多数对象“朝生夕死”的事实，有效的收集成为可能。

### 分代

为了针对这种情况进行优化，内存分几代进行管理(内存池保存不同年龄的对象)。垃圾收集发生在每一代填满时。

绝大多数对象被分配到一个专门用于年轻对象(新生代，young generation)的池中，大多数对象死在那里。当新生代填满时，它会导致一个*minor collection*，其中只收集新生代；其他分代的垃圾不会被回收。这种收集的成本首先与被收集的存活对象的数量成比例；充满死亡对象的新生代收集的很快。

通常，在每一次小规模的收集(minor collection)过程中，新生代幸存下来的一些对象会被转移到老年代(old generation)。最后，老年代会填满并且必须被收集，从而产生一个*major collection*，其中收集了整个堆。major collection的持续时间通常比minor collection长得多，因为涉及的对象数量要大得多。图3-2显示了串行垃圾收集器(serial garbage collector)中的默认分代排列:

![图3-2串行垃圾收集器(serial garbage collector)中的默认分代排列](https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_001_armgnt_gn_new.png)

启动时，Java HotSpot虚拟机将整个Java堆保留在地址空间中，但除非需要，否则不会为其分配任何物理内存。覆盖Java堆的整个地址空间在逻辑上分为新生代和老年代。为对象内存保留的完整地址空间可以分为新生代和老年代。

年轻一代由eden和两个survivor空间组成。大多数对象最初是在eden中分配的。在任何时候都有一个survivor空间是空的，并且在垃圾收集期间充当eden和另一个survivor空间中存活对象的目标空间；垃圾收集后，eden和源survivor空间是空的。在下一次垃圾收集中，两个survivor空间的角色交换。最近填充的一个survivor空间是复制到另一个survivor空间的存活对象的来源。对象以这种方式在两个survivor空间之间复制，直到它们被复制了一定次数或者没有足够的空间。这些对象被复制到年老区。这个过程也被称为*老化(aging)*。

### 性能考虑

垃圾收集的主要指标是吞吐量和延迟。
- 吞吐量是指未花费在垃圾收集上的总时间的百分比(即应用程序所占用的时间，译者注)。吞吐量包括分配所花费的时间(但通常不需要调整分配速度)。
- 延迟是应用程序的响应能力。垃圾收集会暂停应用程序进而会影响应用程序的响应能力。

用户对垃圾收集有不同的要求。例如，有些人认为网络服务器的正确度量是吞吐量，因为垃圾收集期间的暂停可能是可以容忍的，或者会因为网络延迟而变得模糊不清。然而，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。

一些用户对其他考虑很敏感。占用空间是一个进程的工作集，以页面和缓存行来衡量。在物理内存有限或进程众多的系统上，占用空间可能决定可伸缩性。*及时性(Promptness)*是指对象死亡和内存可用之间的时间，对于包括远程方法调用(Remote Method Invocation, RMI)在内的分布式系统来说，这是一个重要的考虑因素。

一般来说，为特定一代选择容量就是这些考虑因素之间作权衡。例如，非常大的新生代可能最大化吞吐量，但这样做是以占用空间、及时性和暂停时间为代价的。相反，可以通过减小新生代的空间来换取小的垃圾收集暂停时间，但这会牺牲吞吐量。一代的空间不会影响另一代的收集频率和暂停时间。

没有一种通用的方法可以选择一代的最优空间大小。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并不总是最佳的，可以通过命令行选项修改；请参见[影响垃圾收集性能的因素](https://docs.oracle.com/en/java/javase/12/gctuning/factors-affecting-garbage-collection-performance.html#GUID-5508674B-F32D-4B02-9002-D0D8C7CDDC75)。

### 吞吐量和占用量考量

吞吐量和占用量最好使用特定于应用的指标来衡量。

例如，可以使用客户端负载生成器测试网络服务器的吞吐量，而可以使用`pmap`命令在Solaris操作系统上测量服务器的占用空间。但是，通过检查虚拟机本身的诊断输出，可以轻松估计垃圾收集导致的暂停。

命令行选项`-verbose:gc`在每次收集中打印关于堆和垃圾收集的信息。下面是一个例子:
```
[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M->57M(307M) (15,646s, 15,651s) 5,048ms
[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M->57M(307M) (16,146s, 16,162s) 16,565ms
[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M->31M(104M) (16,202s, 16,367s) 164,581ms
```
输出显示了两次新生代的垃圾收集，之后是由应用程序通过调用`System.gc()`启动的完整收集。这些行以时间戳开始，该时间戳指示应用程序启动的时间。接下来是关于该行的日志级别(信息)和标签(gc)的信息。随后是垃圾收集识别号。在这种情况下，有三个编号为36、37和38的垃圾收集。然后记录垃圾收集类型和原因。之后，会记录一些关于内存消耗的信息。该日志使用“在垃圾收集之前使用”->“在垃圾收集之后使用”(“堆大小”)的格式。

在示例的第一行中，是239兆-> 57M(307兆)，这意味着在垃圾收集清除大部分内存之前使用了239兆字节，但是收集之后保留了57兆字节。堆大小为307兆字节。请注意，在此示例中，完整的垃圾收集将堆从307兆字节缩减到104兆字节。在内存使用信息之后，将记录垃圾回收的开始和结束时间以及持续时间(结束-开始)。

`-verbose:gc`命令是`-Xlog:gc`的别名。`-Xlog`是用于HotSpot JVM的通用日志配置选项。这是一个基于标签的系统，其中gc是标签之一。要获得更多关于垃圾收集正在做什么的信息，您可以配置日志来打印任何带有垃圾收集标签和任何其他标签的消息。该命令的命令行选项是`-Xlog:gc*`。

下面是一个用`-Xlog:gc*`配置的G1收集器新生代垃圾收集的例子:
```
[10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause)
[10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation
[10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms
[10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms
[10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms
[10.191s][info][gc,phases ] GC(36) Other: 0.2ms
[10.191s][info][gc,heap ] GC(36) Eden regions: 286->0(276)
[10.191s][info][gc,heap ] GC(36) Survivor regions: 15->26(38)
[10.191s][info][gc,heap ] GC(36) Old regions: 88->88
[10.191s][info][gc,heap ] GC(36) Humongous regions: 3->1
[10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K->8152K(1056768K)
[10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M->114M(508M) 13.075ms
[10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s
```
> 注意：由-Xlog:gc*生成的输出格式可能会在未来版本中发生变化。

## 4 影响垃圾收集性能的因素

影响垃圾收集性能的两个最重要的因素是总的可用内存和新生代的比例。

本节内容：
- 总的可用内存
    - 影响分代大小的选项
    - 堆的默认大小
    - 通过最小化Java堆大小来节省动态占用空间
- 新生代
    - 新生代大小选项
    - survivor空间大小

### 总的可用内存

影响垃圾收集性能的最重要因素是总可用内存。因为收集发生在分代空间占满时，吞吐量与可用内存量成反比。

> 注意：以下关于堆的增长和收缩、堆布局和默认值的讨论以串行收集器(serial collector)为例。虽然其他收集器使用类似的机制，但这里提供的细节可能不适用于其他收集器。有关其他收集器的类似信息，请参考各自的主题。

#### 影响分代大小的选项

许多选项会影响分代大小。图4-1展示了堆中提交空间和虚拟空间之间的区别。虚拟机初始化时，堆的整个空间都会被保留。保留空间的大小可以用`-Xmx`选项指定。如果`-Xms`参数的值小于`-Xmx`参数的值，则不是所有保留的空间都会立即提交给虚拟机。在此图中，未提交的空间标记为“虚拟”。堆的不同部分，即新生代和老年代，可以根据需要增长到虚拟空间的极限。

一些参数可以设置堆的一部分与另一部分的比率。例如，参数`–XX:NewRatio`表示老年代与新生代的相对大小。

![堆空间](https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_006_prm_gn_sz_new.png)

#### 堆的默认大小

默认情况下，虚拟机会在每次垃圾收集时增大或缩小堆，以尝试将每次收集中存活对象的可用空间比例保持在特定范围内。

该目标范围由选项`-XX:MinHeapFreeRatio= <最小值>`和`-XX:MaxHeapFreeRatio= <最大值>`设置为百分比，总大小以`–Xms <最小值>`为界，以`–Xmx <最大值>`为界。64位Solaris操作系统(SPARC平台版)的默认选项如表4-1所示。

| 选项                 | 默认值   |
| :---:                | :---:    |
| -XX:MinHeapFreeRatio | 40       |
| -XX:MaxHeapFreeRatio | 70       |
| -Xms                 | 6656 KB  |
| -Xmx                 | 计算得到 |

有了这些选项，如果一代中的可用空间百分比低于40%，则会扩展到保持40%的可用空间，直到这一代的最大允许大小。类似地，如果空闲空间超过70%，那么这一代空间将收缩，使得只有70%的空间是空闲的，这取决于这一代空间的最小尺寸。

如表4-1所示，默认的最大堆大小是由JVM计算的值。Java SE中用于并行收集器(Parallel collector)的计算现在被用于所有垃圾收集器。计算的一部分是64位平台的最大堆大小上限。请参见大小[并行收集器默认堆](https://docs.oracle.com/en/java/javase/12/gctuning/parallel-collector1.html#GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4)。客户端模式的JVM也有类似的计算，只不过最大堆大小小于服务器模式的JVM。

以下是关于服务器应用程序堆大小的一般准则:
- 除非暂停有问题，否则请尝试向虚拟机授予尽可能多的内存。默认大小通常太小。
- 将`-Xms`和`-Xmx`设置为相同的值可以通过从虚拟机中删除最重要的规模调整决策来提高可预测性。但是，如果您做出错误的选择，虚拟机将无法进行补偿。
- 通常，增加处理器数量同时也要增加内存，因为内存分配可以并行进行。

#### 通过最小化Java堆大小来节省动态占用空间

如果您需要最小化应用程序的动态内存占用(执行期间消耗的最大内存)，那么您可以通过最小化Java堆大小来实现这一点。Java SE嵌入式应用程序可能需要这一点。

通过降低命令行选项`-XX:MinHeapFreeRatio`(默认值为40%)和`-XX:MaxHeapFreeRatio`(默认值为70%)的值，从而最小化Java堆大小。将`-XX:MaxHeapFreeRatio`降低到低至10%，`-XX:MinHeapFreeRatio`已证明能够成功地减小堆大小，而且不会造成太大的性能降级；但是，最终的结果可能取决于你的应用。

此外，您可以指定`-XX:-shrinkHeapInTeps`，它会立即将Java堆减小到目标大小(由参数`-XX:MaxHeapFreeRatio`指定)。此设置可能会导致性能下降。默认情况下，Java运行时会逐渐将Java堆减小到目标大小；这个过程需要多个垃圾收集周期。

### 新生代

在总可用内存之后，影响垃圾收集性能的第二个最大影响因素是专用于新生代的堆的比例。

新生代越大，minor collection就越少。然而，对于有限的堆大小，较大的新生代意味着较小的老年代，这将增加major collection的频率。最佳选择取决于应用程序分配的对象的生命周期分布。

#### 新生代大小选项

默认情况下，新生代的大小由选项`-XX:NewRatio`控制。

例如，设置`-XX:NewRatio=3`意味着新生代和老年代之间的比率是1:3。换句话说，eden和survivor空间总的大小将是总堆大小的四分之一。

选项`-XX:NewSize`和`-XX:MaxNewSize`指定了新生代的大小下界和上界。将它们设置为相同的值新生代就是固定值，正如将`-Xms`和`-Xmx`设置为相同的值可以固定总堆大小一样。这有助于以比`-XX:NewRatio`允许的整数倍更精细的粒度调整新生代。

#### survivor空间大小

您可以使用选项`-XX:SurvivorRatio`来调整survivor空间的大小，但这通常对性能并不重要。

例如，`-XX:SurvivorRatio=6`将eden和survivor空间之间的比率设置为1:6。换句话说，每个survivor空间将是eden大小的六分之一，也就是年轻一代大小的八分之一(不是七分之一，因为有两个幸存者空间)。

如果survivor空间太小，那么将会直接复制到老年代。如果幸存者空间太大，那么将会有很多空间永远不会使用。在每次垃圾收集时，虚拟机都会选择一个阈值数，即一个对象在其转移到老年代之前可以复制的次数。选择这个阈值是为了让幸存者保持半饱和状态。您可以使用日志配置`-Xlog:gc`，年龄可以用来显示这个阈值和新一代对象的年龄。它对于观察应用程序的生命周期分布也很有用。

表4-2提供了64位Solaris的默认值。

| 选项              | 默认值      |
| :---:             | :---:       |
| -XX:NewRatio      | 2           |
| -XX:NewSize       | 1310 MB     |
| -XX:MaxNewSize    | not limited |
| -XX:SurvivorRatio | 8           |

新生代的最大大小是根据总堆的最大大小和`-XX:NewRatio`参数的值计算的。`-XX:MaxNewSize`参数的“无限制”默认值意味着计算值不受`-XX:MaxNewSize`的限制，除非命令行上指定了`-XX:MaxNewSize`的值。

以下是服务器应用程序的一般指南:
- 首先决定您可以为虚拟机提供的最大堆大小。然后，根据新生代的规模绘制您的性能指标，以找到最佳设置。
    - 请注意，最大堆大小应始终小于机器上安装的内存量，以避免过多的页面错误和抖动。
- 如果总堆大小是固定的，那么增加新生代的大小需要减少老年代的大小。保持老一代足够大，以容纳应用程序在任何给定时间使用的所有实时数据，加上一定量的空闲空间(10%到20%或更多)。
- 根据前面提到的对老年代的限制:
    - 给予新生代足够的内存。
    - 增加处理器数量的同时增加新生代的规模，因为分配可以并行化。

## 5 可用收集器

本节主题：
- 串行收集器(Serial Collector)
- 并行收集器(Parallel Collector)
- 主要并发收集器(The Mostly Concurrent Collectors)
- 选择收集器

### 串行收集器(Serial Collector)

串行收集器使用单个线程来执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。

它最适合单处理器机器，尽管它对于具有小数据集(高达大约100兆字节)的应用程序在多处理器上很有用，但它不能利用多处理器硬件的优势。默认情况下，串行收集器是在某些硬件和操作系统配置上的默认选择，或者通过选项`-XX:+UseSerialGC`显式启用。

### 并行收集器(Parallel Collector)

并行收集器也称为*吞吐量收集器*，它是与串行收集器相似的一代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个线程用于加快垃圾收集。

并行收集器适用于在多处理器或多线程硬件上运行的具有大中型数据集的应用程序。您可以通过使用`-XX:+UseParallelGC`选项来启用它。

并行压缩是一项使并行收集器能够并行执行major collection的功能。如果没有并行压缩，major collection是使用单个线程来执行的，这可能会极大地限制可伸缩性。如果指定了选项`-XX:+UseParallelGC`，则默认情况下启用并行压缩。您可以通过使用`-XX:-UseParallelOldGC`选项来禁用它。

### 主要并发收集器(The Mostly Concurrent Collectors)

并发标记清除(CMS)收集器和垃圾优先(G1)垃圾收集器是两个主要并发的收集器。大多数并发收集器对应用程序并发执行一些昂贵的工作。

- G1垃圾收集器:这种服务器风格的收集器是为具有大量内存的多处理器机器设计的。为了满足垃圾收集暂停时间的目标，同时实现高吞吐量。 默认情况下，在某些硬件和操作系统配置上选择G1，或者可以使用`-XX:+UseG1GC`显式启用。
- CMS收集器:这个收集器是为那些更喜欢较短垃圾收集暂停时间的应用程序设计的，并且能够与垃圾收集共享处理器资源。使用`-XX:+UseConcMarkSweepGC`启用CMS收集器。

CMS收集器在JDK 9中被标记为弃用。

### Z收集器

Z垃圾收集器(ZGC)是一个可扩展的低延迟垃圾收集器。ZGC同时执行所有代价高昂的工作，同时不停止应用程序线程的执行。

ZGC适用于需要低延迟(暂停时间不到10 ms)和/或使用非常大堆(几T字节)的应用。您可以通过使用`-XX:+UseZGC`选项来启用。

从JDK 11开始，ZGC作为一个实验性的出现。

### 选择收集器

除非您的应用程序有相当严格的暂停时间要求，否则首先运行您的应用程序，并允许虚拟机选择收集器。

如有必要，调整堆大小以提高性能。如果性能仍然达不到您的目标，请使用以下准则作为选择收集器的出发点:
- 如果应用程序有一个小数据集(高达大约100兆字节)，则使用选项`-XX:+UseSerialGC`选择串行收集器。
- 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有选项`-XX:+UseSerialGC`的串行采集器。
- 如果(a)应用程序性能峰值是第一优先事项，并且(b)没有暂停时间要求，或者一秒钟或更长的暂停时间是可接受的，则让虚拟机选择收集器或使用`-XX:+UseParallelGC`选择并行收集器。
- 如果响应时间比总吞吐量更重要，并且垃圾收集暂停时间必须保持在大约一秒钟以内，则选择一个具有`-XX:+UseG1GC`或`-XX:+UseConcMarkSweepGC`的主要并发收集器。
- 如果响应时间是一个高优先级，和/或您正在使用一个非常大的堆，那么选择一个具有`-XX:UseZGC`的完全并发收集器。

这些准则只是选择收集器的出发点，因为性能取决于堆的大小、应用程序维护的实时数据量以及可用处理器的数量和速度。

如果推荐的收集器没有达到期望的性能，那么首先尝试调整堆和各个分代的大小以满足期望的目标。如果性能仍然不足，请尝试不同的收集器:使用并发收集器减少暂停时间，使用并行收集器增加多处理器硬件上的总吞吐量。

## 6 并行收集器(The Parallel Collector)

并行收集器(这里也称为吞吐量收集器)是一个类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个线程用于加快垃圾收集。

并行收集器通过命令行选项`-XX:+UseParallelGC`启用。默认情况下，使用此选项，minor collection和major collection并行运行，以进一步减少垃圾收集开销。

本节主题：
- 并行收集器垃圾收集器线程的数量
- 并行收集器中的分代排列
- 并行收集器人机工程学
    - 指定并行收集器行为的选项
    - 并行收集器指标的优先级
    - 并行收集器各个分代空间调整
    - 并行收集器默认堆大小
        - 并行收集器初始和最大堆大小的规范
- 过多的并行收集器时间和内存不足错误
- 并行收集器度量

### 并行收集器垃圾收集器线程的数量

在硬件线程数N大于8的机器上，并行收集器使用固定比例的硬件线程数作为垃圾收集器线程数。

对于较大的N值，比例为5/8。当小于8时，使用的线程等于N。在特定的平台上，这一比例降至5/16。垃圾收集器线程的具体数量可以通过命令行选项进行调整(这将在后面描述)。在只有一个处理器的主机上，由于并行执行(例如同步)所需的开销，并行收集器的性能可能不如串行收集器。但是，当运行具有中型到大型堆的应用程序时，在具有两个处理器的计算机上，它通常比串行收集器性能略好，并且当有两个以上的处理器可用时，它通常比串行收集器性能好得多。

垃圾收集器线程的数量可以通过命令行选项`-XX:ParallelGCThreads=<N>`来控制。如果使用命令行选项调整堆，那么并行收集器获得良好性能所需的堆大小与串行收集器所需的大小相同。但是，启用并行收集器应该会缩短收集暂停时间。因为多个垃圾收集器线程同时参与一个minor collection，所以在收集过程中，从新生代到老年代的升级可能会导致一些碎片。minor collection中涉及的每个垃圾收集线程都会保留老年代的一部分用于升级，将可用空间划分到这些“升级缓冲区”会导致碎片效应。减少垃圾收集器线程的数量和增加老年代的大小将减少这种碎片效应。

### 并行收集器中的分代排列

在并行收集器中，分代的排列是不同的。

这种布置如图6-1所示:

![并行收集器中的分代排列](https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_002_armgnt_gn_pl_new.png)

### 并行收集器人机工程学

当使用`-XX:+UseParallelGC`选择并行收集器时，它启用了一种自动优化方法，允许您指定行为，而不是分代大小和其他低级优化细节。

#### 指定并行收集器行为的选项

您可以指定最大垃圾收集暂停时间、吞吐量和占用空间(堆大小)。
- 最大垃圾收集暂停时间:最大暂停时间是用命令行选项`-XX:MaxGCPauseMillis=<N>`指定的。这被解释为需要N毫秒或更少的暂停时间；默认情况下，没有最大暂停时间。如果指定了暂停时间，将调整堆大小和其他与垃圾收集相关的参数，以使垃圾收集暂停时间短于指定值；然而，期望的暂停时间目标可能并不总能实现。这些调整可能会导致垃圾收集器降低应用程序的总吞吐量。
- 吞吐量:吞吐量目标是根据垃圾收集花费的时间与垃圾收集之外花费的时间(称为*应用程序时间*)来衡量的。目标由命令行选项`-XX:GCTimeRatio=<N>`指定，该选项将垃圾收集时间与应用程序时间的比率设置为1 / (1 + N)。例如，`-XX:GCTimeRatio=19`设置了垃圾收集总时间的1/20或5%的目标。默认值为99，因此垃圾收集的时间目标为1%。
- 占用空间:最大堆占用空间是使用选项`-Xmx`指定的。此外，收集器有一个隐含的目标，只要满足其他目标，就要最小化堆的大小。

#### 并行收集器指标的优先级

目标按最大暂停时间指标、吞吐量指标和最小占用空间指标顺序排列：首先要满足最大暂停时间指标，只有当最大暂停时间指标达到后才会去实现吞吐量的指标，同样只有前两个指标满足后才会考虑占用空间的指标。

#### 并行收集器各个分代空间调整

收集器保存的平均暂停时间等统计信息会在每次收集结束时更新。

进行测试，以确定目标是否已经实现，并对一代的空间进行任何必要的调整。例外情况是显式垃圾收集，例如，在保存统计信息和调整代的大小方面，将会忽略System.gc()调用的影响。

各个分代大小的增加和缩小是通过各代大小的固定百分比的增量来完成的，以便各个分代朝着其期望的大小递增或递减。默认情况下，一代以20%的增量增长，以5%的增量收缩。新生代和老年代的增长比例分别可以通过`-XX:YoungGenerationSizeIncrement=<Y>`和`-XX:TenuredGenerationSizeIncrement=<T>`指定。收缩比例通过`-XX:AdaptiveSizeDecrementScaleFactor=<D>`进行调整，如果增长比例是X%，那么收缩比例为X/D%。

如果收集器在启动时增加一代的大小，那么增量中会添加一个补充百分比。这种补充将会随着垃圾收集次数的增加而衰减，并不会长期存在。补充的目的是提高启动性能。收缩的百分比没有补充。

如果没有达到最大暂停时间目标，那么一次只能缩小一代的规模。如果两代的暂停时间都超过了目标，那么暂停时间较长的一代的规模将首先缩小。

如果吞吐量目标没有实现，那么两代的规模都会增加。每一个都按其对总垃圾收集时间的贡献比例增加。例如，如果新生代的垃圾收集时间是总收集时间的25%，如果新生代的完整增量是20%，那么年轻一代将增加5%。

#### 并行收集器默认堆大小

除非命令行中指定了初始堆大小和最大堆大小，否则它们是根据计算机上的内存量计算的。默认的最大堆大小是物理内存的四分之一，而初始堆大小是物理内存的六分之一。分配给新生代的最大空间量是总堆大小的三分之一。

##### 并行收集器初始和最大堆大小的规范

您可以使用选项-Xms(初始堆大小)和-Xmx(最大堆大小)指定初始和最大堆大小。

如果您知道您的应用程序需要多少堆才能正常工作，那么您可以将-Xms和-Xmx设置为相同的值。如果您不知道，那么JVM将从使用初始堆大小开始，然后增加Java堆，直到找到堆使用和性能之间的平衡。

其他参数和选项会影响这些默认值。要验证默认值，请使用`-XX:+PrintFlagsFinal`选项，并在输出中查找`-XX:MaxHeapSize`。例如，在Linux或Solaris上，您可以运行以下程序:
```
java -XX:+PrintFlagsFinal <GC options> -version | grep MaxHeapSize
```

### 过多的并行收集器时间和内存不足错误

如果在垃圾收集(垃圾收集)中花费了太多时间，并行收集器将抛出OutOfMemoryError。

如果总时间的98%以上花在垃圾收集上，并且回收的堆少于2%，则抛出OutOfMemoryError。此功能旨在防止应用程序长时间运行，同时由于堆太小而几乎没有进展。如有必要，可以通过向命令行添加选项`-XX:-UseGCOverheadLimit`来禁用此功能。

### 并行收集器度量

并行收集器的详细垃圾收集器输出与串行收集器的输出基本相同。

## 7 主要并发收集器

主要并发的收集器对应用程序并发执行部分工作，因此得名。Java HotSpot虚拟机包括两个主要并发的收集器:
- 并发标记清除(CMS)收集器:该收集器适用于那些更喜欢较短垃圾收集暂停时间并且能够与垃圾收集共享处理器资源的应用程序。
- 垃圾优先(G1)垃圾收集器:这种服务器风格的收集器适用于具有大量内存的多处理器机器。它旨在满足垃圾收集暂停时间目标，同时实现高吞吐量。

### 主要并发收集器的开销

主要并发收集器会占用处理器资源(否则应用程序可以使用这些资源)，以缩短主要收集暂停时间。

最明显的开销是在收集的并发部分使用一个或多个处理器。在N处理器系统中，集合的并发部分使用可用处理器的K/N，其中`1 <= K <=上限{N/4}`。除了在并发阶段使用处理器之外，启用并发还会产生额外的开销。因此，虽然并发收集器的垃圾收集暂停时间通常要短得多，但应用程序吞吐量也往往比其他收集器略低。

在具有多个处理核心的机器上，处理器在收集的并发部分可用于应用程序线程，因此并发垃圾收集器线程不会暂停应用程序。这通常会导致更短的暂停时间，但是应用程序可用的处理器资源也更少，并且应该会有一些减速，尤其是在应用程序最大限度地使用所有处理核心的情况下。随着N的增加，由于并发垃圾收集导致的处理器资源减少变得更小，并发收集的好处也增加了。请参阅[并发模式故障](https://docs.oracle.com/en/java/javase/12/gctuning/concurrent-mark-sweep-cms-collector.html#GUID-700D5A4A-75EE-4CDC-9A43-5DF8FEBE24DD)，其中讨论了这种扩展的潜在限制。

因为在并发阶段至少有一个处理器用于垃圾收集，所以并发收集器通常不会在单处理器(单核)机器上提供任何好处。

## 8 并发标记清除收集器

并发标记清除(CMS)收集器是为那些更喜欢较短垃圾收集暂停时间的应用程序设计的，并且能够在应用程序运行时与垃圾收集器共享处理器资源。

典型地，具有相对大的长寿命数据集(大的老一代)并且运行在具有两个或更多处理器的机器上的应用程序倾向于受益于该收集器的使用。CMS收集器使用`-XX:+UseConcMarkSweepGC`启用。

不推荐使用CMS收集器。强烈考虑改用垃圾优先收集器。

本节主题：
- 并发标记清除收集器的性能和结构
- 并发模式失败
- 过多的垃圾收集时间过长和内存不足错误
- 并发标记清除收集器和浮动垃圾
- 并发标记清除收集器暂停
- 并发标记清除收集器并发阶段
- 启动并发收集周期
- 计划暂停
- 并发标记清除收集器度量

### 并发标记清除收集器的性能和结构

与其他可用的收集器相似，CMS收集器是分代的；因此，minor collection和major collection都会发生。CMS收集器试图通过使用单独的垃圾收集器线程在执行应用程序线程的同时跟踪可到达的对象来减少由于major collection而导致的暂停时间。

在每个主要的收集周期中，CMS收集器会在收集开始时暂停所有应用程序线程一段时间，并再次暂停到收集的中间。第二次暂停往往比第一次较长。多个线程在两次暂停期间执行收集工作。一个或多个垃圾收集器线程完成剩余的收集工作(包括大部分对存活对象的跟踪和对不可达对象的清扫)。minor collection可以与正在进行的major collection交织，并且以类似于并行收集的方式完成(特别是，应用程序线程在minor collection期间停止)。

### 并发模式失败

CMS收集器使用一个或多个垃圾收集器线程，这些线程与应用程序线程同时运行，目的是在老年代变满之前完成老年代的收集。

如前所述，在正常操作中，CMS收集器在应用程序线程仍在运行的情况下执行大部分跟踪和扫描工作，因此应用程序线程只能看到短暂的暂停。但是，如果CMS收集器无法在老年代填满之前回收不可访问的对象，或者如果内存分配不能满足老年代中的可用空闲空间块，则应用程序会暂停，并且收集会在所有应用程序线程停止的情况下完成。无法并发完成收集被称为*并发模式故障*，表示需要调整CMS收集器参数。如果并发收集被显式垃圾收集(System.gc())或为诊断工具提供信息所需的垃圾收集中断，则报告并发模式中断。

### 过多的垃圾收集时间过长和内存不足错误

如果在垃圾收集中花费了太多时间，CMS收集器将抛出OutOfMemoryError:如果总时间的98%以上花费在垃圾收集中，并且恢复的堆少于2%，则抛出OutOfMemoryError。

此功能旨在防止应用程序长时间运行，同时由于堆太小而几乎没有进展。如有必要，可以通过向命令行添加选项`-XX:-UseGCOverheadLimit`来禁用此功能。

该策略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入98%的时间限制。换句话说，只有在应用程序停止时执行的收集才会计入过多的垃圾收集时间。这种收集通常是由于并发模式失败或显式收集请求(例如，对System.gc()的调用)。

### 并发标记清除收集器和浮动垃圾

同Java HotSpot虚拟机中的所有其他收集器一样，CMS收集器是一个跟踪收集器，它需要标识堆中所有可到达的对象。

理查德·琼斯和拉斐尔·林在他们的出版物《垃圾收集:自动动态内存算法》中说，这是一个增量更新收集器。因为应用程序线程和垃圾收集器线程在主要收集过程中同时运行，垃圾收集器线程跟踪的对象可能随后在收集过程结束时变得不可访问。这种尚未被回收的不可达对象被称为*浮动垃圾*。浮动垃圾的数量取决于并发收集周期的持续时间和应用程序引用更新的频率，也称为*突变(mutations)*。此外，因为年轻一代和老一代是独立收集的，所以每一代都是彼此的根源。作为一个粗略的指导方针，试着将老年代的空间增加20%，以解决漂浮垃圾的问题。一个并发收集周期结束时堆中的浮动垃圾将在下一个收集周期中收集。

### 并发标记清除收集器暂停

CMS收集器在并发收集周期内暂停应用程序两次。第一个暂停是将从根(例如，来自应用程序线程堆栈和寄存器的对象引用、静态对象等)和堆中其他地方(例如，新生代)直接可到达的对象标记为存活对象。

第一次暂停称为*初始标记暂停(initial mark pause)*。第二个暂停发生在并发跟踪阶段的末尾，并在CMS收集器完成对对象的跟踪后，查找由于应用程序线程更新对象中的引用而被并发跟踪遗漏的对象。这第二次暂停被称为*备注暂停(remark pause)*。

### 并发标记清除收集器并发阶段

可达对象图的并发跟踪发生在初始标记暂停和备注暂停之间。

在这个并发跟踪阶段，一个或多个并发垃圾收集器线程可能正在使用处理器资源，否则这些资源对于应用程序是可用的。因此，即使应用程序线程没有暂停，在此阶段和其他并发阶段，计算绑定应用程序的吞吐量也会相应降低。备注暂停后，并发清理阶段收集不可达的对象。收集周期完成后，CMS收集器等待，几乎不消耗计算资源，直到下一个主要收集周期开始。

### 启动并发收集周期

对于串行收集器，每当老年代变满，并且在收集完成时所有应用程序线程都停止时，就会出现一个major collection。相比之下，CMS收集器中并发收集的开始时间必须确保收集能够在老年代变满之前完成；否则，由于并发模式失败，应用程序会观察到较长的暂停时间。有几种方法可以开始并发收集。

根据最近的历史记录，CMS收集器会对老年代耗尽之前剩余的时间以及并发收集周期所需的时间进行估计。使用这些动态估计，开始并发收集周期，目的是在老年代耗尽之前完成收集周期。为了安全起见，对这些估计进行了填充，因为并发模式故障的代价可能非常高。

如果老年代的占用率超过初始占用率(老一代的百分比)，并发收集也会开始。启动并发周期阈值的默认值约为92%，但该值会随版本的不同而变化。该值可以使用命令行选项`-XX:CMSInitiatingOccupancyFraction=<N>`手动调整，其中N是老年代大小的整数百分比(0到100)。

### 计划暂停

新生代和老年代的暂停是独立发生的。

它们不会重叠，但可能会快速连续发生，一次收集的暂停，紧接着另一次收集的暂停，看起来可能是一个更长的暂停。为了避免这种情况，CMS收集器试图将备注暂停安排在上一次和下一次新生代暂停的中间。当前没有为初始标记暂停进行这种调度，初始标记暂停通常比备注暂停短得多。

### 并发标记清除收集器度量

以下是带有选项`-Xlog:gc`的CMS收集器的输出:
```
[121,834s][info][gc] GC(657) Pause Initial Mark 191M->191M(485M) (121,831s, 121,834s) 3,433ms
[121,835s][info][gc] GC(657) Concurrent Mark (121,835s)
[121,889s][info][gc] GC(657) Concurrent Mark (121,835s, 121,889s) 54,330ms
[121,889s][info][gc] GC(657) Concurrent Preclean (121,889s)
[121,892s][info][gc] GC(657) Concurrent Preclean (121,889s, 121,892s) 2,781ms
[121,892s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s)
[121,949s][info][gc] GC(658) Pause Young (Allocation Failure) 324M->199M(485M) (121,929s, 121,949s) 19,705ms
[122,068s][info][gc] GC(659) Pause Young (Allocation Failure) 333M->200M(485M) (122,043s, 122,068s) 24,892ms
[122,075s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s, 122,075s) 182,989ms
[122,087s][info][gc] GC(657) Pause Remark 209M->209M(485M) (122,076s, 122,087s) 11,373ms
[122,087s][info][gc] GC(657) Concurrent Sweep (122,087s)
[122,193s][info][gc] GC(660) Pause Young (Allocation Failure) 301M->165M(485M) (122,181s, 122,193s) 12,151ms
[122,254s][info][gc] GC(657) Concurrent Sweep (122,087s, 122,254s) 166,758ms
[122,254s][info][gc] GC(657) Concurrent Reset (122,254s)
[122,255s][info][gc] GC(657) Concurrent Reset (122,254s, 122,255s) 0,952ms
[122,297s][info][gc] GC(661) Pause Young (Allocation Failure) 259M->128M(485M) (122,291s, 122,297s) 5,797ms
```

> 注意：CMS收集器的输出(GC标识657)与minor collection的输出(GC标识658、659和660)穿插在一起；通常，许多minor collection发生在并发收集周期中。暂停初始标记(Pause Initial Mark)表示并发收集周期的开始。以Concurrent为开头的行表示并发阶段的开始和结束。Pause Remark是最后的暂停。前面没有讨论预清洗阶段。预清洁是指在准备备注阶段可以同时完成的工作。最后阶段由并发重置指示(Concurrent Reset)，并为下一个并发收集做准备。

初始标记暂停通常相对于minor collection暂停时间较短。并发阶段(并发标记、并发预清除和并发清除)通常持续的时间比minor collection暂停时间长得多，如CMS收集器输出示例所示。但是，请注意，在这些并发阶段，应用程序不会暂停。备注暂停的长度通常相当于一个minor collection。备注暂停受某些应用程序特征(例如，对象修改率高会增加暂停)和自上次minor collection以来的时间(例如，新生代中的更多对象可能会增加暂停)的影响。

## 9 垃圾优先收集器

本节介绍垃圾优先(G1)收集器。

本节主题：
- 垃圾优先收集器简介
- 启用垃圾优先收集器
- 基本概念
    - 堆布局
    - 垃圾收集周期
- 深入垃圾优先收集器内部
    - 确定初始堆占用率
    - 标记
    - 堆资源紧张下的行为
    - 大对象
    - 纯新生代收集规模
    - 空间回收阶段收集规模
- G1的工程学默认值
- 与其他收集器的对比

### 垃圾优先收集器简介

垃圾优先(G1)收集器针对具有大量内存的多处理器机器。它试图以高概率达到垃圾收集暂停时间目标，同时无需配置就能实现高吞吐量。G1旨在利用当前目标应用程序和环境在延迟和吞吐量之间实现最佳平衡，这些应用程序和环境的功能包括:
- 堆大小高达几十GB或更大，超过50%的Java堆被存活数据占据。
- 随着时间的推移，对象分配和升级的速率可能会有很大变化。
- 堆中有大量碎片。
- 可预测的暂停时间目标，不超过几百毫秒，避免长时间的垃圾收集暂停。

G1取代了并发标记清除(CMS)收集器。它也是默认的收集器。

G1采集器实现了高性能，并试图通过以下几节中描述的几种方式来实现暂停时间目标。

### 启用垃圾优先收集器

垃圾优先垃圾收集器是默认收集器，因此通常您不必执行任何额外的操作。您可以通过在命令行上提供`-XX:+UseG1GC`来显式启用它。

### 基本概念

G1是一个分代的、渐进的、并发的、疏散垃圾收集器，它监控每次stop-the-world暂停中的暂停时间目标。与其他收集器一样，G1将这堆分成(虚拟的)新生代和老年代。空间回收工作集中在最有效的新生代，而老年代偶尔会进行空间回收。

为了提高吞吐量，有些操作总是在stop-the-world时执行。停止应用程序需要更多时间的其他操作(如*全局标记*等整体堆操作)与应用程序并行执行。为了让空间回收时stop-the-world的时间更短，G1逐步并行地进行空间回收。G1通过跟踪关于先前应用程序行为和垃圾收集暂停的信息来建立相关成本的模型，从而实现可预测性。它使用这些信息来调整暂停中完成的工作。例如，G1首先回收最高效区域的空间(即大部分被垃圾填满的区域，因此得名)。

G1主要通过疏散来回收空间:在选定的存储区域中发现的要收集的存活对象被复制到新的存储区域中，在这个过程中对它们进行压缩。疏散完成后，先前由存活对象占据的空间将被应用程序重新用于分配。

垃圾优先收集器不是实时收集器。它试图在更长的时间内以高概率达到设定的暂停时间目标，但对于给定的暂停并不总是绝对确定的。

#### 堆布局

G1将堆分成一组大小相等的堆区域，每个区域都是一个连续的虚拟内存范围，如图9-1所示。区域是内存分配和内存回收的单位。在任何给定的时间，这些区域中的每一个都可以是空的(浅灰色)，或者分配给特定的一代，新生的或老年的。当内存请求进来时，内存管理器会分发空闲区域。内存管理器将它们分配给一代，然后将它们作为空闲空间返回给应用程序，应用程序可以将它们分配给自己。

![G1堆布局](https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_004_grbg_frst_hp.png)

新生代包含eden区域(红色)和survivor区域(红色带“S”)。这些区域提供了与其他收集器中相应的连续空间相同的功能，不同之处在于，在G1，这些区域通常在内存中以不连续的模式排列。(浅蓝色)组成了老年代。对于跨越多个区域的对象，老年代区域可能非常大(浅蓝色，带“H”)。

一个应用程序总是分配新生代，也就是eden区域，除了那些被直接分配给老年代的巨大对象。

#### 垃圾收集周期

在高层次上，G1收集器在两个阶段之间交替。纯年轻阶段(young-only)包含垃圾收集，这些垃圾收集逐渐用老年代中的对象填充当前可用的内存。空间回收阶段(space-reclamation)，G1除了处理新生代的事务外，还逐步回收老年代的空间。然后，循环从一个纯年轻的阶段重新开始。

图9-2给出了这个循环的概述，并举例说明了可能发生的垃圾收集暂停序列:

![垃圾收集周期](https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_001_grbgcltncyl.png)

下面的列表详细描述了G1垃圾收集周期的各个阶段、它们的暂停以及各个阶段之间的过渡:
1. 纯年轻阶段:这个阶段从几个普通的收集开始，这些收集将对象升级到老年代。纯年轻阶段和空间回收阶段之间的过渡开始于老年代占用率达到某个阈值(启动堆占用率阈值)时。此时，G1计划启动并发新生代收集(Concurrent Start young collection)，而不是普通新生代收集(Normal young collection)。
    - 并发开始(Concurrent Start):这种类型的收集除了执行普通的收集之外，还开始标记过程。并发标记决定了老年代区域中所有当前可到达(活动)的对象将被保留到下一个空间回收阶段。虽然收集标记尚未完全完成，但可能会出现普通的新生代收集。标记结束时有两个特殊stop-the-world停顿:备注(Remark)和清理(Cleanup)。
    - 备注(Remark)：这种暂停完成标记本身，执行全局引用处理和类卸载，回收完全空的区域并清理内部数据结构。在“备注”和“清理”之间，G1计算信息，以便以后能够同时回收选定老年代区域中的可用空间，这将在“清理”暂停中完成。
    - 清理(Cleanup)：这一暂停决定了空间回收阶段是否会真正到来。如果随后是空间回收阶段，则纯年轻阶段将通过单个混合新生代收集来完成。
2. 空间回收阶段：该阶段包括多个混合收集，除新生代区域外，还疏散老年代区域集合中的活动对象。当G1确定疏散更多的老年代不会产生足够的空闲空间时，空间回收阶段就结束了。

空间回收后，收集周期从另一个纯年轻阶段重新开始。作为备份，如果应用程序在收集活动信息时耗尽内存，G1会像其他收集器一样执行就地停止的完整堆压缩(完整垃圾收集)。

#### 垃圾收集暂停和收集集合

G1在stop-the-world暂停时进行垃圾收集和空间回收。活动对象通常从源区域复制到堆中的一个或多个目标区域，并调整对这些移动对象的现有引用。

对于非大型区域，对象的目标区域由该对象的源区域确定:
- 新生代的对象(eden和survivor区域)被复制到survivor或老年代，这取决于他们的年龄。
- 老年代区域的对象被复制到其他老年代区域。

巨大区域中的对象被区别对待。G1只决定他们的活跃度，如果他们不活着，收回他们占据的空间。巨大区域内的物体不会被G1移动。

收集集和是要从中回收空间的源区域集。根据垃圾收集的类型，收集集由不同类型的区域组成:
- 在纯年轻阶段，集合仅由新生代中的区域和具有潜在可回收对象的巨大区域组成。
- 在空间回收阶段，由新生代的区域、具有潜在可回收对象的巨大区域以及收集组候选区域中的一些老年代区域组成。

G1在并发周期中准备收集候选区域。在备注暂停期间，G1选择占用空间低的区域，这些区域包含大量可用空间。然后，在“备注”和“清理”暂停之间同时准备这些区域，以便以后收集。清理暂停会根据效率对准备结果进行排序。在随后的混合收集中，优先选择包含更多空闲空间的更有效的区域，这些区域收集时间更少。

### 深入垃圾优先收集器内部

本节描述了垃圾优先(G1)垃圾收集器的一些重要细节。

#### 确定初始堆占用率

G1在调整Java堆的大小时遵守标准规则，使用`-XX:InitialHeapSize`作为最小Java堆大小，`-XX:MaxHeapSize`作为最大Java堆大小，`-XX:MinHeapFreeRatio`代表最小可用内存比率，`-XX:MaxHeapFreeRatio`用于确定调整大小后最大可用内存百分比。G1收集器在备注暂停和完整收集中调整Java堆的大小。此过程可能会向操作系统释放内存或从操作系统分配内存。

#### 纯新生代收集规模

G1总是在下一个突变阶段的普通新生代收集结束时对新生代进行评估。通过对实际暂停时间长时间的观察，G1可以达到使用`-XX:MaxGCPauseTimeMillis`和`-XX:PauseTimeIntervalMillis`设置的暂停时间目标。它考虑到了相似大小的年轻一代撤离需要多长时间。
